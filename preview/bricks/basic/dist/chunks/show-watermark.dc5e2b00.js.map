{"version":3,"file":"chunks/show-watermark.dc5e2b00.js","mappings":"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","sources":["webpack:///./src/data-providers/show-watermark/getClips.ts","webpack:///./src/data-providers/show-watermark/show-watermark.tsx"],"sourcesContent":["import { WatermarkProps } from \"./show-watermark.js\";\n\nexport const FontGap = 3;\n\nfunction prepareCanvas(\n  width: number,\n  height: number,\n  ratio: number = 1\n): [\n  ctx: CanvasRenderingContext2D,\n  canvas: HTMLCanvasElement,\n  realWidth: number,\n  realHeight: number,\n] {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\")!;\n\n  const realWidth = width * ratio;\n  const realHeight = height * ratio;\n  canvas.setAttribute(\"width\", `${realWidth}px`);\n  canvas.setAttribute(\"height\", `${realHeight}px`);\n  ctx.save();\n\n  return [ctx, canvas, realWidth, realHeight];\n}\n\nexport function getClips(\n  content: NonNullable<WatermarkProps[\"content\"]> | HTMLImageElement,\n  rotate: number,\n  ratio: number,\n  width: number,\n  height: number,\n  font: Required<NonNullable<WatermarkProps[\"font\"]>>,\n  gapX: number,\n  gapY: number\n): [dataURL: string, finalWidth: number, finalHeight: number] {\n  // ================= Text / Image =================\n  const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(\n    width,\n    height,\n    ratio\n  );\n\n  if (content instanceof HTMLImageElement) {\n    // Image\n    ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n  } else {\n    // Text\n    const { color, fontSize, fontStyle, fontWeight, fontFamily, textAlign } =\n      font;\n    const mergedFontSize = Number(fontSize) * ratio;\n\n    ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;\n    ctx.fillStyle = color;\n    ctx.textAlign = textAlign;\n    ctx.textBaseline = \"top\";\n    const contents = Array.isArray(content) ? content : [content];\n    contents?.forEach((item, index) => {\n      ctx.fillText(\n        item ?? \"\",\n        contentWidth / 2,\n        index * (mergedFontSize + FontGap * ratio)\n      );\n    });\n  }\n\n  // ==================== Rotate ====================\n  const angle = (Math.PI / 180) * Number(rotate);\n  const maxSize = Math.max(width, height);\n  const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);\n\n  // Copy from `ctx` and rotate\n  rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n  rCtx.rotate(angle);\n  if (contentWidth > 0 && contentHeight > 0) {\n    rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n  }\n\n  // Get boundary of rotated text\n  function getRotatePos(x: number, y: number) {\n    const targetX = x * Math.cos(angle) - y * Math.sin(angle);\n    const targetY = x * Math.sin(angle) + y * Math.cos(angle);\n    return [targetX, targetY];\n  }\n\n  let left = 0;\n  let right = 0;\n  let top = 0;\n  let bottom = 0;\n\n  const halfWidth = contentWidth / 2;\n  const halfHeight = contentHeight / 2;\n  const points = [\n    [0 - halfWidth, 0 - halfHeight],\n    [0 + halfWidth, 0 - halfHeight],\n    [0 + halfWidth, 0 + halfHeight],\n    [0 - halfWidth, 0 + halfHeight],\n  ];\n  points.forEach(([x, y]) => {\n    const [targetX, targetY] = getRotatePos(x, y);\n    left = Math.min(left, targetX);\n    right = Math.max(right, targetX);\n    top = Math.min(top, targetY);\n    bottom = Math.max(bottom, targetY);\n  });\n\n  const cutLeft = left + realMaxSize / 2;\n  const cutTop = top + realMaxSize / 2;\n  const cutWidth = right - left;\n  const cutHeight = bottom - top;\n\n  // ================ Fill Alternate ================\n  const realGapX = gapX * ratio;\n  const realGapY = gapY * ratio;\n  const filledWidth = (cutWidth + realGapX) * 2;\n  const filledHeight = cutHeight + realGapY;\n\n  const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);\n\n  function drawImg(targetX = 0, targetY = 0) {\n    fCtx.drawImage(\n      rCanvas,\n      cutLeft,\n      cutTop,\n      cutWidth,\n      cutHeight,\n      targetX,\n      targetY,\n      cutWidth,\n      cutHeight\n    );\n  }\n  drawImg();\n  drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n  drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n\n  return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n}\n","import { getCurrentTheme } from \"@next-core/runtime\";\nimport { FontGap, getClips } from \"./getClips.js\";\nimport { createProviderClass } from \"@next-core/utils/general\";\n\nexport interface WatermarkProps {\n  container?: HTMLElement | string;\n  content?: string | string[];\n  zIndex?: number;\n  rotate?: number;\n  width?: number;\n  height?: number;\n  image?: string;\n  font?: {\n    color?: CanvasFillStrokeStyles[\"fillStyle\"];\n    fontSize?: number | string;\n    fontWeight?: \"normal\" | \"light\" | \"weight\" | number;\n    fontStyle?: \"none\" | \"normal\" | \"italic\" | \"oblique\";\n    fontFamily?: string;\n    textAlign?: CanvasTextAlign;\n  };\n  style?: React.CSSProperties;\n  gap?: [number, number];\n  offset?: [number, number];\n}\n\nconst DEFAULT_GAP_X = 100;\nconst DEFAULT_GAP_Y = 100;\n\nconst watermarkMap = new WeakMap<HTMLElement, HTMLDivElement>();\nconst observeMap = new WeakMap<HTMLElement, MutationObserver>();\n\nfunction toLowercaseSeparator(key: string) {\n  return key.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n}\n\nfunction getStyleStr(style: React.CSSProperties): string {\n  return Object.keys(style)\n    .map(\n      (key) =>\n        `${toLowercaseSeparator(key)}: ${style[key as keyof React.CSSProperties]};`\n    )\n    .join(\" \");\n}\n\nconst appendWatermark = (\n  base64Url: string,\n  markWidth: number,\n  container: HTMLElement,\n  style: React.CSSProperties\n) => {\n  if (container) {\n    const element = watermarkMap.get(container);\n    const hadElement = element && container.contains(element);\n    if (!hadElement) {\n      const newWatermarkEle = document.createElement(\"div\");\n      watermarkMap.set(container, newWatermarkEle);\n    }\n\n    const watermarkEle = watermarkMap.get(container)!;\n\n    const defaultStyle = getStyleStr({\n      ...style,\n      backgroundImage: `url('${base64Url}')`,\n      backgroundSize: `${Math.floor(markWidth)}px`,\n    });\n    const elementStyle = watermarkEle.getAttribute(\"style\");\n\n    if (elementStyle !== defaultStyle) {\n      watermarkEle.setAttribute(\"style\", defaultStyle);\n    }\n\n    // Prevents using the browser `Hide Element` to hide watermarks\n    watermarkEle.hasAttribute(\"class\") && watermarkEle.removeAttribute(\"class\");\n\n    !hadElement && container.append(watermarkEle);\n  }\n};\n\nexport function showWaterMark({\n  zIndex = 9,\n  rotate = -22,\n  width,\n  height,\n  image,\n  content,\n  font = {},\n  style,\n  container: _container,\n  gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],\n}: WatermarkProps): void {\n  const computedContainer = (\n    element?: HTMLElement | string\n  ): HTMLElement | null => {\n    if (typeof element === \"string\") {\n      return document.querySelector(element);\n    }\n    return element ?? document.body;\n  };\n  const container = computedContainer(_container);\n  if (!container) return;\n  const containerObserve = observeMap.get(container);\n\n  if (containerObserve) {\n    observeMap.delete(container);\n    containerObserve.disconnect();\n  }\n\n  const {\n    color,\n    fontSize = \"14\",\n    fontWeight = \"normal\",\n    fontStyle = \"normal\",\n    fontFamily = \"sans-serif\",\n    textAlign = \"center\",\n  } = font;\n\n  const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;\n\n  const mergedStyle: React.CSSProperties = {\n    zIndex,\n    position: \"absolute\",\n    left: 0,\n    top: 0,\n    width: \"100%\",\n    height: \"100%\",\n    pointerEvents: \"none\",\n    backgroundRepeat: \"repeat\",\n  };\n\n  const defaultStyle = {\n    ...mergedStyle,\n    ...style,\n  };\n\n  const getMarkSize = (ctx: CanvasRenderingContext2D) => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const sizes = contents.map((item) => {\n        const metrics = ctx.measureText(item!);\n\n        return [\n          metrics.width,\n          metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent,\n        ];\n      });\n      defaultWidth = Math.ceil(Math.max(...sizes.map((size) => size[0])));\n      defaultHeight =\n        Math.ceil(Math.max(...sizes.map((size) => size[1]))) * contents.length +\n        (contents.length - 1) * FontGap;\n    }\n    return [width ?? defaultWidth, height ?? defaultHeight] as const;\n  };\n\n  const renderWatermark = () => {\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n\n    if (ctx) {\n      const ratio = 1;\n      const [markWidth, markHeight] = getMarkSize(ctx);\n\n      const drawCanvas = (\n        drawContent?: NonNullable<WatermarkProps[\"content\"]> | HTMLImageElement\n      ) => {\n        const [nextClips, clipWidth] = getClips(\n          drawContent || \"\",\n          rotate,\n          ratio,\n          markWidth,\n          markHeight,\n          {\n            color: color\n              ? color\n              : getCurrentTheme() === \"light\"\n                ? \"rgba(0, 0, 0, 0.15)\"\n                : \"rgba(255, 255, 255, 0.4)\",\n            fontSize,\n            fontStyle,\n            fontWeight,\n            fontFamily,\n            textAlign,\n          },\n          gapX,\n          gapY\n        );\n\n        appendWatermark(nextClips, clipWidth, container, defaultStyle);\n      };\n\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          drawCanvas(img);\n        };\n        img.onerror = () => {\n          drawCanvas(content);\n        };\n        img.crossOrigin = \"anonymous\";\n        img.referrerPolicy = \"no-referrer\";\n        img.src = image;\n      } else {\n        drawCanvas(content);\n      }\n    }\n  };\n\n  const reRendering = (mutation: MutationRecord) => {\n    let flag = false;\n    // Whether to delete the watermark node\n    if (mutation.removedNodes.length) {\n      flag = Array.from<Node>(mutation.removedNodes).some(\n        (node) => watermarkMap.get(container) === node\n      );\n    }\n    // Whether the watermark dom property value has been modified\n    if (\n      mutation.type === \"attributes\" &&\n      watermarkMap.get(container) === mutation.target\n    ) {\n      flag = true;\n    }\n    return flag;\n  };\n\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (reRendering(mutation)) {\n        renderWatermark();\n      }\n    });\n  });\n\n  observer.observe(container, {\n    subtree: true,\n    childList: true,\n    attributeFilter: [\"style\", \"class\"],\n  });\n\n  observeMap.set(container, observer);\n\n  window.addEventListener(\"theme.change\", renderWatermark);\n\n  renderWatermark();\n}\n\ncustomElements.define(\n  \"basic.show-watermark\",\n  createProviderClass(showWaterMark)\n);\n"],"names":["FontGap","prepareCanvas","width","height","ratio","arguments","length","undefined","canvas","document","createElement","ctx","getContext","realWidth","realHeight","setAttribute","save","getClips","content","rotate","font","gapX","gapY","contentWidth","contentHeight","HTMLImageElement","drawImage","color","fontSize","fontStyle","fontWeight","fontFamily","textAlign","mergedFontSize","Number","fillStyle","textBaseline","contents","Array","isArray","forEach","item","index","fillText","angle","Math","PI","maxSize","max","rCtx","rCanvas","realMaxSize","translate","left","right","top","bottom","halfWidth","halfHeight","_ref","x","y","targetX","targetY","cos","sin","getRotatePos","min","cutLeft","cutTop","cutWidth","cutHeight","realGapX","realGapY","filledWidth","filledHeight","fCtx","fCanvas","drawImg","toDataURL","DEFAULT_GAP_X","DEFAULT_GAP_Y","watermarkMap","WeakMap","observeMap","appendWatermark","base64Url","markWidth","container","style","element","get","hadElement","contains","newWatermarkEle","set","watermarkEle","defaultStyle","Object","keys","map","key","replace","toLowerCase","toLowercaseSeparator","join","getStyleStr","backgroundImage","backgroundSize","floor","getAttribute","hasAttribute","removeAttribute","append","showWaterMark","zIndex","image","_container","gap","querySelector","body","containerObserve","delete","disconnect","position","pointerEvents","backgroundRepeat","renderWatermark","markHeight","defaultWidth","defaultHeight","measureText","sizes","metrics","fontBoundingBoxAscent","fontBoundingBoxDescent","ceil","size","getMarkSize","drawCanvas","drawContent","nextClips","clipWidth","getCurrentTheme","img","Image","onload","onerror","crossOrigin","referrerPolicy","src","observer","MutationObserver","mutations","mutation","flag","removedNodes","from","some","node","type","target","reRendering","observe","subtree","childList","attributeFilter","window","addEventListener","customElements","define","createProviderClass"],"sourceRoot":""}