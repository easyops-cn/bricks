"use strict";(globalThis.webpackChunk_next_bricks_basic=globalThis.webpackChunk_next_bricks_basic||[]).push([[1122],{4586:(e,n,t)=>{t.d(n,{A:()=>i});var r=t(1369);function i(e,n,t){return(n=(0,r.A)(n))in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}},1369:(e,n,t)=>{t.d(n,{A:()=>i});var r=t(7545);function i(e){var n=function(e,n){if("object"!=(0,r.A)(e)||!e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var i=t.call(e,"string");if("object"!=(0,r.A)(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==(0,r.A)(n)?n:n+""}},7545:(e,n,t)=>{function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}t.d(n,{A:()=>r})},1122:(e,n,t)=>{t.r(n),t.d(n,{__dev_only_clearGlobalExecutionContextStack:()=>W,__dev_only_getGlobalExecutionContextStack:()=>q,clearExpressionASTCache:()=>ae,clearFunctionASTCache:()=>ee,cook:()=>G,isEvaluable:()=>re,isTrackAll:()=>oe,precook:()=>K,precookFunction:()=>Y,preevaluate:()=>te,shouldAllowRecursiveEvaluations:()=>ie});var r=t(4586);let i=function(e){return e[e.LEXICAL=0]="LEXICAL",e[e.STRICT=1]="STRICT",e}({});const o=Symbol.for("SourceNode"),a=Symbol.for("FormalParameters"),s=Symbol.for("ECMAScriptCode"),c=Symbol.for("Environment"),l=Symbol.for("IsConstructor"),u=Symbol.for("ThisMode"),d=Symbol.for("$DebuggerCall$"),f=Symbol.for("$DebuggerScope$"),y=Symbol.for("$DebuggerNode$"),p=Symbol.for("$DebuggerReturn$");class m{constructor(){(0,r.A)(this,"VariableEnvironment",void 0),(0,r.A)(this,"LexicalEnvironment",void 0),(0,r.A)(this,"Function",void 0)}}let v=function(e){return e[e.UNINITIALIZED=0]="UNINITIALIZED",e[e.LEXICAL=1]="LEXICAL",e[e.INITIALIZED=2]="INITIALIZED",e}({});class g{constructor(e){(0,r.A)(this,"OuterEnv",void 0),(0,r.A)(this,"bindingMap",new Map),(0,r.A)(this,"ThisValue",void 0),(0,r.A)(this,"ThisBindingStatus",void 0),this.OuterEnv=e}HasBinding(e){return this.bindingMap.has(e)}CreateMutableBinding(e,n){return this.bindingMap.set(e,{mutable:!0,deletable:n}),x(void 0)}CreateImmutableBinding(e,n){return this.bindingMap.set(e,{strict:n}),x(void 0)}InitializeBinding(e,n){const t=this.bindingMap.get(e);return Object.assign(t,{initialized:!0,value:n}),x(void 0)}SetMutableBinding(e,n,t){const r=this.bindingMap.get(e);if(!r.initialized)throw new ReferenceError(`${e} is not initialized`);if(!r.mutable)throw new TypeError("Assignment to constant variable");return r.value=n,x(void 0)}GetBindingValue(e,n){const t=this.bindingMap.get(e);if(!t.initialized)throw new ReferenceError(`${e} is not initialized`);return t.value}HasThisBinding(){return!1}}class h extends g{}class b extends g{constructor(e){super(e[c]),e[u]===i.LEXICAL?this.ThisBindingStatus=v.LEXICAL:this.ThisBindingStatus=v.UNINITIALIZED}HasThisBinding(){return this.ThisBindingStatus!==v.LEXICAL}BindThisValue(e){if(this.ThisBindingStatus===v.INITIALIZED)throw new Error("This binding has been initialized");this.ThisValue=e,this.ThisBindingStatus=v.INITIALIZED}GetThisBinding(){if(this.ThisBindingStatus===v.UNINITIALIZED)throw new Error("This binding is not initialized");return this.ThisValue}}class E{constructor(e,n,t){(0,r.A)(this,"Base",void 0),(0,r.A)(this,"ReferenceName",void 0),(0,r.A)(this,"Strict",void 0),this.Base=e,this.ReferenceName=n,this.Strict=t}}class w{constructor(e,n){(0,r.A)(this,"Type",void 0),(0,r.A)(this,"Value",void 0),this.Type=e,this.Value=n}}function x(e){return new w("normal",e)}const S=Symbol("empty completion");function A(e){const n=new Set,t=e=>{if(Array.isArray(e))for(const n of e)t(n);else if(e)switch(e.type){case"Identifier":return void n.add(e.name);case"VariableDeclaration":return t(e.declarations);case"VariableDeclarator":case"FunctionDeclaration":return t(e.id);case"ArrayPattern":return t(e.elements);case"AssignmentPattern":return t(e.left);case"ObjectPattern":return t(e.properties);case"Property":return t(e.value);case"RestElement":return t(e.argument)}};return t(e),Array.from(n)}function L(e){const n=e=>{if(Array.isArray(e))return e.some(n);if(e)switch(e.type){case"ArrayPattern":return n(e.elements);case"AssignmentPattern":return!0;case"ObjectPattern":return n(e.properties);case"Property":return e.computed||n(e.value);case"RestElement":return n(e.argument)}};return n(e)}function B(e,n){const t=[],r={var:n.var},i=(e,n)=>{if(Array.isArray(e))for(const t of e)i(t,n);else if(e){switch(e.type){case"FunctionDeclaration":return void(Number(!n.var)^Number(n.topLevel)&&t.push(e));case"VariableDeclaration":return void(Number(!n.var)^Number("var"===e.kind)&&t.push(e));case"SwitchCase":return void i(e.consequent,r);case"CatchClause":return void i(e.body,r)}if(n.var)switch(e.type){case"BlockStatement":case"DoWhileStatement":case"WhileStatement":return void i(e.body,r);case"IfStatement":return i(e.consequent,r),void i(e.alternate,r);case"ForStatement":return i(e.init,r),void i(e.body,r);case"ForInStatement":case"ForOfStatement":return i(e.left,r),void i(e.body,r);case"SwitchStatement":return void i(e.cases,r);case"TryStatement":return i(e.block,r),i(e.handler,r),void i(e.finalizer,r)}}};return i(e,n),t}function I(e){return"unresolvable"!==e.Base&&!(e.Base instanceof g)}function T(e,n){return e.Base.InitializeBinding(e.ReferenceName,n)}function C(e,n,t){if(null==n)return e;const r=Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));for(const i of r)if(!t.has(i)){const t=Object.getOwnPropertyDescriptor(n,i);null!=t&&t.enumerable&&(e[i]=n[i])}return e}function k(e,n){const t="const"===e.kind;for(const r of A(e))t?n.CreateImmutableBinding(r,!0):n.CreateMutableBinding(r,!1)}function V(e){return"normal"===e.Type||"continue"==e.Type}function P(e,n){return e.Value!==S?e:new w(e.Type,n)}function O(e){if(e instanceof w&&(e=e.Value),!(e instanceof E))return e;if("unresolvable"===e.Base)throw new ReferenceError(`${e.ReferenceName} is not defined`);return e.Base instanceof g?e.Base.GetBindingValue(e.ReferenceName,e.Strict):e.Base[e.ReferenceName]}function F(e){return"symbol"==typeof e?e:String(e)}function j(e,n){return e[n]}function D(e,n){if("unresolvable"===e.Base)throw new ReferenceError(`${e.ReferenceName} is not defined`);return e.Base instanceof g?e.Base.SetMutableBinding(e.ReferenceName,n,e.Strict):(e.Base[e.ReferenceName]=n,x(void 0))}function M(e){if(n=e,!(Array.isArray(n)||null!=n&&"function"==typeof n[Symbol.iterator]))throw new TypeError(typeof e+" is not iterable");var n;return e[Symbol.iterator]()}function R(e){if(null==e)throw new TypeError("Cannot destructure properties of undefined or null")}function N(e,n,t){return e?e.HasBinding(n)?new E(e,n,t):N(e.OuterEnv,n,t):new E("unresolvable",n,t)}function $(e,n,t){switch(n){case"+":return e+t;case"-":return e-t;case"/":return e/t;case"%":return e%t;case"*":return e*t;case"**":return e**t;case"==":return e==t;case"===":return e===t;case"!=":return e!=t;case"!==":return e!==t;case">":return e>t;case"<":return e<t;case">=":return e>=t;case"<=":return e<=t;case"in":return e in t}throw new SyntaxError(`Unsupported binary operator \`${n}\``)}const z=new WeakSet([Function,Object,Function.prototype,Object.prototype,function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}()]),_=new WeakSet([Array,Map,Set,URL,URLSearchParams,WeakMap,WeakSet,RegExp]),U=[];function W(){U.length=0}function q(){return U}function G(e,n){var t;let{rules:r,debug:v,externalSourceForDebug:g,globalVariables:W={},ArrayConstructor:q=Array,hooks:G={}}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const Z="FunctionDeclaration"!==e.type;function H(e){g||function(e){if(z.has(e))throw new TypeError("Cannot access reserved objects such as `Function`.")}(e)}const K=new h(null),J=new m;J.VariableEnvironment=K,J.LexicalEnvironment=K;const Q=[J];for(const[e,n]of Object.entries(W))K.CreateImmutableBinding(e,!0),K.InitializeBinding(e,n);const Y=new WeakMap;let ee;function*ne(e,t,r){var i,o;switch(null===(i=G.beforeEvaluate)||void 0===i||i.call(G,e),ee=e,v&&(r||e.type.endsWith("Statement")&&("ExpressionStatement"!==e.type||"CallExpression"!==e.expression.type&&"TaggedTemplateExpression"!==e.expression.type)&&"TryStatement"!==e.type&&"BlockStatement"!==e.type&&"DoWhileStatement"!==e.type&&"WhileStatement"!==e.type&&"ForStatement"!==e.type&&"ForInStatement"!==e.type&&"ForOfStatement"!==e.type)&&(yield),e.type){case"ArrayExpression":{const n=new q;for(const t of e.elements)if(t)if("SpreadElement"===t.type){const e=O(yield*ne(t.argument));n.push(...e)}else n.push(O(yield*ne(t)));else n.length+=1;return x(n)}case"ArrowFunctionExpression":return Te(e),x(Ee(e));case"BinaryExpression":{const t=O(yield*ne(e.left)),r=yield*ne(e.right),i=O(r);if(Z&&"|>"===e.operator){if("function"!=typeof i){const t=n.substring(e.right.start,e.right.end);throw new TypeError(`${t} is not a function`)}let o;return r instanceof E&&I(r)&&(o=r.Base),x(i.call(o,t))}return x($(t,e.operator,i))}case"CallExpression":{const n=(yield*ne(e.callee,t)).Value,r=O(n);return null==r&&(e.optional||null!=t&&t.skipped)?(t.skipped=!0,x(void 0)):(H(r),v&&(yield),yield*fe(r,n,e.arguments,e.callee))}case"ChainExpression":return yield*ne(e.expression,{});case"ConditionalExpression":return x(O(yield*ne(O(yield*ne(e.test))?e.consequent:e.alternate)));case"Identifier":return x(re(e.name));case"Literal":if(e.regex){if(null===e.value)throw new SyntaxError(`Invalid regular expression: ${e.raw}`);if(e.regex.flags.includes("u"))throw new SyntaxError(`Unsupported unicode flag in regular expression: ${e.raw}`);return x(new RegExp(e.regex.pattern,e.regex.flags))}return x(e.value);case"LogicalExpression":{const n=O(yield*ne(e.left));switch(e.operator){case"&&":return x(n&&O(yield*ne(e.right)));case"||":return x(n||O(yield*ne(e.right)));case"??":return x(n??O(yield*ne(e.right)));default:throw new SyntaxError(`Unsupported logical operator '${e.operator}'`)}}case"MemberExpression":{const n=O((yield*ne(e.object,t)).Value);if(null==n&&(e.optional||null!=t&&t.skipped))return t.skipped=!0,x(void 0);H(n);const r=e.computed?yield*function*(e,n,t){const r=F(O(yield*ne(n)));return new E(e,r,!0)}(n,e.property):function(e,n,t){ee=n;const r=n.name;return new E(e,r,!0)}(n,e.property);return H(r),x(r)}case"NewExpression":return yield*function*(e,t){const r=O(yield*ne(e)),i=yield*ye(t);if("function"!=typeof r||!1===r[l]){const t=n.substring(e.start,e.end);throw new TypeError(`${t} is not a constructor`)}if(!g&&!function(e){return _.has(e)||e===Date}(r)&&r!==q){const t=n.substring(e.start,e.end);throw new TypeError(`${t} is not an allowed constructor`)}return x(new r(...i))}(e.callee,e.arguments);case"ObjectExpression":{const n={};for(const t of e.properties)if("SpreadElement"===t.type)C(n,O(yield*ne(t.argument)),new Set);else{if("init"!==t.kind)throw new SyntaxError("Unsupported object getter/setter");const e=t.computed||"Identifier"!==t.key.type?yield*Ae(t.key):t.key.name;if("__proto__"===e)throw new TypeError("Setting '__proto__' property is not allowed");const r=O(yield*ne(t.value));t.method&&"function"==typeof r&&we(r,e),n[e]=r}return x(n)}case"SequenceExpression":{let n;for(const t of e.expressions)n=x(O(yield*ne(t)));return n}case"TemplateLiteral":{const n=[e.quasis[0].value.cooked];let t=0;for(const r of e.expressions){const i=O(yield*ne(r));n.push(String(i)),n.push(e.quasis[t+=1].value.cooked)}return x(n.join(""))}case"TaggedTemplateExpression":{const n=(yield*ne(e.tag)).Value,t=O(n);return H(t),v&&(yield),yield*fe(t,n,e.quasi,e.tag)}case"UnaryExpression":{const n=(yield*ne(e.argument)).Value;if(!Z&&"delete"===e.operator){if(!(n instanceof E))return x(!0);if(I(n))return x(delete n.Base[n.ReferenceName])}return"typeof"===e.operator?n instanceof E&&"unresolvable"===n.Base?x("undefined"):x(typeof O(n)):x(function(e,n){switch(n){case"!":return!e;case"+":return+e;case"-":return-e;case"void":return}throw new SyntaxError(`Unsupported unary operator \`${n}\``)}(O(n),e.operator))}}if(!Z)switch(e.type){case"AssignmentExpression":{if("="===e.operator){if("ArrayPattern"!==e.left.type&&"ObjectPattern"!==e.left.type){const n=(yield*ne(e.left)).Value;let t;return t=ve(e.right)&&"Identifier"===e.left.type?ge(e.right,e.left.name):O(yield*ne(e.right)),D(n,t),x(t)}const n=O(yield*ne(e.right));return yield*ce(e.left,n),x(n)}const n=(yield*ne(e.left)).Value,t=O(n),r=O(yield*ne(e.right)),i=function(e,n,t){switch(n){case"+=":case"-=":case"*=":case"/=":case"%=":case"**=":return $(e,n.substr(0,n.length-1),t)}throw new SyntaxError(`Unsupported assignment operator \`${n}\``)}(t,e.operator,r);return D(n,i),x(i)}case"BlockStatement":{if(!e.body.length)return x(S);const n=te().LexicalEnvironment,t=new h(n);de(e.body,t),te().LexicalEnvironment=t;const r=yield*me(e.body);return te().LexicalEnvironment=n,r}case"BreakStatement":return new w("break",S);case"ContinueStatement":return new w("continue",S);case"EmptyStatement":case"FunctionDeclaration":return x(S);case"DoWhileStatement":return ie(yield*function*(e){let n;for(;;){const t=yield*ne(e.body);if(!V(t))return P(t,n);if(t.Value!==S&&(n=t.Value),!O(yield*ne(e.test,void 0,!0)))return x(n)}}(e));case"ExpressionStatement":case"TSAsExpression":return yield*ne(e.expression);case"ForInStatement":case"ForOfStatement":return ie(yield*function*(e){const n=e.left,t="VariableDeclaration"===n.type?"var"===n.kind?"varBinding":"lexicalBinding":"assignment",r="lexicalBinding"===t?A(n):[],i="ForInStatement"===e.type?"enumerate":"iterate",o=yield*function*(e,n,t){const r=te(),i=r.LexicalEnvironment;if(e.length>0){const n=new h(i);for(const t of e)n.CreateMutableBinding(t,!1);r.LexicalEnvironment=n}const o=yield*ne(n,void 0,!0);r.LexicalEnvironment=i;const a=O(o);return"enumerate"===t?null==a?new w("break",S):x(function*(e){for(const n in e)yield n}(a)):x(M(a))}(r,e.right,i);return"normal"!==o.Type?o:yield*function*(e,n,t,r,i){const o="assignment"===i?e:e.declarations[0].id,a=te().LexicalEnvironment;let s;const c="ObjectPattern"===o.type||"ArrayPattern"===o.type;for(;;){ee=o;const{done:l,value:u}=t.next();if(l)return v&&(yield),x(s);let d,f;if("lexicalBinding"===i){if(f=new h(a),k(e,f),te().LexicalEnvironment=f,v&&(yield),!c){const[e]=A(o);d=re(e)}}else v&&(yield),c||(d=(yield*ne(o)).Value);c?"assignment"===i?yield*ce(o,u):"varBinding"===i?yield*Se(o,u,void 0):yield*Se(o,u,f):"lexicalBinding"===i?T(d,u):D(d,u);const y=yield*ne(n);if(te().LexicalEnvironment=a,!V(y)){const e=P(y,s);if("enumerate"!==r&&void 0!==t.return){const e=t.return();if(!e||!["object","function"].includes(typeof e))throw new TypeError("Iterator result is not an object")}return e}y.Value!==S&&(s=y.Value)}}(n,e.body,o.Value,i,t)}(e));case"ForStatement":return ie(yield*function*(e){var n;if("VariableDeclaration"===(null===(n=e.init)||void 0===n?void 0:n.type)){if("var"===e.init.kind)return yield*ne(e.init),yield*ae(e.test,e.update,e.body,[]);const n=te().LexicalEnvironment,t=new h(n),r="const"===e.init.kind,i=A(e.init);for(const e of i)r?t.CreateImmutableBinding(e,!0):t.CreateMutableBinding(e,!1);te().LexicalEnvironment=t,yield*ne(e.init);const o=r?[]:Array.from(i),a=yield*ae(e.test,e.update,e.body,o);return te().LexicalEnvironment=n,a}return e.init&&O(yield*ne(e.init)),yield*ae(e.test,e.update,e.body,[])}(e));case"FunctionExpression":return Te(e),x(be(e));case"IfStatement":var a;return O(yield*ne(e.test))?(null===(a=G.beforeBranch)||void 0===a||a.call(G,e,"if"),P(yield*ne(e.consequent),void 0)):(null===(o=G.beforeBranch)||void 0===o||o.call(G,e,"else"),e.alternate?P(yield*ne(e.alternate),void 0):x(void 0));case"ReturnStatement":{let n;return e.argument&&(n=O(yield*ne(e.argument))),new w("return",n)}case"ThisExpression":if(!g)break;return x(function(){let e=te().LexicalEnvironment;for(;e;){if(e.HasThisBinding())return e;e=e.OuterEnv}throw new Error("Accessing global this is forbidden")}().GetThisBinding());case"ThrowStatement":throw O(yield*ne(e.argument));case"UpdateExpression":{const n=(yield*ne(e.argument)).Value,t=Number(O(n)),r="++"===e.operator?t+1:t-1;return D(n,r),x(e.prefix?r:t)}case"SwitchCase":return yield*me(e.consequent);case"SwitchStatement":{const n=O(yield*ne(e.discriminant)),t=te().LexicalEnvironment,r=new h(t);de(e.cases,r),te().LexicalEnvironment=r;const i=yield*function*(e,n){let t;const r=e.findIndex((e=>!e.test)),i=r>=0,o=i?e.slice(0,r):e;let a=!1;for(const e of o)if(a||(a=yield*oe(e,n)),a){const n=yield*ne(e);if(n.Value!==S&&(t=n.Value),"normal"!==n.Type)return P(n,t)}if(!i)return x(t);let s=!1;const c=e.slice(r+1);if(!a)for(const e of c)if(s||(s=yield*oe(e,n)),s){const n=yield*ne(e);if(n.Value!==S&&(t=n.Value),"normal"!==n.Type)return P(n,t)}if(s)return x(t);const l=yield*ne(e[r]);if(l.Value!==S&&(t=l.Value),"normal"!==l.Type)return P(l,t);for(const e of c){const n=yield*ne(e);if(n.Value!==S&&(t=n.Value),"normal"!==n.Type)return P(n,t)}return x(t)}(e.cases,n);return te().LexicalEnvironment=t,ie(i)}case"TryStatement":{let n;try{n=yield*ne(e.block)}catch(t){if(!e.handler)throw t;var s;ee=e.handler,null===(s=G.beforeEvaluate)||void 0===s||s.call(G,e.handler),n=yield*function*(e,n){if(!e.param)return yield*ne(e.body);const t=te().LexicalEnvironment,r=new h(t);for(const n of A(e.param))r.CreateMutableBinding(n,!1);te().LexicalEnvironment=r,yield*Se(e.param,n,r);const i=yield*ne(e.body);return te().LexicalEnvironment=t,i}(e.handler,t)}finally{if(e.finalizer){const t=yield*ne(e.finalizer);"normal"!==t.Type&&(n=t)}}return n}case"VariableDeclaration":{let n;for(const t of e.declarations)if(ee=t,t.init)if("Identifier"===t.id.type){ee=t.init,v&&"CallExpression"!==ee.type&&"TaggedTemplateExpression"!==ee.type&&(yield);const r=t.id.name,i=re(r);let o;o=ve(t.init)?ge(t.init,r):O(yield*ne(t.init)),n="var"===e.kind?D(i,o):T(i,o)}else{ee=t.init,v&&"CallExpression"!==ee.type&&"TaggedTemplateExpression"!==ee.type&&(yield);const r=O(yield*ne(t.init));n=yield*Se(t.id,r,"var"===e.kind?void 0:te().LexicalEnvironment)}else n="var"===e.kind?x(S):T(re(t.id.name),void 0);return n}case"WhileStatement":return ie(yield*function*(e){let n;for(;;){if(!O(yield*ne(e.test,void 0,!0)))return x(n);const t=yield*ne(e.body);if(!V(t))return P(t,n);t.Value!==S&&(n=t.Value)}}(e))}throw new SyntaxError(`Unsupported node type \`${e.type}\``)}function te(){return Q[Q.length-1]}function re(e,n){return n||(n=te().LexicalEnvironment),N(n,e,!0)}function ie(e){return"break"===e.Type?e.Value===S?x(void 0):x(e.Value):e}function*oe(e,n){return n===O(yield*ne(e.test))}function*ae(e,n,t,r){let i;for(se(r);;){if(e&&!O(yield*ne(e,void 0,!0)))return x(i);const o=yield*ne(t);if(!V(o))return P(o,i);o.Value&&(i=o.Value),se(r),n&&O(yield*ne(n,void 0,!0))}}function se(e){if(0===e.length)return;const n=te().LexicalEnvironment,t=n.OuterEnv,r=new h(t);for(const t of e){r.CreateMutableBinding(t,!1);const e=n.GetBindingValue(t,!1);r.InitializeBinding(t,e)}te().LexicalEnvironment=r}function*ce(e,n){if("ObjectPattern"===e.type)return R(n),e.properties.length>0&&(yield*function*(e,n){const t=new Set;for(const r of e)if("Property"===r.type){const e=r.computed||"Identifier"!==r.key.type?yield*Ae(r.key):r.key.name,i="AssignmentPattern"===r.value.type?r.value.left:r.value;if("Identifier"===i.type){const o=re(i.name);let a=j(n,e);"AssignmentPattern"===r.value.type&&void 0===a&&(a=ve(r.value.right)?ge(r.value.right,i.name):O(yield*ne(r.value.right))),D(o,a),t.add(e)}else yield*le(r.value,n,e),t.add(e)}else yield*ue(r,n,t)}(e.properties,n)),x(S);const t=M(n);return yield*function*(e,n){let t=x(S);for(const r of e){if(!r){n.next(),t=x(S);continue}const e="RestElement"===r.type?r.argument:"AssignmentPattern"===r.type?r.left:r,i="ArrayPattern"===e.type||"ObjectPattern"===e.type;let o,a;if(i||(o=(yield*ne(e)).Value),"RestElement"!==r.type){const{done:t,value:i}=n.next(),o=t?void 0:i;a="AssignmentPattern"===r.type&&void 0===o?ve(r.right)&&"Identifier"===e.type?ge(r.right,e.name):O(yield*ne(r.right)):o}else{a=new q;let e=0;for(;;){const{done:t,value:r}=n.next();if(t)break;a[e]=r,e++}}t=i?yield*ce(e,a):D(o,a)}return t}(e.elements,t)}function*le(e,n,t){const r="AssignmentPattern"===e.type?e.left:e,i="ArrayPattern"===r.type||"ObjectPattern"===r.type;let o;i||(o=(yield*ne(r)).Value);const a=j(n,t);let s;return s="AssignmentPattern"===e.type&&void 0===a?O(yield*ne(e.right)):a,i?yield*ce(r,s):D(o,s)}function*ue(e,n,t){return D((yield*ne(e.argument)).Value,C({},n,t))}function de(e,n){const t=B(e,{var:!1,topLevel:!1});for(const e of t){const t="VariableDeclaration"===e.type&&"const"===e.kind;for(const r of A(e))t?n.CreateImmutableBinding(r,!0):n.CreateMutableBinding(r,!1);if("FunctionDeclaration"===e.type){const[t]=A(e),r=he(e,n);n.InitializeBinding(t,r)}}}function*fe(e,t,r,i){let o;t instanceof E&&I(t)&&(o=t.Base);const a=yield*ye(r);if("function"!=typeof e){const e=n.substring(i.start,i.end);throw new TypeError(`${e} is not a function`)}if(v||g){const n=e[d];if(n){const e=yield*n.apply(o,a);return H(e),x(e)}}const s=e.apply(o,a);return H(s),x(s)}function*ye(e){const n=[];if(Array.isArray(e))for(const t of e)if("SpreadElement"===t.type){const e=O(yield*ne(t.argument));n.push(...e)}else n.push(O(yield*ne(t)));else{n.push(function(e){const n=Y.get(e);if(n)return n;const t=e.quasis.map((e=>e.value.raw)),r=e.quasis.map((e=>e.value.cooked));return Object.freeze(t),Object.defineProperty(r,"raw",{value:t,writable:!1,enumerable:!1,configurable:!1}),Object.freeze(r),Y.set(e,r),r}(e));for(const t of e.expressions)n.push(O(yield*ne(t)))}return n}function*pe(e,n,t){var c;null===(c=G.beforeCall)||void 0===c||c.call(G,e[o]),function(e,n,t){if(e[u]===i.LEXICAL)return;const r=n.LexicalEnvironment;null==r||r.BindThisValue(t)}(e,function(e){const n=new m;n.Function=e;const t=new b(e);return n.VariableEnvironment=t,n.LexicalEnvironment=t,Q.push(n),U.push(n),n}(e),n);const l=yield*function*(e,n){return yield*function*(e,n,t){return yield*function*(e,n){const t=te(),o=e[s],c=e[a],l=A(c),d=L(c),f=B(o,{var:!0,topLevel:!0}),y=A(f),p=[],m=[];for(let e=f.length-1;e>=0;e--){const n=f[e];if("FunctionDeclaration"===n.type){Te(n);const[e]=A(n);p.includes(e)||(p.unshift(e),m.unshift(n))}else if(null!=r&&r.noVar)throw new SyntaxError("Var declaration is not recommended, use `let` or `const` instead")}const v=!!g&&e[u]!==i.LEXICAL,b=t.LexicalEnvironment;for(const e of l)b.CreateMutableBinding(e,!1);let E=l;if(v){const e=function(e){const n=[...e],t={};Object.defineProperty(t,"length",{value:n.length,writable:!0,configurable:!0});for(let e=0;e<n.length;e++)t[String(e)]=n[e];Object.defineProperty(t,Symbol.iterator,{value:Array.prototype.values,writable:!0,configurable:!0});const r=()=>{throw new TypeError("'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them")};return Object.defineProperty(t,"callee",{get:r,set:r}),t}(n);b.CreateImmutableBinding("arguments",!1),b.InitializeBinding("arguments",e),E=l.concat("arguments")}const w=M(n);let x;if(yield*Be(c,w,b),d){x=new h(b),t.VariableEnvironment=x;const e=[];for(const n of y)if(!e.includes(n)){let t;e.push(n),x.CreateMutableBinding(n,!1),E.includes(n)&&!p.includes(n)&&(t=b.GetBindingValue(n,!1)),x.InitializeBinding(n,t)}}else{const e=[...E];for(const n of y)e.includes(n)||(e.push(n),b.CreateMutableBinding(n,!1),b.InitializeBinding(n,void 0));x=b}const S=x;t.LexicalEnvironment=S;const I=B(o,{var:!1,topLevel:!0});for(const e of I)for(const n of A(e))"const"===e.kind?S.CreateImmutableBinding(n,!0):S.CreateMutableBinding(n,!1);for(const e of m){const[n]=A(e),t=he(e,S);x.SetMutableBinding(n,t,!1)}}(n,t),Array.isArray(e)?yield*me(e):new w("return",O(yield*ne(e)))}(e[s],e,n)}(e,t);if(v&&(ee={...e[o],[p]:!0},yield{type:"return",value:"return"===l.Type?l.Value:void 0}),Q.pop(),U.pop(),"return"===l.Type)return l.Value}function*me(e){let n=x(S);for(const t of e){const e=yield*ne(t);if("normal"!==e.Type)return e;n=P(n,e.Value)}return n}function ve(e){return"FunctionExpression"===e.type&&!e.id||"ArrowFunctionExpression"===e.type}function ge(e,n){var t;switch(null===(t=G.beforeEvaluate)||void 0===t||t.call(G,e),e.type){case"FunctionExpression":return be(e,n);case"ArrowFunctionExpression":return Ee(e,n);default:throw new Error(`Unexpected node type for NamedEvaluation: ${e.type}`)}}function he(e,n){const t=xe(e,n,!0,!1);return e.id&&we(t,e.id.name),t}function be(e,n){const t=te().LexicalEnvironment;if(e.id){const n=e.id.name,r=new h(t);r.CreateImmutableBinding(n,!1);const i=xe(e,r,!0,!1);return we(i,n),r.InitializeBinding(n,i),i}{const r=xe(e,t,!0,!1);return we(r,n??""),r}}function Ee(e,n){const t=xe(e,te().LexicalEnvironment,!1,!0);return we(t,n??""),t}function we(e,n){Object.defineProperty(e,"name",{value:n,configurable:!0})}function xe(e,n,t,r){const f=function(){return X(pe(f,this,arguments))};Object.defineProperties(f,{[o]:{value:e},[a]:{value:e.params},[s]:{value:"BlockStatement"===e.body.type?e.body.body:e.body},[c]:{value:n},[l]:{value:t},[u]:{value:r?i.LEXICAL:i.STRICT}});const y=function(e){let n=0;for(const t of e)switch(t.type){case"AssignmentPattern":case"RestElement":return n;default:n++}return n}(e.params);return Object.defineProperty(f,"length",{configurable:!0,value:y}),(v||g)&&Object.defineProperty(f,d,{value:function(){return pe(f,this,arguments)}}),f}function*Se(e,n,t){switch(e.type){case"Identifier":return function(e,n,t){return t.InitializeBinding(e,n),x(S)}(e.name,n,t);case"ObjectPattern":return R(n),yield*function*(e,n,t){const r=new Set;for(const i of e){if("RestElement"===i.type)return Le(i,n,t,r);if(i.computed||"Identifier"!==i.key.type){const e=yield*Ae(i.key);yield*Ie(i.value,n,t,e),r.add(e)}else yield*Ie(i.value,n,t,i.key.name),r.add(i.key.name)}return x(S)}(e.properties,n,t);case"ArrayPattern":{const r=M(n);return yield*Be(e.elements,r,t)}}}function*Ae(e){return F(O(yield*ne(e)))}function Le(e,n,t,r){const i=re(e.argument.name,t),o=C({},n,r);return t?T(i,o):D(i,o)}function*Be(e,n,t){if(0===e.length)return x(S);let r;for(const i of e)if(i)if("RestElement"===i.type)if("Identifier"===i.argument.type){const e=re(i.argument.name,t),o=new q;let a=0;for(;;){const{done:i,value:s}=n.next();if(i){r=t?T(e,o):D(e,o);break}o[a]=s,a++}}else{const e=new q;let o=0;for(;;){const{done:a,value:s}=n.next();if(a){r=yield*Se(i.argument,e,t);break}e[o]=s,o++}}else{const e="AssignmentPattern"===i.type?i.left:i;switch(e.type){case"ObjectPattern":case"ArrayPattern":{let o;const{done:a,value:s}=n.next();a||(o=s),"AssignmentPattern"===i.type&&void 0===o&&(o=O(yield*ne(i.right))),r=yield*Se(e,o,t);break}case"Identifier":{const o=e.name,a=re(o,t);let s;const{done:c,value:l}=n.next();c||(s=l),"AssignmentPattern"===i.type&&void 0===s&&(s=ve(i.right)?ge(i.right,o):O(yield*ne(i.right))),r=t?T(a,s):D(a,s);break}}}else n.next(),r=x(S);return r}function*Ie(e,n,t,r){if("Identifier"===e.type||"AssignmentPattern"===e.type&&"Identifier"===e.left.type){const i="Identifier"===e.type?e.name:e.left.name,o=re(i,t);let a=j(n,r);return"AssignmentPattern"===e.type&&void 0===a&&(a=ve(e.right)?ge(e.right,i):O(yield*ne(e.right))),t?T(o,a):D(o,a)}let i=j(n,r);return"AssignmentPattern"===e.type&&void 0===i&&(i=O(yield*ne(e.right))),yield*Se("AssignmentPattern"===e.type?e.left:e,i,t)}function Te(e){if(e.async||e.generator)throw new SyntaxError((e.async?"Async":"Generator")+" function is not allowed");if(Z&&!e.expression)throw new SyntaxError("Only an `Expression` is allowed in `ArrowFunctionExpression`'s body")}if(Z)return O(X(ne(e)));null===(t=G.beforeEvaluate)||void 0===t||t.call(G,e),Te(e);const[Ce]=A(e);K.CreateImmutableBinding(Ce,!0);const ke=he(e,K);return K.InitializeBinding(Ce,ke),v&&Object.defineProperties(ke,{[f]:{value:function(){return te().LexicalEnvironment}},[y]:{value:function(){return ee}}}),ke}function X(e){for(;;){const{done:n,value:t}=e.next();if(n)return t}}class Z{constructor(){(0,r.A)(this,"VariableEnvironment",void 0),(0,r.A)(this,"LexicalEnvironment",void 0)}}class H{constructor(e){(0,r.A)(this,"OuterEnv",void 0),(0,r.A)(this,"bindingSet",new Set),this.OuterEnv=e}HasBinding(e){return this.bindingSet.has(e)}CreateBinding(e){this.bindingSet.add(e)}}function K(e){let{expressionOnly:n,visitors:t,withParent:r,externalSourceForDebug:i,hooks:o={}}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const a=new Set,s=[],c=new H(null),l=new Z;function u(){return s[s.length-1]}function d(e,n,t){for(const r of n)f(e[r],null==t?void 0:t.concat({node:e,key:r}))}function f(e,r){if(Array.isArray(e))e.forEach(((e,n)=>{f(e,r?r.slice(0,-1).concat({...r[r.length-1],index:n}):r)}));else if(e){var s,c;switch(null===(s=o.beforeVisit)||void 0===s||s.call(o,e,r),function(e){var n,r;t&&(n=t,r=e.type,Object.prototype.hasOwnProperty.call(n,r))&&t[e.type](e)}(e),e.type){case"Identifier":var l;return b=e.name,void(p(u().LexicalEnvironment,b)||(null===(l=o.beforeVisitGlobal)||void 0===l||l.call(o,e,r),a.add(e.name)));case"ArrayExpression":case"ArrayPattern":return void d(e,["elements"],r);case"ArrowFunctionExpression":return void v(g(e,u().LexicalEnvironment,!0),r);case"AssignmentPattern":case"BinaryExpression":case"LogicalExpression":return void d(e,["left","right"],r);case"CallExpression":case"NewExpression":return void d(e,["callee","arguments"],r);case"ChainExpression":return void d(e,["expression"],r);case"ConditionalExpression":return void d(e,["test","consequent","alternate"],r);case"MemberExpression":return d(e,["object"],r),void(e.computed&&d(e,["property"],r));case"ObjectExpression":case"ObjectPattern":return void d(e,["properties"],r);case"Property":return e.computed&&d(e,["key"],r),void d(e,["value"],r);case"RestElement":case"SpreadElement":case"UnaryExpression":return void d(e,["argument"],r);case"SequenceExpression":case"TemplateLiteral":return void d(e,["expressions"],r);case"TaggedTemplateExpression":return void d(e,["tag","quasi"],r);case"Literal":return}if(!n)switch(e.type){case"AssignmentExpression":return void d(e,["right","left"],r);case"BlockStatement":{if(!e.body.length)return;const n=u(),t=n.LexicalEnvironment,i=new H(t);return m(e.body,i),n.LexicalEnvironment=i,d(e,["body"],r),void(n.LexicalEnvironment=t)}case"BreakStatement":case"ContinueStatement":case"EmptyStatement":return;case"CatchClause":{const n=u(),t=n.LexicalEnvironment,i=new H(t);return y(e.param,i),n.LexicalEnvironment=i,d(e,["param","body"],r),void(n.LexicalEnvironment=t)}case"DoWhileStatement":return void d(e,["body","test"],r);case"ExpressionStatement":case"TSAsExpression":return void d(e,["expression"],r);case"ForInStatement":case"ForOfStatement":{const n="VariableDeclaration"===e.left.type&&"var"!==e.left.kind,t=u(),i=t.LexicalEnvironment;if(n){const n=new H(i);y(e.left,n),t.LexicalEnvironment=n}if(d(e,["right"],r),t.LexicalEnvironment=i,n){const n=new H(i);y(e.left,n),t.LexicalEnvironment=n}return d(e,["left","body"],r),void(t.LexicalEnvironment=i)}case"ForStatement":{var h;const n="VariableDeclaration"===(null===(h=e.init)||void 0===h?void 0:h.type)&&"var"!==e.init.kind,t=u(),i=t.LexicalEnvironment;if(n){const n=new H(i);y(e.init,n),t.LexicalEnvironment=n}return d(e,["init","test","body","update"],r),void(t.LexicalEnvironment=i)}case"FunctionDeclaration":{const[n]=A(e),t=u().LexicalEnvironment,i=g(e,t);return t.CreateBinding(n),void v(i,r)}case"FunctionExpression":{const n=function(e){const n=u().LexicalEnvironment;if(!e.id)return g(e,n);const t=e.id.name,r=new H(n);return r.CreateBinding(t),g(e,r)}(e);return void v(n,r)}case"IfStatement":return void d(e,["test","consequent","alternate"],r);case"ReturnStatement":case"ThrowStatement":case"UpdateExpression":return void d(e,["argument"],r);case"SwitchCase":return void d(e,["test","consequent"],r);case"SwitchStatement":{d(e,["discriminant"],r);const n=u(),t=n.LexicalEnvironment,i=new H(t);return m(e.cases,i),n.LexicalEnvironment=i,d(e,["cases"],r),void(n.LexicalEnvironment=t)}case"ThisExpression":if(!i)break;return;case"TryStatement":return void d(e,["block","handler","finalizer"],r);case"VariableDeclaration":return void d(e,["declarations"],r);case"VariableDeclarator":return void d(e,["id","init"],r);case"WhileStatement":return void d(e,["test","body"],r)}(null===(c=o.beforeVisitUnknown)||void 0===c?void 0:c.call(o,e,r))||console.warn(`Unsupported node type \`${e.type}\``)}var b}function y(e,n){for(const t of A(e))n.CreateBinding(t)}function p(e,n){return!!e&&(e.HasBinding(n)||p(e.OuterEnv,n))}function m(e,n){y(B(e,{var:!1,topLevel:!1}),n)}function v(e,n){!function(e){const n=new Z,t=new H(e.Environment);n.VariableEnvironment=t,n.LexicalEnvironment=t,s.push(n)}(e),function(e,n){const t=u(),r=e.ECMAScriptCode,o=e.FormalParameters,a=L(o),s=A(B(r,{var:!0,topLevel:!0})),c=!!i&&"LEXICAL"!==e.ThisMode,l=t.LexicalEnvironment;let d;if(y(o,l),c&&l.CreateBinding("arguments"),f(o,null==n?void 0:n.concat({node:e.Function,key:"params"})),a){d=new H(l),t.VariableEnvironment=d;for(const e of s)d.CreateBinding(e)}else{for(const e of s)l.CreateBinding(e);d=l}const p=d;t.LexicalEnvironment=p,y(B(r,{var:!1,topLevel:!0}),p)}(e,n),f(e.ECMAScriptCode,null==n?void 0:n.concat({node:e.Function,key:"body"}).concat("BlockStatement"===e.Function.body.type?{node:e.Function.body,key:"body"}:[])),s.pop()}function g(e,n,t){return{Function:e,FormalParameters:e.params,ECMAScriptCode:"BlockStatement"===e.body.type?e.body.body:e.body,Environment:n,ThisMode:t?"LEXICAL":"STRICT"}}return l.VariableEnvironment=c,l.LexicalEnvironment=c,s.push(l),f(e,r?[]:void 0),a}var J=t(3340);let Q=new WeakMap;function Y(e){let{typescript:n,cacheKey:t,...r}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=t?Q.get(t):void 0;return i||(i=function(e){let{typescript:n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const t=(0,J.parse)(e,{plugins:["estree",n&&"typescript"].filter(Boolean),strictMode:!0,attachComment:!1}).program.body,r=n?[]:t;if(n)for(const e of t)if(e.type.startsWith("TS")){if(/Enum|Import|Export/.test(e.type))throw new SyntaxError(`Unsupported TypeScript syntax: ${e.type}`)}else r.push(e);if(0===r.length)throw new SyntaxError("Function declaration not found");if(r.length>1||"FunctionDeclaration"!==r[0].type)throw new SyntaxError(`Expect a single function declaration at top level, but received: ${r.map((e=>`"${e.type}"`)).join(", ")}`);return r[0]}(e,{typescript:n}),t&&Q.set(t,i)),{function:i,attemptToVisitGlobals:K(i,r)}}function ee(){Q=new WeakMap}const ne=new Map;function te(e){let{cache:n,...t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=[],i=e.replace(/^\s*<%[~=]?\s|\s%>\s*$/g,(e=>(r.push(e),"")));let o=n?ne.get(i):void 0;return o||(o=function(e){return(0,J.parseExpression)(e,{plugins:["estree",["pipelineOperator",{proposal:"minimal"}]],attachComment:!1})}(i),n&&ne.set(i,o)),{expression:o,attemptToVisitGlobals:K(o,{...t,expressionOnly:!0}),source:i,prefix:r[0],suffix:r[1]}}function re(e){return/^\s*<%[~=]?\s/.test(e)&&/\s%>\s*$/.test(e)}function ie(e){return/^\s*<%~\s/.test(e)}function oe(e){return/^\s*<%=\s/.test(e)&&/\s%>\s*$/.test(e)}function ae(){ne.clear()}}}]);
//# sourceMappingURL=1122.e79b2fbf.js.map