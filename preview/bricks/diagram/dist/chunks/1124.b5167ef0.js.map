{"version":3,"file":"chunks/1124.b5167ef0.js","mappings":"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","sources":["webpack:///./src/diagram/MarkerComponent.tsx","webpack:///./src/diagram/lines/curveLine.ts","webpack:///./src/diagram/lines/getDirectLinePoints.ts","webpack:///./src/diagram/lines/getPolyLinePoints.ts","webpack:///./src/diagram/processors/doTwoNodesOverlap.ts","webpack:///./src/diagram/processors/extractPartialRectTuple.ts"],"sourcesContent":["import React from \"react\";\nimport type { LineMarkerType } from \"./interfaces\";\n\nexport interface MarkerComponentProps extends BaseMarkerComponentProps {\n  type: LineMarkerType;\n}\n\nexport interface BaseMarkerComponentProps {\n  id: string;\n  strokeColor?: string;\n}\n\nexport function MarkerComponent({\n  id,\n  type,\n  strokeColor,\n}: MarkerComponentProps): JSX.Element {\n  let Component: (props: BaseMarkerComponentProps) => JSX.Element;\n\n  switch (type) {\n    case \"0..1\":\n      Component = EntityRelationZeroOrOneMarker;\n      break;\n    case \"0..N\":\n      Component = EntityRelationZeroOrManyMarker;\n      break;\n    case \"circle\":\n      Component = CircleMarker;\n      break;\n    default:\n      Component = ArrowMarker;\n  }\n  return <Component id={id} strokeColor={strokeColor} />;\n}\n\nfunction CircleMarker({\n  id,\n  strokeColor,\n}: BaseMarkerComponentProps): JSX.Element {\n  const r = 3;\n  const d = r * 3;\n  return (\n    <marker\n      viewBox={`0 0 ${d} ${d}`}\n      refX={r}\n      refY={r}\n      id={id}\n      overflow=\"visible\"\n      markerWidth={d}\n      markerHeight={d}\n    >\n      <circle stroke=\"none\" fill={strokeColor} cx={r} cy={r} r={r} />\n    </marker>\n  );\n}\n\nfunction ArrowMarker({\n  id,\n  strokeColor,\n}: BaseMarkerComponentProps): JSX.Element {\n  return (\n    <marker\n      id={id}\n      viewBox=\"0 0 6 6\"\n      refX={5}\n      refY={3}\n      markerWidth={6}\n      markerHeight={6}\n      orient=\"auto-start-reverse\"\n      strokeLinejoin=\"round\"\n    >\n      <path\n        d=\"M 0.5 0.5 L 5.5 3 L 0.5 5.5 z\"\n        stroke={strokeColor}\n        strokeWidth={1}\n        fill={strokeColor}\n      />\n    </marker>\n  );\n}\n\nfunction EntityRelationZeroOrOneMarker({\n  id,\n  strokeColor,\n}: BaseMarkerComponentProps): JSX.Element {\n  return (\n    <marker\n      id={id}\n      viewBox=\"0 0 21 11\"\n      refX={0.5}\n      refY={5.5}\n      markerWidth={21}\n      markerHeight={11}\n      orient=\"auto-start-reverse\"\n    >\n      <path\n        d=\"M 5.5 5.5 m 5 0 a 5 5 0 1 0 -10 0 a 5 5 0 1 0 10 0 M 15.5 0.5 V 10.5 M 10.5 5.5 H 20.5\"\n        stroke={strokeColor}\n        strokeWidth={1}\n        fill=\"none\"\n      />\n    </marker>\n  );\n}\n\nfunction EntityRelationZeroOrManyMarker({\n  id,\n  strokeColor,\n}: BaseMarkerComponentProps): JSX.Element {\n  return (\n    <marker\n      id={id}\n      viewBox=\"0 0 21 11\"\n      refX={0.5}\n      refY={5.5}\n      markerWidth={21}\n      markerHeight={11}\n      orient=\"auto-start-reverse\"\n    >\n      <path\n        d=\"M 5.5 5.5 m 5 0 a 5 5 0 1 0 -10 0 a 5 5 0 1 0 10 0 M 20.5 0.5 L 10.5 5.5 L 20.5 10.5 M 10.5 5.5 H 20.5\"\n        stroke={strokeColor}\n        strokeWidth={1}\n        fill=\"none\"\n      />\n    </marker>\n  );\n}\n","import {\n  curveLinear,\n  line,\n  curveBasis,\n  curveBumpX,\n  curveBumpY,\n  type CurveFactory,\n  curveMonotoneX,\n  curveNatural,\n  curveMonotoneY,\n} from \"d3-shape\";\nimport type { CurveType, NodePosition } from \"../interfaces\";\n\n/**\n * Generate Line from points\n */\nexport function curveLine(\n  points: Array<NodePosition> | null | undefined,\n  curveType: CurveType | undefined,\n  startOffset: number,\n  endOffset: number\n): string {\n  if (!Array.isArray(points)) {\n    return \"\";\n  }\n  let curveFactory: CurveFactory;\n  switch (curveType) {\n    case \"curveLinear\":\n      curveFactory = curveLinear;\n      break;\n    case \"curveBumpX\":\n      curveFactory = curveBumpX;\n      break;\n    case \"curveBumpY\":\n      curveFactory = curveBumpY;\n      break;\n    case \"curveMonotoneX\":\n      curveFactory = curveMonotoneX;\n      break;\n    case \"curveMonotoneY\":\n      curveFactory = curveMonotoneY;\n      break;\n    case \"curveNatural\":\n      curveFactory = curveNatural;\n      break;\n    default:\n      curveFactory = curveBasis;\n  }\n  const startOffsets = getOffsets(points[1], points[0], startOffset);\n  const endOffsets = getOffsets(\n    points[points.length - 2],\n    points[points.length - 1],\n    endOffset\n  );\n  const lineFunction = line()\n    .x(\n      (d, index) =>\n        (d as unknown as { x: number }).x -\n        (index === 0\n          ? startOffsets.x\n          : index === points.length - 1\n            ? endOffsets.x\n            : 0)\n    )\n    .y(\n      (d, index) =>\n        (d as unknown as { y: number }).y -\n        (index === 0\n          ? startOffsets.y\n          : index === points.length - 1\n            ? endOffsets.y\n            : 0)\n    )\n    .curve(curveFactory);\n  return lineFunction(points as unknown as Array<[number, number]>)!;\n}\n\nfunction getOffsets(\n  start: NodePosition,\n  end: NodePosition,\n  offset: number\n): NodePosition {\n  if (!offset) {\n    return { x: 0, y: 0 };\n  }\n  const { x: x0, y: y0 } = start;\n  const { x: x1, y: y1 } = end;\n  const distance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n  const ratio = offset / distance;\n  return {\n    x: (x1 - x0) * ratio,\n    y: (y1 - y0) * ratio,\n  };\n}\n","import type { EdgeView } from \"../../draw-canvas/interfaces\";\nimport type { NodePosition, NodeRect, PositionTuple } from \"../interfaces\";\nimport { doTwoNodesOverlap } from \"../processors/doTwoNodesOverlap\";\n\ntype LineTuple = [start: PositionTuple, end: PositionTuple];\n\nexport function getDirectLinePoints(\n  source: NodeRect,\n  target: NodeRect,\n  parallelGap?: number,\n  edgeView?: EdgeView\n): NodePosition[] | null {\n  const hasExitPosition = !!edgeView?.exitPosition;\n  const hasEntryPosition = !!edgeView?.entryPosition;\n\n  // Ignore if two nodes are the same.\n  // Ignore if two nodes overlap and no entry nor exit position.\n  if (\n    source === target ||\n    (doTwoNodesOverlap(source, target, 0, 0) &&\n      !(hasExitPosition || hasEntryPosition))\n  ) {\n    return null;\n  }\n\n  let p0: PositionTuple;\n  let p1: PositionTuple;\n\n  let xDiff = 0;\n  let yDiff = 0;\n\n  if (parallelGap) {\n    const dx = target.x - source.x;\n    const dy = target.y - source.y;\n    const angle = Math.atan2(dy, dx);\n    xDiff = (parallelGap / 2) * Math.cos(angle + Math.PI / 2);\n    yDiff = (parallelGap / 2) * Math.sin(angle + Math.PI / 2);\n  }\n\n  const line: LineTuple = [\n    hasExitPosition\n      ? [\n          source.x + (edgeView!.exitPosition!.x - 0.5) * source.width,\n          source.y + (edgeView!.exitPosition!.y - 0.5) * source.height,\n        ]\n      : [source.x + xDiff, source.y + yDiff],\n    hasEntryPosition\n      ? [\n          target.x + (edgeView!.entryPosition!.x - 0.5) * target.width,\n          target.y + (edgeView!.entryPosition!.y - 0.5) * target.height,\n        ]\n      : [target.x + xDiff, target.y + yDiff],\n  ];\n\n  if (hasExitPosition) {\n    p0 = line[0];\n  } else {\n    const sourceIntersections = getIntersections(source, line);\n    // Todo: handle when more than one intersection\n    if (sourceIntersections.length > 0) {\n      p0 = sourceIntersections[0];\n    } else {\n      p0 = [source.x, source.y];\n    }\n  }\n\n  if (hasEntryPosition) {\n    p1 = line[1];\n  } else {\n    const targetIntersections = getIntersections(target, line);\n    // Todo: handle when more than one intersection\n    if (targetIntersections.length > 0) {\n      p1 = targetIntersections[0];\n    } else {\n      p1 = [target.x, target.y];\n    }\n  }\n\n  return [\n    { x: p0[0], y: p0[1] },\n    { x: p1[0], y: p1[1] },\n  ];\n}\n\nfunction getIntersections(rect: NodeRect, line: LineTuple) {\n  const vertices: PositionTuple[] = [\n    [rect.x - rect.width / 2, rect.y - rect.height / 2],\n    [rect.x + rect.width / 2, rect.y - rect.height / 2],\n    [rect.x + rect.width / 2, rect.y + rect.height / 2],\n    [rect.x - rect.width / 2, rect.y + rect.height / 2],\n  ];\n  const possibleLines: [start: PositionTuple, end: PositionTuple][] = [];\n  for (let i = 0; i < 4; i++) {\n    possibleLines.push([vertices[i], vertices[(i + 1) % 4]]);\n  }\n  const intersections: PositionTuple[] = [];\n  for (const item of possibleLines) {\n    const intersection = intersect(line[0], line[1], item[0], item[1]);\n    if (intersection) {\n      intersections.push(intersection);\n    }\n  }\n  return intersections;\n}\n\n// https://paulbourke.net/geometry/pointlineplane/javascript.txt\nfunction intersect(\n  [x1, y1]: PositionTuple,\n  [x2, y2]: PositionTuple,\n  [x3, y3]: PositionTuple,\n  [x4, y4]: PositionTuple\n): null | PositionTuple {\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return null;\n  }\n\n  const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return null;\n  }\n\n  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return null;\n  }\n\n  // Return a object with the x and y coordinates of the intersection\n  const x = x1 + ua * (x2 - x1);\n  const y = y1 + ua * (y2 - y1);\n\n  return [x, y];\n}\n","import type { Direction, NodePosition, NodeRect } from \"../interfaces\";\n\nconst MINIMAL_OFFSET = 20;\n\nexport function getPolyLinePoints(\n  source: NodeRect,\n  target: NodeRect,\n  sourceDirection: Direction,\n  targetDirection: Direction,\n  sourcePosition: number,\n  targetPosition: number\n): NodePosition[] {\n  const p0 = getCoordinates(source, sourceDirection, sourcePosition);\n  const p1 = getCoordinates(target, targetDirection, targetPosition);\n\n  let controls: NodePosition[] = [];\n  let reverseControls = false;\n\n  const sourceIsVertical =\n    sourceDirection === \"top\" || sourceDirection === \"bottom\";\n  const targetIsVertical =\n    targetDirection === \"top\" || targetDirection === \"bottom\";\n\n  if (sourceIsVertical !== targetIsVertical) {\n    // One is vertical and the other is horizontal\n    let horizontal: NodeRect;\n    let vertical: NodeRect;\n    let horizontalSign: number;\n    let verticalSign: number;\n    let horizontalPosition: NodePosition;\n    let verticalPosition: NodePosition;\n    if (sourceIsVertical) {\n      horizontal = target;\n      vertical = source;\n      horizontalSign = targetDirection === \"right\" ? 1 : -1;\n      verticalSign = sourceDirection === \"bottom\" ? 1 : -1;\n      horizontalPosition = p1;\n      verticalPosition = p0;\n    } else {\n      horizontal = source;\n      vertical = target;\n      horizontalSign = sourceDirection === \"right\" ? 1 : -1;\n      verticalSign = targetDirection === \"bottom\" ? 1 : -1;\n      horizontalPosition = p0;\n      verticalPosition = p1;\n      reverseControls = true;\n    }\n\n    const defaultControlX =\n      horizontalPosition.x + MINIMAL_OFFSET * horizontalSign;\n    const defaultControlY = verticalPosition.y + MINIMAL_OFFSET * verticalSign;\n\n    if ((horizontal.x - vertical.x) * horizontalSign >= 0) {\n      if ((vertical.y - horizontal.y) * verticalSign >= 0) {\n        //    ┌──────────────┐\n        // ┌──┴──┐   ┌─────┐ │\n        // │  S  │   │  T  ├─┘\n        // └─────┘   └─────┘\n        controls = [\n          { x: verticalPosition.x, y: defaultControlY },\n          { x: defaultControlX, y: defaultControlY },\n          { x: defaultControlX, y: horizontalPosition.y },\n        ];\n      } else {\n        const controlY0 =\n          vertical.y + (vertical.height / 2 + MINIMAL_OFFSET) * verticalSign;\n        const controlY1 =\n          horizontal.y -\n          (horizontal.height / 2 + MINIMAL_OFFSET) * verticalSign;\n        if ((controlY1 - controlY0) * verticalSign >= 0) {\n          //     ┌─────┐\n          //     │  T  ├─┐\n          //     └─────┘ │\n          //    ┌────────┘\n          // ┌──┴──┐\n          // │  S  │\n          // └─────┘\n          const middleY = (controlY0 + controlY1) / 2;\n          controls = [\n            { x: verticalPosition.x, y: middleY },\n            { x: defaultControlX, y: middleY },\n            { x: defaultControlX, y: horizontalPosition.y },\n          ];\n        } else {\n          //           ┌─────┐\n          //    ┌────┐ │  T  ├─┐\n          // ┌──┴──┐ │ └─────┘ │\n          // │  S  │ └─────────┘\n          // └─────┘\n          const middleX =\n            (vertical.x +\n              (vertical.width / 2) * horizontalSign +\n              horizontal.x -\n              (horizontal.width / 2) * horizontalSign) /\n            2;\n          controls = [\n            { x: verticalPosition.x, y: controlY0 },\n            { x: middleX, y: controlY0 },\n            { x: middleX, y: controlY1 },\n            { x: defaultControlX, y: controlY1 },\n            { x: defaultControlX, y: horizontalPosition.y },\n          ];\n        }\n      }\n    } else if ((horizontalPosition.y - defaultControlY) * verticalSign >= 0) {\n      if ((verticalPosition.x - defaultControlX) * horizontalSign >= 0) {\n        //       ┌─────┐\n        //    ┌──┤  T  │\n        //    │  └─────┘\n        // ┌──┴──┐\n        // │  S  │\n        // └─────┘\n        controls = [{ x: verticalPosition.x, y: horizontalPosition.y }];\n      } else {\n        // ┌─────┐\n        // │  T  ├─┐\n        // └─────┘ │\n        //       ┌─┘\n        //    ┌──┴──┐\n        //    │  S  │\n        //    └─────┘\n        const controlY0 =\n          vertical.y + (vertical.height / 2 + MINIMAL_OFFSET) * verticalSign;\n        const controlY1 =\n          horizontal.y -\n          (horizontal.height / 2 + MINIMAL_OFFSET) * verticalSign;\n        const middleY = (controlY0 + controlY1) / 2;\n        controls = [\n          { x: verticalPosition.x, y: middleY },\n          { x: defaultControlX, y: middleY },\n          { x: defaultControlX, y: horizontalPosition.y },\n        ];\n      }\n    } else {\n      const sourceExtendX =\n        vertical.x - (vertical.width / 2 + MINIMAL_OFFSET) * horizontalSign;\n      if ((sourceExtendX - defaultControlX) * horizontalSign >= 0) {\n        //         ┌────┐\n        //         │ ┌──┴──┐\n        //         │ │  S  │\n        // ┌─────┐ │ └─────┘\n        // │  T  ├─┘\n        // └─────┘\n        const middleX = (sourceExtendX + defaultControlX) / 2;\n        controls = [\n          { x: verticalPosition.x, y: defaultControlY },\n          { x: middleX, y: defaultControlY },\n          { x: middleX, y: horizontalPosition.y },\n        ];\n      } else {\n        //     ┌────┐\n        //     │ ┌──┴──┐\n        //     │ │  S  │\n        //     │ └─────┘\n        //     └───┐\n        // ┌─────┐ │\n        // │  T  ├─┘\n        // └─────┘\n        const middleY =\n          (vertical.y -\n            (vertical.height / 2) * verticalSign +\n            horizontal.y +\n            (horizontal.height / 2) * verticalSign) /\n          2;\n        controls = [\n          { x: verticalPosition.x, y: defaultControlY },\n          { x: sourceExtendX, y: defaultControlY },\n          { x: sourceExtendX, y: middleY },\n          { x: defaultControlX, y: middleY },\n          { x: defaultControlX, y: horizontalPosition.y },\n        ];\n      }\n    }\n  } else if (sourceDirection === targetDirection) {\n    // Same direction\n    const sign =\n      sourceDirection === \"bottom\" || sourceDirection === \"right\" ? 1 : -1;\n    let start: NodeRect;\n    let end: NodeRect;\n    let startPosition: NodePosition;\n    let endPosition: NodePosition;\n    const axis = sourceIsVertical ? \"y\" : \"x\";\n    const oppositeAxis = sourceIsVertical ? \"x\" : \"y\";\n    if (target[axis] < source[axis]) {\n      start = target;\n      end = source;\n      startPosition = p1;\n      endPosition = p0;\n      reverseControls = sign === 1;\n    } else {\n      start = source;\n      end = target;\n      startPosition = p0;\n      endPosition = p1;\n      reverseControls = sign !== 1;\n    }\n    const perpendicular =\n      target[oppositeAxis] < source[oppositeAxis] ? source : target;\n    let around: NodeRect;\n    let nonAround: NodeRect;\n    let aroundPosition: NodePosition;\n    let nonAroundPosition: NodePosition;\n    if (sign === 1) {\n      around = end;\n      nonAround = start;\n      aroundPosition = endPosition;\n      nonAroundPosition = startPosition;\n    } else {\n      around = start;\n      nonAround = end;\n      aroundPosition = startPosition;\n      nonAroundPosition = endPosition;\n    }\n    const aroundSign = around === perpendicular ? 1 : -1;\n    if (sourceIsVertical) {\n      const defaultControlX =\n        around.x - (around.width / 2 + MINIMAL_OFFSET) * aroundSign;\n      const defaultControlY = aroundPosition.y + MINIMAL_OFFSET * sign;\n      if ((defaultControlX - nonAroundPosition.x) * aroundSign >= 0) {\n        //    ┌─────────┐\n        //    │      ┌──┴──┐\n        //    │      │  T  │\n        // ┌──┴──┐   └─────┘\n        // │  S  │\n        // └─────┘\n        controls = [\n          { x: nonAroundPosition.x, y: defaultControlY },\n          { x: aroundPosition.x, y: defaultControlY },\n        ];\n      } else {\n        //  ┌────┐\n        //  │ ┌──┴──┐\n        //  │ │  T  │\n        //  │ └─────┘\n        //  └─┐\n        // ┌──┴──┐\n        // │  S  │\n        // └─────┘\n        const middleY =\n          (nonAround.y +\n            (nonAround.height / 2) * sign +\n            around.y -\n            (around.height / 2) * sign) /\n          2;\n        controls = [\n          { x: nonAroundPosition.x, y: middleY },\n          { x: defaultControlX, y: middleY },\n          { x: defaultControlX, y: defaultControlY },\n          { x: aroundPosition.x, y: defaultControlY },\n        ];\n      }\n    } else {\n      const defaultControlX = aroundPosition.x + MINIMAL_OFFSET * sign;\n      const defaultControlY =\n        around.y - (around.height / 2 + MINIMAL_OFFSET) * aroundSign;\n      if ((defaultControlY - nonAroundPosition.y) * aroundSign >= 0) {\n        //           ┌─────┐\n        // ┌─────────┤  T  │\n        // │ ┌─────┐ └─────┘\n        // └─┤  S  │\n        //   └─────┘\n        controls = [\n          { x: defaultControlX, y: nonAroundPosition.y },\n          { x: defaultControlX, y: aroundPosition.y },\n        ];\n      } else {\n        // ┌─────────┐\n        // │ ┌─────┐ │ ┌─────┐\n        // └─┤  S  │ └─┤  T  │\n        //   └─────┘   └─────┘\n        const middleX =\n          (nonAround.x +\n            (nonAround.width / 2) * sign +\n            around.x -\n            (around.width / 2) * sign) /\n          2;\n        controls = [\n          { x: middleX, y: nonAroundPosition.y },\n          { x: middleX, y: defaultControlY },\n          { x: defaultControlX, y: defaultControlY },\n          { x: defaultControlX, y: aroundPosition.y },\n        ];\n      }\n    }\n  } else {\n    // Opposite direction\n    const targetSign =\n      targetDirection === \"bottom\" || targetDirection === \"right\" ? 1 : -1;\n    let axis: \"x\" | \"y\";\n    let oppositeAxis: \"x\" | \"y\";\n    let size: \"width\" | \"height\";\n    let oppositeSize: \"width\" | \"height\";\n    if (sourceIsVertical) {\n      axis = \"y\";\n      oppositeAxis = \"x\";\n      size = \"height\";\n      oppositeSize = \"width\";\n    } else {\n      axis = \"x\";\n      oppositeAxis = \"y\";\n      size = \"width\";\n      oppositeSize = \"height\";\n    }\n    const targetEdge = target[axis] + (target[size] / 2) * targetSign;\n    const sourceEdge = source[axis] - (source[size] / 2) * targetSign;\n    const targetControl = targetEdge + MINIMAL_OFFSET * targetSign;\n    const sourceControl = sourceEdge - MINIMAL_OFFSET * targetSign;\n    const oppositeIsStraight = p0[oppositeAxis] === p1[oppositeAxis];\n    if ((sourceControl - targetControl) * targetSign >= 0) {\n      const middle = (sourceControl + targetControl) / 2;\n      if (oppositeIsStraight) {\n        // Straight line\n        // ┌─────┐\n        // │  T  │\n        // └──┬──┘\n        //    │\n        // ┌──┴──┐\n        // │  S  │\n        // └─────┘\n        controls = [];\n      } else {\n        //     ┌─────┐\n        //     │  T  │\n        //     └──┬──┘\n        //    ┌───┘\n        // ┌──┴──┐\n        // │  S  │\n        // └─────┘\n        controls = [\n          { [oppositeAxis]: p0[oppositeAxis], [axis]: middle },\n          { [oppositeAxis]: p1[oppositeAxis], [axis]: middle },\n        ] as unknown[] as NodePosition[];\n      }\n    } else if (\n      oppositeIsStraight &&\n      (sourceEdge - targetEdge) * targetSign >= 0\n    ) {\n      // Straight line (very close)\n      // ┌─────┐\n      // │  T  │\n      // └──┬──┘\n      // ┌──┴──┐\n      // │  S  │\n      // └─────┘\n      controls = [];\n    } else {\n      const targetOppositeSign =\n        target[oppositeAxis] < source[oppositeAxis] ? -1 : 1;\n      const sourceOppositeControl =\n        source[oppositeAxis] +\n        (source[oppositeSize] / 2 + MINIMAL_OFFSET) * targetOppositeSign;\n      const targetOppositeControl =\n        target[oppositeAxis] -\n        (target[oppositeSize] / 2 + MINIMAL_OFFSET) * targetOppositeSign;\n      if (\n        (targetOppositeControl - sourceOppositeControl) * targetOppositeSign >=\n          0 ||\n        Math.abs((sourceControl - targetControl) * targetSign) < MINIMAL_OFFSET\n      ) {\n        //           ┌─────┐\n        //    ┌────┐ │  T  │\n        // ┌──┴──┐ │ └──┬──┘\n        // │  S  │ └────┘\n        // └─────┘\n        const oppositeMiddle =\n          (sourceOppositeControl + targetOppositeControl) / 2;\n        controls = [\n          { [oppositeAxis]: p0[oppositeAxis], [axis]: sourceControl },\n          { [oppositeAxis]: oppositeMiddle, [axis]: sourceControl },\n          { [oppositeAxis]: oppositeMiddle, [axis]: targetControl },\n          { [oppositeAxis]: p1[oppositeAxis], [axis]: targetControl },\n        ] as unknown[] as NodePosition[];\n      } else {\n        //      ┌────┐\n        //   ┌──┴──┐ │\n        //   │  S  │ │\n        //   └─────┘ │\n        // ┌─────────┘\n        // │ ┌─────┐\n        // │ │  T  │\n        // │ └──┬──┘\n        // └────┘\n        const middle =\n          (source[axis] +\n            (source[size] / 2) * targetSign +\n            target[axis] -\n            (target[size] / 2) * targetSign) /\n          2;\n        controls = [\n          { [oppositeAxis]: p0[oppositeAxis], [axis]: sourceControl },\n          { [oppositeAxis]: sourceOppositeControl, [axis]: sourceControl },\n          { [oppositeAxis]: sourceOppositeControl, [axis]: middle },\n          { [oppositeAxis]: targetOppositeControl, [axis]: middle },\n          { [oppositeAxis]: targetOppositeControl, [axis]: targetControl },\n          { [oppositeAxis]: p1[oppositeAxis], [axis]: targetControl },\n        ] as unknown[] as NodePosition[];\n      }\n    }\n  }\n\n  if (reverseControls) {\n    controls.reverse();\n  }\n\n  return [p0, ...controls, p1] as NodePosition[];\n}\n\nfunction getCoordinates(\n  node: NodeRect,\n  direction: Direction,\n  position: number\n): NodePosition {\n  const { x, y, width, height } = node;\n  switch (direction) {\n    case \"top\":\n      return {\n        x: x - width / 2 + width * position,\n        y: y - height / 2,\n      };\n    case \"bottom\":\n      return {\n        x: x - width / 2 + width * position,\n        y: y + height / 2,\n      };\n    case \"left\":\n      return {\n        x: x - width / 2,\n        y: y - height / 2 + height * position,\n      };\n    case \"right\":\n      return {\n        x: x + width / 2,\n        y: y - height / 2 + height * position,\n      };\n  }\n}\n","import type { NodeRect } from \"../interfaces\";\n\nexport function doTwoNodesOverlap(\n  a: NodeRect,\n  b: NodeRect,\n  paddingA: number,\n  paddingB: number\n): boolean {\n  const A = paddingA ? getNodesWithPadding(a, paddingA) : a;\n  const B = paddingB ? getNodesWithPadding(b, paddingB) : b;\n  const left = Math.min(A.x - A.width / 2, B.x - B.width / 2);\n  const right = Math.max(A.x + A.width / 2, B.x + B.width / 2);\n  const top = Math.min(A.y - A.height / 2, B.y - B.height / 2);\n  const bottom = Math.max(A.y + A.height / 2, B.y + B.height / 2);\n  return right - left < A.width + B.width && bottom - top < A.height + B.height;\n}\n\nfunction getNodesWithPadding(node: NodeRect, padding: number) {\n  return {\n    x: node.x - node.width / 2 - padding,\n    y: node.y - node.height / 2 - padding,\n    width: node.width + padding * 2,\n    height: node.height + padding * 2,\n  };\n}\n","import type { FullRectTuple, PartialRectTuple } from \"../interfaces\";\n\nexport function extractPartialRectTuple(\n  value: PartialRectTuple\n): FullRectTuple {\n  if (Array.isArray(value)) {\n    const v0 = value[0];\n    const v1 = value.length > 1 ? value[1]! : v0;\n    const v2 = value.length > 2 ? value[2]! : v0;\n    const v3 = value.length > 3 ? value[3]! : v1;\n    return [v0, v1, v2, v3];\n  }\n  return new Array(4).fill(value) as FullRectTuple;\n}\n"],"names":["MarkerComponent","_ref","Component","id","type","strokeColor","EntityRelationZeroOrOneMarker","EntityRelationZeroOrManyMarker","CircleMarker","ArrowMarker","React","_ref2","viewBox","refX","refY","overflow","markerWidth","r","markerHeight","stroke","fill","cx","cy","_ref3","orient","strokeLinejoin","d","strokeWidth","_ref4","_ref5","curveLine","points","curveType","startOffset","endOffset","Array","isArray","curveFactory","curveLinear","curveBumpX","curveBumpY","curveMonotoneX","curveMonotoneY","curveNatural","curveBasis","startOffsets","getOffsets","endOffsets","length","line","x","index","y","curve","lineFunction","start","end","offset","x0","y0","x1","y1","ratio","Math","sqrt","pow","getDirectLinePoints","source","target","parallelGap","edgeView","hasExitPosition","exitPosition","hasEntryPosition","entryPosition","doTwoNodesOverlap","p0","p1","xDiff","yDiff","dx","dy","angle","atan2","cos","PI","sin","width","height","sourceIntersections","getIntersections","targetIntersections","rect","vertices","possibleLines","i","push","intersections","item","intersection","intersect","x2","y2","x3","y3","x4","y4","denominator","ua","ub","MINIMAL_OFFSET","getPolyLinePoints","sourceDirection","targetDirection","sourcePosition","targetPosition","getCoordinates","controls","reverseControls","sourceIsVertical","horizontal","vertical","horizontalSign","verticalSign","horizontalPosition","verticalPosition","defaultControlX","defaultControlY","controlY0","controlY1","middleY","middleX","sourceExtendX","sign","startPosition","endPosition","axis","oppositeAxis","around","nonAround","aroundPosition","nonAroundPosition","aroundSign","targetSign","size","oppositeSize","targetEdge","sourceEdge","targetControl","sourceControl","oppositeIsStraight","middle","targetOppositeSign","sourceOppositeControl","targetOppositeControl","abs","oppositeMiddle","reverse","node","direction","position","a","b","paddingA","paddingB","A","getNodesWithPadding","B","left","min","right","max","top","bottom","padding","extractPartialRectTuple","value","v0","v1"],"sourceRoot":""}