{"version":3,"file":"chunks/9961.b0abcd60.js","mappings":"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","sources":["webpack:///./src/draw-canvas/processors/findNodeOrAreaDecorator.ts","webpack:///./src/draw-canvas/EdgeComponent.tsx","webpack:///./src/draw-canvas/NodeComponent.tsx","webpack:///./src/draw-canvas/processors/handleMouseDown.ts","webpack:///./src/draw-canvas/processors/normalizeSnapOptions.ts","webpack:///./src/draw-canvas/decorators/DecoratorArea.tsx","webpack:///./src/draw-canvas/decorators/DecoratorText.tsx","webpack:///./src/draw-canvas/decorators/DecoratorContainer.tsx","webpack:///./src/draw-canvas/decorators/index.tsx","webpack:///./src/draw-canvas/processors/computeContainerRect.ts","webpack:///./src/draw-canvas/CellComponent.tsx","webpack:///./src/draw-canvas/ConnectLineComponent.tsx","webpack:///./src/shared/canvas/processors/getEditingLinePoints.ts","webpack:///./src/draw-canvas/EditingLineComponent.tsx","webpack:///./src/draw-canvas/HoverStateContext.ts","webpack:///./src/draw-canvas/LineConnectorComponent.tsx","webpack:///./src/draw-canvas/LineEditorComponent.tsx","webpack:///./src/draw-canvas/SmartConnectLineComponent.tsx","webpack:///./src/shared/canvas/processors/getConnectLinePoints.ts","webpack:///./src/draw-canvas/constants.ts","webpack:///./src/draw-canvas/processors/asserts.ts","webpack:///./src/draw-canvas/processors/cellToTarget.ts","webpack:///./src/draw-canvas/processors/getUnrelatedCells.ts","webpack:///./src/draw-canvas/processors/handleKeyboard.ts","webpack:///./src/draw-canvas/processors/handleLasso.ts","webpack:///./src/draw-canvas/processors/handleNodeContainedChange.ts","webpack:///./src/draw-canvas/processors/initializeCells.ts","webpack:///./src/draw-canvas/processors/sameTarget.ts","webpack:///./src/draw-canvas/processors/targetIsActive.ts","webpack:///./src/draw-canvas/processors/transformToCenter.ts","webpack:///./src/draw-canvas/processors/updateCells.ts","webpack:///./src/draw-canvas/reducers/cells.ts","webpack:///./src/draw-canvas/reducers/index.ts","webpack:///./src/draw-canvas/reducers/layoutKey.ts","webpack:///./src/shared/canvas/icons/center.svg","webpack:///./src/shared/canvas/icons/zoom-in.svg","webpack:///./src/shared/canvas/icons/zoom-out.svg","webpack:///./src/shared/canvas/ZoomBarComponent.tsx","webpack:///./src/shared/canvas/dagreLayout.ts","webpack:///./src/shared/canvas/forceLayout.ts","webpack:///./src/shared/canvas/processors/nodeViewToNodeRect.ts","webpack:///./src/shared/canvas/processors/getSmartLinePoints.ts","webpack:///./src/shared/canvas/shapes/Rectangle.ts","webpack:///./src/shared/canvas/useActiveTarget.ts","webpack:///./src/draw-canvas/processors/normalizeAlignOrigin.ts","webpack:///./src/shared/canvas/useLayout.ts","webpack:///./src/shared/canvas/useAutoCenter.ts","webpack:///./src/shared/canvas/useLineMarkers.ts","webpack:///./src/shared/canvas/useReady.ts","webpack:///./src/shared/canvas/useZoom.ts","webpack:///./src/shared/canvas/ZoomBarComponent.shadow.css","webpack:///./src/shared/canvas/styles.shadow.css"],"sourcesContent":["import type { Cell, NodeCell, DecoratorCell, NodeId } from \"../interfaces\";\nimport { isNodeOrAreaDecoratorCell } from \"./asserts\";\n\nexport function findNodeOrAreaDecorator(\n  cells: Cell[],\n  id: NodeId\n): NodeCell | DecoratorCell | undefined {\n  return cells.find(\n    (cell) => isNodeOrAreaDecoratorCell(cell) && cell.id === id\n  ) as NodeCell | DecoratorCell | undefined;\n}\n","import React, { useEffect, useMemo, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport type { Cell, ComputedEdgeLineConf, EdgeCell } from \"./interfaces\";\nimport { isEdgeCell, isStraightType } from \"./processors/asserts\";\nimport { DEFAULT_LINE_INTERACT_ANIMATE_DURATION } from \"./constants\";\nimport { curveLine } from \"../diagram/lines/curveLine\";\nimport { getSmartLinePoints } from \"../shared/canvas/processors/getSmartLinePoints\";\nimport { findNodeOrAreaDecorator } from \"./processors/findNodeOrAreaDecorator\";\nimport { useHoverStateContext } from \"./HoverStateContext\";\nimport { getMarkers } from \"../shared/canvas/useLineMarkers\";\nimport { LineMarkerConf } from \"../diagram/interfaces\";\n\nexport interface EdgeComponentProps {\n  edge: EdgeCell;\n  cells: Cell[];\n  lineConfMap: WeakMap<EdgeCell, ComputedEdgeLineConf>;\n  active?: boolean;\n}\n\nexport function EdgeComponent({\n  edge,\n  cells,\n  lineConfMap,\n  active,\n}: EdgeComponentProps): JSX.Element | null {\n  const { setActiveEditableLine } = useHoverStateContext();\n  const pathRef = useRef<SVGPathElement>(null);\n  const sourceNode = useMemo(\n    () => findNodeOrAreaDecorator(cells, edge.source),\n    [cells, edge.source]\n  );\n  const targetNode = useMemo(\n    () => findNodeOrAreaDecorator(cells, edge.target),\n    [cells, edge.target]\n  );\n  const lineConf = useMemo(() => lineConfMap.get(edge)!, [edge, lineConfMap]);\n\n  const parallelGap = useMemo(() => {\n    const hasOppositeEdge =\n      isStraightType(edge.view?.type) &&\n      cells.some(\n        (cell) =>\n          isEdgeCell(cell) &&\n          cell.source === edge.target &&\n          cell.target === edge.source &&\n          isStraightType(cell.view?.type)\n      );\n    return hasOppositeEdge ? lineConf.parallelGap : 0;\n  }, [cells, edge.source, edge.target, edge.view, lineConf.parallelGap]);\n\n  const linePoints = useMemo(() => {\n    const points =\n      sourceNode &&\n      targetNode &&\n      sourceNode.view.x != null &&\n      targetNode.view.x != null\n        ? getSmartLinePoints(\n            sourceNode.view,\n            targetNode.view,\n            edge.view,\n            parallelGap\n          )\n        : null;\n    return points;\n  }, [edge.view, parallelGap, sourceNode, targetNode]);\n\n  const line = useMemo(() => {\n    const fixedLineType = lineConf.type;\n    return curveLine(\n      linePoints,\n      fixedLineType === \"curve\" ? lineConf.curveType : \"curveLinear\",\n      0,\n      1\n    );\n  }, [lineConf, linePoints]);\n\n  useEffect(() => {\n    setActiveEditableLine((prev) =>\n      active\n        ? linePoints && sourceNode && targetNode\n          ? {\n              edge,\n              source: sourceNode,\n              target: targetNode,\n              linePoints,\n              lineType: lineConf.type,\n              lineCurveType: lineConf.curveType,\n              parallelGap,\n            }\n          : null\n        : prev?.edge &&\n            prev.edge.source === edge.source &&\n            prev.edge.target === edge.target\n          ? null\n          : prev\n    );\n  }, [\n    active,\n    edge,\n    lineConf.curveType,\n    lineConf.type,\n    linePoints,\n    setActiveEditableLine,\n    sourceNode,\n    targetNode,\n    parallelGap,\n  ]);\n\n  if (!line || !linePoints) {\n    // This happens when source or target is not found,\n    // or when source or target has not been positioned yet.\n    return null;\n  }\n\n  let markerStart: string | undefined;\n  let markerEnd: string | undefined;\n  const lineMarkers: LineMarkerConf[] = getMarkers(lineConf);\n  for (const marker of lineMarkers) {\n    if (marker.placement === \"start\") {\n      markerStart = lineConf.$markerStartUrl;\n    } else {\n      markerEnd = lineConf.$markerEndUrl;\n    }\n  }\n\n  return (\n    <>\n      <path\n        // This `path` is made for expanding interaction area of graph lines.\n        d={line}\n        fill=\"none\"\n        stroke=\"transparent\"\n        strokeWidth={lineConf.interactStrokeWidth}\n      />\n      <path\n        ref={pathRef}\n        className={classNames(\"line\", {\n          dashed: lineConf.dashed,\n          dotted: lineConf.dotted,\n          [`${lineConf.dashed ? \"dashed\" : lineConf.dotted ? \"dotted\" : \"solid\"}-animation`]:\n            lineConf.animate.useAnimate,\n        })}\n        style={\n          {\n            \"--time\": `${lineConf.animate.duration ?? DEFAULT_LINE_INTERACT_ANIMATE_DURATION}s`,\n            \"--solid-length\": pathRef.current?.getTotalLength?.(),\n          } as React.CSSProperties\n        }\n        d={line}\n        fill=\"none\"\n        stroke={lineConf.strokeColor}\n        strokeWidth={lineConf.strokeWidth}\n        markerStart={markerStart}\n        markerEnd={markerEnd}\n      />\n      <path className=\"line-active-bg\" d={line} fill=\"none\" />\n    </>\n  );\n}\n","import React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { ReactUseBrick } from \"@next-core/react-runtime\";\nimport { __secret_internals, checkIfByTransform } from \"@next-core/runtime\";\nimport { isEqual } from \"lodash\";\nimport ResizeObserver from \"resize-observer-polyfill\";\nimport type { NodeBrickCell, NodeBrickConf, NodeCell } from \"./interfaces\";\nimport type { SizeTuple } from \"../diagram/interfaces\";\n\nexport interface NodeComponentProps {\n  node: NodeCell;\n  degraded: boolean;\n  degradedNodeLabel?: string;\n  defaultNodeBricks?: NodeBrickConf[];\n  onResize(id: string, size: SizeTuple | null): void;\n}\n\nexport function NodeComponent({\n  node,\n  degraded,\n  degradedNodeLabel,\n  defaultNodeBricks,\n  onResize,\n}: NodeComponentProps): JSX.Element | null {\n  const memoizedData = useDeepMemo({ node: { id: node.id, data: node.data } });\n  const specifiedUseBrick = (node as NodeBrickCell).useBrick;\n  const observerRef = useRef<ResizeObserver | null>(null);\n\n  const useBrick = useMemo(() => {\n    return degraded\n      ? null\n      : specifiedUseBrick ??\n          defaultNodeBricks?.find((item) =>\n            checkIfByTransform(item, memoizedData)\n          )?.useBrick;\n  }, [degraded, specifiedUseBrick, defaultNodeBricks, memoizedData]);\n\n  const label = useMemo<string>(\n    () =>\n      degraded\n        ? String(\n            __secret_internals.legacyDoTransform(\n              memoizedData,\n              degradedNodeLabel ?? \"<% DATA.node.id %>\"\n            )\n          )\n        : \"\",\n    [degraded, degradedNodeLabel, memoizedData]\n  );\n\n  const refCallback = useCallback(\n    (element: HTMLElement | null) => {\n      const prevObserver = observerRef.current;\n      if (prevObserver) {\n        prevObserver.disconnect();\n        observerRef.current = null;\n      }\n      if (element) {\n        // Todo: correctly wait for `useBrick` in v3 to be rendered (after layout)\n        // Wait a macro task to let `useBrick` to be rendered.\n        setTimeout(() => {\n          const observer = new ResizeObserver(() => {\n            onResize(node.id, [element.offsetWidth, element.offsetHeight]);\n          });\n          observer.observe(element);\n          observerRef.current = observer;\n        });\n      } else {\n        onResize(node.id, null);\n      }\n    },\n    [node.id, onResize]\n  );\n\n  const degradedRefCallBack = useCallback(\n    (g: SVGGElement | null) => {\n      if (g) {\n        // istanbul ignore next\n        const size =\n          process.env.NODE_ENV === \"test\"\n            ? { width: 60, height: 60 }\n            : g.getBBox();\n        onResize(node.id, [size.width, size.height]);\n      } else {\n        onResize(node.id, null);\n      }\n    },\n    [node.id, onResize]\n  );\n\n  return useBrick ? (\n    <foreignObject\n      // Make a large size to avoid the brick inside to be clipped by the foreignObject.\n      width={9999}\n      height={9999}\n      className=\"node\"\n    >\n      {useBrick && (\n        <ReactUseBrick\n          useBrick={useBrick}\n          data={memoizedData}\n          refCallback={refCallback}\n        />\n      )}\n    </foreignObject>\n  ) : degraded ? (\n    <g className=\"degraded\" ref={degradedRefCallBack}>\n      <circle cx={8} cy={8} r={8} />\n      <text x={8} y={32}>\n        {label}\n      </text>\n    </g>\n  ) : null;\n}\n\nfunction useDeepMemo<T>(value: T): T {\n  const [memoizedValue, setMemoizedValue] = useState(value);\n\n  useEffect(() => {\n    setMemoizedValue((prev) => (isEqual(prev, value) ? prev : value));\n  }, [value]);\n\n  return memoizedValue;\n}\n","import type { PositionTuple } from \"../../diagram/interfaces\";\nimport type {\n  ActiveTarget,\n  Cell,\n  LayoutOptions,\n  DecoratorCell,\n  LayoutType,\n  NodeCell,\n  NodeView,\n} from \"../interfaces\";\nimport type {\n  MoveCellPayload,\n  ResizeCellPayload,\n} from \"../reducers/interfaces\";\nimport {\n  isContainerDecoratorCell,\n  isDecoratorCell,\n  isEdgeCell,\n  isNodeCell,\n} from \"./asserts\";\nimport { cellToTarget } from \"./cellToTarget\";\nimport { normalizeSnapOptions } from \"./normalizeSnapOptions\";\nimport { targetIsActive } from \"./targetIsActive\";\n\nexport function handleMouseDown(\n  event: MouseEvent,\n  {\n    action,\n    cell,\n    scale,\n    layout,\n    layoutOptions,\n    activeTarget,\n    cells,\n    onCellsMoving,\n    onCellsMoved,\n    onCellResizing,\n    onCellResized,\n    onSwitchActiveTarget,\n  }: {\n    action: \"move\" | \"resize\";\n    cell: Cell;\n    scale: number;\n    layout?: LayoutType;\n    layoutOptions?: LayoutOptions;\n    activeTarget: ActiveTarget | null | undefined;\n    cells: Cell[];\n    onCellsMoving?(info: MoveCellPayload[]): void;\n    onCellsMoved?(info: MoveCellPayload[]): void;\n    onCellResizing?(info: ResizeCellPayload): void;\n    onCellResized?(info: ResizeCellPayload): void;\n    onSwitchActiveTarget?(activeTarget: ActiveTarget | null): void;\n  }\n) {\n  event.stopPropagation();\n  // Drag node\n  if (action === \"resize\" || !targetIsActive(cell, activeTarget)) {\n    onSwitchActiveTarget?.(cellToTarget(cell));\n  }\n  if (isEdgeCell(cell)) {\n    return;\n  }\n  const activeCells: Cell[] = [];\n  const actives =\n    activeTarget?.type === \"multi\" && action === \"move\"\n      ? cells.filter((c) => targetIsActive(c, activeTarget))\n      : [cell];\n  actives.forEach((a) => {\n    activeCells.push(a);\n    if (action === \"move\" && isContainerDecoratorCell(a)) {\n      activeCells.push(\n        ...cells.filter(\n          (c) => isNodeCell(c) && c.containerId === a.id && !actives.includes(c)\n        )\n      );\n    }\n  });\n  const isAutoLayout = layout === \"force\" || layout === \"dagre\";\n  const movableActiveCells = activeCells.filter(\n    (c) => (isNodeCell(c) && !isAutoLayout) || isDecoratorCell(c)\n  ) as (NodeCell | DecoratorCell)[];\n\n  if (movableActiveCells.length === 0) {\n    return;\n  }\n\n  const snap = normalizeSnapOptions(layoutOptions?.snap);\n\n  const from: PositionTuple = [event.clientX, event.clientY];\n  const originals = movableActiveCells.map<{\n    cell: NodeCell | DecoratorCell;\n    position: PositionTuple;\n    center: PositionTuple | null;\n  }>((c) => ({\n    cell: c,\n    position:\n      action === \"move\" ? [c.view.x, c.view.y] : [c.view.width, c.view.height],\n    center:\n      action === \"move\" && !isEdgeCell(c) ? getCenterPosition(c.view) : null,\n  }));\n  const firstOriginalPosition = originals[0].position;\n  let previousPositions = originals.map(({ position }) => position);\n\n  // Get the positions of the objects (cells that are not active) to snap to\n  let snapToObjectTargets: {\n    cell: NodeCell | DecoratorCell;\n    center: PositionTuple;\n  }[] = [];\n  if (action === \"move\" && snap.object) {\n    const objectCells = cells.filter(\n      (c) => !isEdgeCell(c) && !activeCells.includes(c)\n    ) as (NodeCell | DecoratorCell)[];\n    snapToObjectTargets = objectCells.map((c) => ({\n      cell: c,\n      center: getCenterPosition(c.view),\n    }));\n  }\n\n  function getMovement(e: MouseEvent): PositionTuple {\n    return [(e.clientX - from[0]) / scale, (e.clientY - from[1]) / scale];\n  }\n  let moved = false;\n\n  const handleMove = (e: MouseEvent, finished?: boolean) => {\n    // Respect the scale\n    const movement = getMovement(e);\n    let newPositions: PositionTuple[];\n    let xAlign: [PositionTuple, PositionTuple] | undefined;\n    let yAlign: [PositionTuple, PositionTuple] | undefined;\n    let xAlignCell: Cell | undefined;\n    let yAlignCell: Cell | undefined;\n\n    // Use alt key (or option key  on Mac) to disable snap\n    if ((!snap.grid && !snap.object) || e.altKey) {\n      // No snap\n      newPositions = originals.map(({ position }) => [\n        position[0] + movement[0],\n        position[1] + movement[1],\n      ]);\n      if (!moved) {\n        moved = movement[0] ** 2 + movement[1] ** 2 >= 9;\n      }\n    } else {\n      // Snap\n      let diffX = Infinity;\n      let diffY = Infinity;\n      const snapMovement: PositionTuple = [...movement];\n\n      if (snap.object) {\n        const snapToObjectDistance = snap.object.distance;\n        let xAlignFrom: PositionTuple | undefined;\n        let yAlignFrom: PositionTuple | undefined;\n        let xAlignTarget: NodeCell | DecoratorCell | undefined;\n        let yAlignTarget: NodeCell | DecoratorCell | undefined;\n        let xAlignToY = 0;\n        let yAlignToX = 0;\n        for (const {\n          cell: target,\n          center: [x, y],\n        } of snapToObjectTargets) {\n          for (const { cell: c, center } of originals) {\n            const [cx, cy] = center!;\n            const dX = Math.abs(cx + movement[0] - x);\n            const dY = Math.abs(cy + movement[1] - y);\n            const xSnapped = dX < snapToObjectDistance && dX < diffX;\n            const ySnapped = dY < snapToObjectDistance && dY < diffY;\n            if (xSnapped) {\n              diffX = dX;\n              snapMovement[0] = x - cx;\n              xAlignCell = c;\n              xAlignTarget = target;\n              xAlignFrom = [x, y];\n              xAlignToY = cy;\n            }\n            if (ySnapped) {\n              diffY = dY;\n              snapMovement[1] = y - cy;\n              yAlignCell = c;\n              yAlignTarget = target;\n              yAlignFrom = [x, y];\n              yAlignToX = cx;\n            }\n          }\n        }\n\n        if (xAlignTarget && xAlignTarget === yAlignTarget) {\n          // Handle special case when both x and y are snapped to the same target.\n          const halfHeight = xAlignTarget.view.height / 2;\n          const halfWidth = xAlignTarget.view.width / 2;\n          xAlign = [\n            [xAlignFrom![0], xAlignFrom![1] - halfHeight],\n            [xAlignFrom![0], xAlignFrom![1] + halfHeight],\n          ];\n          yAlign = [\n            [yAlignFrom![0] - halfWidth, yAlignFrom![1]],\n            [yAlignFrom![0] + halfWidth, yAlignFrom![1]],\n          ];\n        } else {\n          if (xAlignFrom) {\n            xAlign = [xAlignFrom, [xAlignFrom[0], xAlignToY + snapMovement[1]]];\n          }\n          if (yAlignFrom) {\n            yAlign = [yAlignFrom, [yAlignToX + snapMovement[0], yAlignFrom[1]]];\n          }\n        }\n      }\n\n      if (snap.grid) {\n        const snapToGridSize = snap.grid.size;\n        // Use the first cell to decide the snap to grid position\n        const firstNewPosition: PositionTuple = [\n          Math.round(\n            (firstOriginalPosition[0] + movement[0]) / snapToGridSize\n          ) * snapToGridSize,\n          Math.round(\n            (firstOriginalPosition[1] + movement[1]) / snapToGridSize\n          ) * snapToGridSize,\n        ];\n        const snapToGridMovement: PositionTuple = [\n          firstNewPosition[0] - firstOriginalPosition[0],\n          firstNewPosition[1] - firstOriginalPosition[1],\n        ];\n        const snapToGridDiffX = Math.abs(snapToGridMovement[0] - movement[0]);\n        const snapToGridDiffY = Math.abs(snapToGridMovement[1] - movement[1]);\n        if (snapToGridDiffX < diffX) {\n          diffX = snapToGridDiffX;\n          snapMovement[0] = snapToGridMovement[0];\n          xAlign = undefined;\n          xAlignCell = undefined;\n        }\n        if (snapToGridDiffY < diffY) {\n          diffY = snapToGridDiffY;\n          snapMovement[1] = snapToGridMovement[1];\n          yAlign = undefined;\n          yAlignCell = undefined;\n        }\n      }\n\n      newPositions = originals.map(({ position }) => [\n        Math.round(position[0] + snapMovement[0]),\n        Math.round(position[1] + snapMovement[1]),\n      ]);\n      const changed =\n        newPositions[0][0] !== previousPositions[0][0] ||\n        newPositions[0][1] !== previousPositions[0][1];\n      if (changed) {\n        previousPositions = newPositions;\n        moved = true;\n      }\n    }\n\n    if (moved) {\n      if (action === \"move\") {\n        const payloads = originals.map(({ cell: c }, index) => ({\n          type: c.type,\n          id: c.id,\n          x: newPositions[index][0],\n          y: newPositions[index][1],\n          width: c.view.width,\n          height: c.view.height,\n          decorator: isDecoratorCell(c) ? c.decorator : undefined,\n          guideLines: finished\n            ? undefined\n            : [\n                ...(xAlignCell === c ? [xAlign!] : []),\n                ...(yAlignCell === c ? [yAlign!] : []),\n              ],\n        }));\n        (finished ? onCellsMoved : onCellsMoving)?.(payloads);\n      } else {\n        (finished ? onCellResized : onCellResizing)?.({\n          type: cell.type,\n          id: cell.id,\n          width: newPositions[0][0],\n          height: newPositions[0][1],\n        });\n      }\n    }\n  };\n\n  const onMouseMove = (e: MouseEvent) => {\n    handleMove(e);\n  };\n  const onMouseUp = (e: MouseEvent) => {\n    handleMove(e, true);\n    moved = false;\n    document.removeEventListener(\"mousemove\", onMouseMove);\n    document.removeEventListener(\"mouseup\", onMouseUp);\n  };\n  document.addEventListener(\"mousemove\", onMouseMove);\n  document.addEventListener(\"mouseup\", onMouseUp);\n}\n\nfunction getCenterPosition(view: NodeView): PositionTuple {\n  return [view.x + view.width / 2, view.y + view.height / 2];\n}\n","import {\n  DEFAULT_SNAP_GRID_SIZE,\n  DEFAULT_SNAP_OBJECT_DISTANCE,\n} from \"../constants\";\nimport type {\n  SnapOptions,\n  SnapToGridOptions,\n  SnapToObjectOptions,\n} from \"../interfaces\";\n\nexport interface NormalizedSnapOptions {\n  grid: Required<SnapToGridOptions> | null;\n  object: Required<SnapToObjectOptions> | null;\n}\n\nexport function normalizeSnapOptions(\n  snap: boolean | SnapOptions | undefined\n): NormalizedSnapOptions {\n  const intermediateSnap = snap\n    ? snap === true\n      ? { grid: true, object: true }\n      : snap\n    : null;\n  const snapToGrid = intermediateSnap?.grid\n    ? intermediateSnap.grid === true\n      ? {}\n      : intermediateSnap.grid\n    : null;\n  const snapToObject = intermediateSnap?.object\n    ? intermediateSnap.object === true\n      ? {}\n      : intermediateSnap.object\n    : null;\n  return {\n    grid: snapToGrid\n      ? { size: snapToGrid.size ?? DEFAULT_SNAP_GRID_SIZE }\n      : null,\n    object: snapToObject\n      ? { distance: snapToObject.distance ?? DEFAULT_SNAP_OBJECT_DISTANCE }\n      : null,\n  };\n}\n","import React, { useEffect } from \"react\";\nimport type { BasicDecoratorProps } from \"../interfaces\";\nimport { handleMouseDown } from \"../processors/handleMouseDown\";\n\nexport function DecoratorArea({\n  cell,\n  transform,\n  readOnly,\n  layoutOptions,\n  activeTarget,\n  cells,\n  onCellResizing,\n  onCellResized,\n  onSwitchActiveTarget,\n}: BasicDecoratorProps): JSX.Element {\n  const resizeHandleRef = React.useRef<SVGGElement>(null);\n\n  useEffect(() => {\n    const resizeHandle = resizeHandleRef.current;\n    if (!resizeHandle || readOnly) {\n      return;\n    }\n    const onMouseDown = (event: MouseEvent) => {\n      handleMouseDown(event, {\n        action: \"resize\",\n        cell,\n        scale: transform.k,\n        layoutOptions,\n        activeTarget,\n        cells,\n        onCellResizing,\n        onCellResized,\n        onSwitchActiveTarget,\n      });\n    };\n    resizeHandle.addEventListener(\"mousedown\", onMouseDown);\n    return () => {\n      resizeHandle.removeEventListener(\"mousedown\", onMouseDown);\n    };\n  }, [\n    activeTarget,\n    cell,\n    cells,\n    layoutOptions,\n    onCellResized,\n    onCellResizing,\n    onSwitchActiveTarget,\n    readOnly,\n    transform.k,\n  ]);\n\n  return (\n    <g className=\"decorator-area\">\n      <rect\n        width={cell.view.width}\n        height={cell.view.height}\n        className=\"area\"\n      />\n      {!readOnly && (\n        <g\n          ref={resizeHandleRef}\n          className=\"resize-handle\"\n          transform={`translate(${cell.view.width - 20} ${cell.view.height - 20})`}\n        >\n          <rect width={20} height={20} />\n          <path d=\"M10 18L18 10 M15 18L18 15\" />\n        </g>\n      )}\n    </g>\n  );\n}\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { BasicDecoratorProps } from \"../interfaces\";\nimport classNames from \"classnames\";\n\nexport type DecoratorTextProps = Pick<\n  BasicDecoratorProps,\n  \"cell\" | \"readOnly\" | \"onDecoratorTextEditing\" | \"onDecoratorTextChange\"\n>;\n\nexport function DecoratorText({\n  cell,\n  readOnly,\n  onDecoratorTextEditing,\n  onDecoratorTextChange,\n}: DecoratorTextProps): JSX.Element {\n  const label = cell.view.text ?? \"\";\n  const [currentLabel, setCurrentLabel] = useState<string>(label);\n  const [editingLabel, setEditingLabel] = useState(false);\n  const editingLabelInitialized = useRef(false);\n  const [shouldEmitLabelChange, setShouldEmitLabelChange] = useState(false);\n  const ref = useRef<HTMLDivElement>(null);\n\n  const handleEnableEdit = useCallback(\n    (e: React.MouseEvent) => {\n      if (readOnly) {\n        return;\n      }\n      e.preventDefault();\n      e.stopPropagation();\n      setEditingLabel(true);\n    },\n    [readOnly]\n  );\n\n  useEffect(() => {\n    const element = ref.current;\n    if (element && element.textContent !== currentLabel) {\n      element.textContent = currentLabel;\n    }\n  }, [currentLabel]);\n  useEffect(() => {\n    const parentElement = ref.current?.parentElement;\n    if (parentElement) {\n      cell.view.width = parentElement.clientWidth;\n      cell.view.height = parentElement.clientHeight;\n    }\n  }, [currentLabel, cell.id]);\n\n  useEffect(() => {\n    if (editingLabel && ref.current) {\n      ref.current.focus();\n      selectAllText(ref.current);\n    }\n    onDecoratorTextEditing?.({ id: cell.id, editing: editingLabel });\n  }, [cell.id, editingLabel, onDecoratorTextEditing]);\n\n  useEffect(() => {\n    if (editingLabelInitialized.current) {\n      onDecoratorTextEditing?.({ id: cell.id, editing: editingLabel });\n    } else {\n      editingLabelInitialized.current = true;\n    }\n  }, [cell.id, editingLabel, onDecoratorTextEditing]);\n\n  const handleInput = useCallback(\n    (event: React.FormEvent<HTMLDivElement>) => {\n      if (readOnly) {\n        return;\n      }\n      setCurrentLabel((event.target as HTMLDivElement).textContent!);\n    },\n    [readOnly]\n  );\n\n  const handleBlur = useCallback(() => {\n    if (readOnly) {\n      return;\n    }\n    setEditingLabel(false);\n    setShouldEmitLabelChange(true);\n  }, [readOnly]);\n\n  useEffect(() => {\n    if (shouldEmitLabelChange) {\n      onDecoratorTextChange?.({\n        id: cell.id,\n        view: { ...cell.view, text: currentLabel },\n      });\n      setShouldEmitLabelChange(false);\n    }\n  }, [cell, currentLabel, onDecoratorTextChange, shouldEmitLabelChange]);\n\n  return (\n    <foreignObject className=\"decorator-text\">\n      <div\n        className={classNames(\"text-container\", { editing: editingLabel })}\n        onDoubleClick={handleEnableEdit}\n      >\n        <div\n          className=\"text\"\n          contentEditable={editingLabel}\n          ref={ref}\n          onInput={handleInput}\n          onBlur={handleBlur}\n        />\n      </div>\n    </foreignObject>\n  );\n}\n\nexport function selectAllText(element: HTMLElement) {\n  const range = document.createRange();\n  range.selectNodeContents(element);\n  const selection = window.getSelection()!;\n  selection.removeAllRanges();\n  selection.addRange(range);\n}\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { BasicDecoratorProps } from \"../interfaces\";\nimport { handleMouseDown } from \"../processors/handleMouseDown\";\nimport classNames from \"classnames\";\nimport { get } from \"lodash\";\nimport { selectAllText } from \"./DecoratorText\";\nimport { isNoManualLayout } from \"../processors/asserts\";\nimport { uuidV4 } from \"..\";\n\nexport function DecoratorContainer({\n  cell,\n  transform,\n  readOnly,\n  layout,\n  view,\n  activeTarget,\n  cells,\n  onCellResizing,\n  onCellResized,\n  onSwitchActiveTarget,\n  onDecoratorTextEditing,\n  onDecoratorTextChange,\n}: BasicDecoratorProps): JSX.Element {\n  const label = get(cell.view, \"text\", \"\");\n  const direction = get(cell.view, \"direction\", \"top\");\n  const textRef = useRef<HTMLDivElement>(null);\n  const resizeHandleRef = React.useRef<SVGGElement>(null);\n  const [editingLabel, setEditingLabel] = useState(false);\n  const [currentLabel, setCurrentLabel] = useState<string>(label);\n  const [shouldEmitLabelChange, setShouldEmitLabelChange] = useState(false);\n  const [recomputation, setRecomputation] = useState<string>();\n  const [titleForeignRect, setTitleForeignRect] = useState({\n    x: 0,\n    y: 0,\n    width: cell.view.width,\n    height: cell.view.height,\n  });\n  const handleEnableEdit = useCallback(\n    (e: React.MouseEvent) => {\n      if (readOnly) {\n        return;\n      }\n      e.preventDefault();\n      e.stopPropagation();\n      setEditingLabel(true);\n    },\n    [readOnly]\n  );\n  const handleInput = useCallback(\n    (event: React.FormEvent<HTMLDivElement>) => {\n      if (readOnly) {\n        return;\n      }\n      setCurrentLabel((event.target as HTMLDivElement).textContent!);\n    },\n    [readOnly]\n  );\n\n  const handleBlur = useCallback(() => {\n    if (readOnly) {\n      return;\n    }\n    setEditingLabel(false);\n    setShouldEmitLabelChange(true);\n    setRecomputation(uuidV4());\n  }, [readOnly]);\n\n  useEffect(() => {\n    setCurrentLabel(label);\n  }, [label]);\n  useEffect(() => {\n    const element = textRef.current;\n    if (element && element.textContent !== currentLabel) {\n      element.textContent = currentLabel;\n    }\n  }, [currentLabel]);\n\n  useEffect(() => {\n    const textParentEle = textRef.current?.parentElement;\n    if (textParentEle) {\n      const { clientWidth, clientHeight } = textParentEle;\n      if ([\"left\", \"right\"].includes(direction)) {\n        const rect = {\n          width: clientWidth,\n          height: view.height,\n          x: direction === \"left\" ? -clientWidth : view.width,\n          y: 0,\n        };\n        setTitleForeignRect(rect);\n      } else {\n        const rect = {\n          width: view.width,\n          height: clientHeight,\n          x: 0,\n          y: direction === \"top\" ? -clientHeight : view.height,\n        };\n        setTitleForeignRect(rect);\n      }\n    }\n  }, [view, currentLabel, direction, recomputation]);\n\n  useEffect(() => {\n    if (editingLabel && textRef.current) {\n      textRef.current.focus();\n      selectAllText(textRef.current);\n    }\n    onDecoratorTextEditing?.({ id: cell.id, editing: editingLabel });\n  }, [cell.id, editingLabel, onDecoratorTextEditing]);\n\n  useEffect(() => {\n    if (shouldEmitLabelChange) {\n      onDecoratorTextChange?.({\n        id: cell.id,\n        view: { ...view, text: currentLabel },\n      });\n      setShouldEmitLabelChange(false);\n    }\n  }, [cell, view, currentLabel, onDecoratorTextChange, shouldEmitLabelChange]);\n\n  useEffect(() => {\n    const resizeHandle = resizeHandleRef.current;\n    if (!resizeHandle || readOnly) {\n      return;\n    }\n    const onMouseDown = (event: MouseEvent) => {\n      handleMouseDown(event, {\n        action: \"resize\",\n        cell,\n        scale: transform.k,\n        activeTarget,\n        cells,\n        onCellResizing,\n        onCellResized,\n        onSwitchActiveTarget,\n      });\n    };\n    resizeHandle.addEventListener(\"mousedown\", onMouseDown);\n    return () => {\n      resizeHandle.removeEventListener(\"mousedown\", onMouseDown);\n    };\n  }, [\n    activeTarget,\n    cell,\n    cells,\n    onCellResized,\n    onCellResizing,\n    onSwitchActiveTarget,\n    readOnly,\n    transform.k,\n  ]);\n\n  return (\n    <g className=\"decorator-container\">\n      <foreignObject {...titleForeignRect}>\n        <div\n          className={classNames(\"text-container\", {\n            editing: editingLabel,\n            [[\"left\", \"right\"].includes(direction) ? \"vertical\" : \"horizontal\"]:\n              true,\n          })}\n          onDoubleClick={handleEnableEdit}\n        >\n          <div\n            className=\"text\"\n            contentEditable={editingLabel}\n            ref={textRef}\n            onInput={handleInput}\n            onBlur={handleBlur}\n          />\n        </div>\n      </foreignObject>\n      <rect width={view.width} height={view.height} className=\"container\" />\n      {!readOnly && !isNoManualLayout(layout) && (\n        <g\n          ref={resizeHandleRef}\n          className=\"resize-handle\"\n          transform={`translate(${view.width - 20} ${view.height - 20})`}\n        >\n          <rect width={20} height={20} />\n          <path d=\"M10 18L18 10 M15 18L18 15\" />\n        </g>\n      )}\n    </g>\n  );\n}\n","import React from \"react\";\nimport type { BasicDecoratorProps } from \"../interfaces\";\nimport { DecoratorArea } from \"./DecoratorArea\";\nimport { DecoratorText } from \"./DecoratorText\";\nimport { DecoratorContainer } from \"./DecoratorContainer\";\n\nexport function DecoratorComponent({\n  cell,\n  view,\n  transform,\n  readOnly,\n  layout,\n  layoutOptions,\n  activeTarget,\n  cells,\n  onCellResizing,\n  onCellResized,\n  onSwitchActiveTarget,\n  onDecoratorTextEditing,\n  onDecoratorTextChange,\n}: BasicDecoratorProps): JSX.Element | null {\n  let SpecifiedComponent: (props: BasicDecoratorProps) => JSX.Element | null;\n\n  switch (cell.decorator) {\n    case \"container\":\n      SpecifiedComponent = DecoratorContainer;\n      break;\n    case \"area\":\n      SpecifiedComponent = DecoratorArea;\n      break;\n    case \"text\":\n      SpecifiedComponent = DecoratorText;\n      break;\n    // istanbul ignore next\n    default:\n      // eslint-disable-next-line no-console\n      console.error(`Unknown decorator: ${cell.decorator}`);\n      return null;\n  }\n\n  return (\n    <SpecifiedComponent\n      cell={cell}\n      view={view}\n      transform={transform}\n      readOnly={readOnly}\n      layout={layout}\n      layoutOptions={layoutOptions}\n      activeTarget={activeTarget}\n      cells={cells}\n      onCellResizing={onCellResizing}\n      onCellResized={onCellResized}\n      onSwitchActiveTarget={onSwitchActiveTarget}\n      onDecoratorTextEditing={onDecoratorTextEditing}\n      onDecoratorTextChange={onDecoratorTextChange}\n    />\n  );\n}\n","import { BaseNodeCell } from \"../interfaces\";\n\nexport function computeContainerRect(cells: BaseNodeCell[]) {\n  let minX = Infinity,\n    minY = Infinity;\n  let maxX = -Infinity,\n    maxY = -Infinity;\n  cells.forEach((cell) => {\n    const { x, y, width, height } = cell.view;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n  });\n  if (![minX, maxX, minY, maxY].some((n) => isFinite(n))) return {};\n  const padding = 20;\n  const width = maxX - minX + padding * 2;\n  const height = maxY - minY + padding * 2;\n  return {\n    x: minX - padding,\n    y: minY - padding,\n    width: width,\n    height: height,\n  };\n}\n","import React, { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport classNames from \"classnames\";\nimport type {\n  ActiveTarget,\n  Cell,\n  CellContextMenuDetail,\n  ComputedEdgeLineConf,\n  DecoratorTextChangeDetail,\n  DecoratorView,\n  EdgeCell,\n  LayoutOptions,\n  LayoutType,\n  NodeBrickConf,\n  NodeCell,\n} from \"./interfaces\";\nimport {\n  isContainerDecoratorCell,\n  isDecoratorCell,\n  isEdgeCell,\n  isEdgeSide,\n  isNoManualLayout,\n  isNodeCell,\n} from \"./processors/asserts\";\nimport { EdgeComponent } from \"./EdgeComponent\";\nimport { NodeComponent } from \"./NodeComponent\";\nimport { handleMouseDown } from \"./processors/handleMouseDown\";\nimport type { MoveCellPayload, ResizeCellPayload } from \"./reducers/interfaces\";\nimport { DecoratorComponent } from \"./decorators\";\nimport { cellToTarget } from \"./processors/cellToTarget\";\nimport type { SizeTuple, TransformLiteral } from \"../diagram/interfaces\";\nimport { sameTarget } from \"./processors/sameTarget\";\nimport { targetIsActive } from \"./processors/targetIsActive\";\nimport { computeContainerRect } from \"./processors/computeContainerRect\";\nimport { get } from \"lodash\";\nimport { useHoverStateContext } from \"./HoverStateContext\";\nexport interface CellComponentProps {\n  layout: LayoutType;\n  layoutOptions?: LayoutOptions;\n  cell: Cell;\n  cells: Cell[];\n  degraded: boolean;\n  degradedNodeLabel?: string;\n  defaultNodeBricks?: NodeBrickConf[];\n  transform: TransformLiteral;\n  lineConfMap: WeakMap<EdgeCell, ComputedEdgeLineConf>;\n  activeTarget: ActiveTarget | null | undefined;\n  readOnly?: boolean;\n  unrelatedCells: Cell[];\n  dragNodeToContainerActive?: boolean;\n  allowEdgeToArea?: boolean;\n  onCellsMoving?(info: MoveCellPayload[]): void;\n  onCellsMoved?(info: MoveCellPayload[]): void;\n  onCellResizing?(info: ResizeCellPayload): void;\n  onCellResized?(info: ResizeCellPayload): void;\n  onSwitchActiveTarget(target: ActiveTarget | null): void;\n  onCellContextMenu(detail: CellContextMenuDetail): void;\n  onCellClick?(detail: CellContextMenuDetail): void;\n  onDecoratorTextEditing?(detail: { id: string; editing: boolean }): void;\n  onDecoratorTextChange?(detail: DecoratorTextChangeDetail): void;\n  onNodeBrickResize(id: string, size: SizeTuple | null): void;\n  onCellMouseEnter?(cell: Cell): void;\n  onCellMouseLeave?(cell: Cell): void;\n}\n\nexport function CellComponent({\n  layout,\n  layoutOptions,\n  cell,\n  cells,\n  degraded,\n  degradedNodeLabel,\n  defaultNodeBricks,\n  lineConfMap,\n  activeTarget,\n  dragNodeToContainerActive,\n  readOnly,\n  transform,\n  unrelatedCells,\n  allowEdgeToArea,\n  onCellsMoving,\n  onCellsMoved,\n  onCellResizing,\n  onCellResized,\n  onSwitchActiveTarget,\n  onCellContextMenu,\n  onCellClick,\n  onDecoratorTextEditing,\n  onDecoratorTextChange,\n  onNodeBrickResize,\n  onCellMouseEnter,\n  onCellMouseLeave,\n}: CellComponentProps): JSX.Element | null {\n  const {\n    lineEditorState,\n    smartConnectLineState,\n    setSmartConnectLineState,\n    onConnect,\n    setLineEditorState,\n    onChangeEdgeView,\n  } = useHoverStateContext();\n  const gRef = useRef<SVGGElement>(null);\n  const unrelated = useMemo(\n    () => unrelatedCells.some((item) => sameTarget(item, cell)),\n    [cell, unrelatedCells]\n  );\n  // `containerRect` is undefined when it's an edge cell.\n  const containerRect = useMemo((): DecoratorView | undefined => {\n    if (isContainerDecoratorCell(cell) && isNoManualLayout(layout)) {\n      const containCells = cells.filter(\n        (c): c is NodeCell => isNodeCell(c) && c.containerId === cell.id\n      );\n      const view = {\n        ...cell.view,\n        ...computeContainerRect(containCells),\n      };\n      cell.view = view; //Update the rect container to make sure Lasso gets the correct size\n      return view;\n    }\n    return isEdgeCell(cell)\n      ? undefined\n      : get(cell, \"view\", { x: 0, y: 0, width: 0, height: 0 });\n  }, [layout, cell, cells]);\n\n  useEffect(() => {\n    const g = gRef.current;\n    if (!g) {\n      return;\n    }\n    const onMouseDown = (event: MouseEvent) => {\n      if (\n        readOnly ||\n        (isContainerDecoratorCell(cell) && isNoManualLayout(layout))\n      ) {\n        event.stopPropagation();\n      } else {\n        handleMouseDown(event, {\n          layout,\n          layoutOptions,\n          action: \"move\",\n          cell,\n          scale: transform.k,\n          activeTarget,\n          cells,\n          onCellsMoving,\n          onCellsMoved,\n          onSwitchActiveTarget,\n        });\n      }\n    };\n    g.addEventListener(\"mousedown\", onMouseDown);\n    return () => {\n      g.removeEventListener(\"mousedown\", onMouseDown);\n    };\n  }, [\n    layout,\n    layoutOptions,\n    cell,\n    activeTarget,\n    cells,\n    onCellsMoved,\n    onCellsMoving,\n    onSwitchActiveTarget,\n    readOnly,\n    transform.k,\n  ]);\n\n  // istanbul ignore next: experimental\n  useEffect(() => {\n    const g = gRef.current;\n    if (\n      !g ||\n      !isEdgeSide(cell, allowEdgeToArea) ||\n      !(\n        smartConnectLineState ||\n        (lineEditorState && lineEditorState.type !== \"control\")\n      )\n    ) {\n      return;\n    }\n    const onMouseUp = (e: MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (smartConnectLineState) {\n        if (smartConnectLineState.source !== cell) {\n          onConnect?.(\n            smartConnectLineState.source,\n            cell,\n            smartConnectLineState.exitPosition,\n            undefined\n          );\n        }\n        setSmartConnectLineState(null);\n      } else if (lineEditorState) {\n        const {\n          type,\n          source,\n          target,\n          edge: { view },\n        } = lineEditorState;\n\n        const isEntry = type === \"entry\";\n        if ((isEntry ? target : source) === cell) {\n          if (isEntry) {\n            onChangeEdgeView?.(source, target, {\n              ...view,\n              entryPosition: null,\n              // ...(!view?.exitPosition ? { vertices: null } : {}),\n            });\n          } else {\n            onChangeEdgeView?.(source, target, {\n              ...view,\n              exitPosition: null,\n              // ...(!view?.entryPosition ? { vertices: null } : {}),\n            });\n          }\n        }\n        setLineEditorState(null);\n      }\n    };\n    g.addEventListener(\"mouseup\", onMouseUp);\n    return () => {\n      g.removeEventListener(\"mouseup\", onMouseUp);\n    };\n  }, [\n    allowEdgeToArea,\n    cell,\n    lineEditorState,\n    onChangeEdgeView,\n    onConnect,\n    setLineEditorState,\n    setSmartConnectLineState,\n    smartConnectLineState,\n  ]);\n\n  const handleContextMenu = useCallback(\n    (event: React.MouseEvent<SVGGElement>) => {\n      if (readOnly && cell.type === \"decorator\") {\n        return;\n      }\n      event.preventDefault();\n      onSwitchActiveTarget(cellToTarget(cell));\n      onCellContextMenu({\n        cell,\n        clientX: event.clientX,\n        clientY: event.clientY,\n      });\n    },\n    [cell, onCellContextMenu, onSwitchActiveTarget, readOnly]\n  );\n\n  const handleCellClick = useCallback(\n    (event: React.MouseEvent<SVGGElement>) => {\n      if (!onCellClick || cell.type === \"decorator\") {\n        return;\n      }\n      onCellClick({\n        cell,\n        clientX: event.clientX,\n        clientY: event.clientY,\n      });\n    },\n    [cell, onCellClick]\n  );\n\n  const handleMouseEnter = useCallback(() => {\n    onCellMouseEnter?.(cell);\n  }, [cell, onCellMouseEnter]);\n\n  const handleMouseLeave = useCallback(() => {\n    onCellMouseLeave?.(cell);\n  }, [cell, onCellMouseLeave]);\n\n  const active = targetIsActive(cell, activeTarget);\n\n  return (\n    <g\n      className={classNames(\"cell\", {\n        active,\n        faded: unrelated,\n        \"read-only\": readOnly,\n        \"container-active\": dragNodeToContainerActive,\n      })}\n      ref={gRef}\n      transform={\n        cell.type === \"edge\" || cell.view.x == null\n          ? undefined\n          : `translate(${containerRect!.x} ${containerRect!.y})`\n      }\n      onContextMenu={handleContextMenu}\n      onClick={handleCellClick}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n    >\n      {isNodeCell(cell) ? (\n        <NodeComponent\n          node={cell}\n          degraded={degraded}\n          degradedNodeLabel={degradedNodeLabel}\n          defaultNodeBricks={defaultNodeBricks}\n          onResize={onNodeBrickResize}\n        />\n      ) : isEdgeCell(cell) ? (\n        <EdgeComponent\n          edge={cell}\n          cells={cells}\n          lineConfMap={lineConfMap}\n          active={active}\n        />\n      ) : isDecoratorCell(cell) ? (\n        <DecoratorComponent\n          cell={cell}\n          view={containerRect!}\n          transform={transform}\n          readOnly={readOnly}\n          layout={layout}\n          layoutOptions={layoutOptions}\n          activeTarget={activeTarget}\n          cells={cells}\n          onCellResizing={onCellResizing}\n          onCellResized={onCellResized}\n          onSwitchActiveTarget={onSwitchActiveTarget}\n          onDecoratorTextEditing={onDecoratorTextEditing}\n          onDecoratorTextChange={onDecoratorTextChange}\n        />\n      ) : null}\n    </g>\n  );\n}\n","import React, { useEffect, useState } from \"react\";\nimport classNames from \"classnames\";\nimport type { ConnectLineState } from \"./interfaces\";\nimport type { PositionTuple, TransformLiteral } from \"../diagram/interfaces\";\n\nexport interface ConnectLineComponentProps {\n  connectLineState: ConnectLineState | null;\n  transform: TransformLiteral;\n  markerEnd: string;\n  onConnect(state: ConnectLineState, to: PositionTuple): void;\n}\n\nexport function ConnectLineComponent({\n  connectLineState,\n  transform,\n  markerEnd,\n  onConnect,\n}: ConnectLineComponentProps): JSX.Element {\n  const [connectLineTo, setConnectLineTo] = useState<PositionTuple | null>(\n    null\n  );\n\n  useEffect(() => {\n    if (connectLineState) {\n      setConnectLineTo(connectLineState.from);\n    }\n  }, [connectLineState]);\n\n  useEffect(() => {\n    if (connectLineState) {\n      const getConnectTo = (e: MouseEvent): PositionTuple => [\n        (e.clientX - transform.x - connectLineState.offset[0]) / transform.k,\n        (e.clientY - transform.y - connectLineState.offset[1]) / transform.k,\n      ];\n      const onMouseMove = (e: MouseEvent) => {\n        // Set connect line to based on the mouse position and the transform\n        setConnectLineTo(getConnectTo(e));\n      };\n      const onMouseDown = (e: MouseEvent) => {\n        e.stopPropagation();\n      };\n      const onClick = (e: MouseEvent) => {\n        e.stopPropagation();\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        reset();\n        onConnect(connectLineState, getConnectTo(e));\n      };\n      const reset = () => {\n        document.removeEventListener(\"mousemove\", onMouseMove);\n        document.removeEventListener(\"mousedown\", onMouseDown, {\n          capture: true,\n        });\n        document.removeEventListener(\"click\", onClick, { capture: true });\n        setConnectLineTo(null);\n      };\n      document.addEventListener(\"mousemove\", onMouseMove);\n      document.addEventListener(\"mousedown\", onMouseDown, { capture: true });\n      document.addEventListener(\"click\", onClick, { capture: true });\n\n      return reset;\n    }\n  }, [connectLineState, onConnect, transform]);\n\n  return (\n    <path\n      className={classNames(\"connect-line\", {\n        connecting:\n          !!connectLineState &&\n          connectLineTo &&\n          // Do not show when the distance of mouse move is less than 5px\n          (connectLineTo[0] - connectLineState.from[0]) ** 2 +\n            (connectLineTo[1] - connectLineState.from[1]) ** 2 >\n            25,\n      })}\n      d={\n        connectLineState && connectLineTo\n          ? `M${connectLineState.from.join(\" \")}L${connectLineTo.join(\" \")}`\n          : \"\"\n      }\n      fill=\"none\"\n      stroke=\"gray\"\n      strokeWidth={1}\n      markerEnd={`url(#${markerEnd})`}\n    />\n  );\n}\n","import { pick } from \"lodash\";\nimport type { NodePosition, PositionTuple } from \"../../../diagram/interfaces\";\nimport type { HoverState } from \"../../../draw-canvas/HoverStateContext\";\nimport type {\n  LineEditorState,\n  LineEditorStateOfControl,\n} from \"../../../draw-canvas/interfaces\";\nimport { getSmartLinePoints, simplifyVertices } from \"./getSmartLinePoints\";\n\nexport function getEditingLinePoints(\n  lineEditorState: LineEditorState | null,\n  connectLineTo: PositionTuple | null,\n  hoverState: HoverState | null\n): NodePosition[] | null {\n  if (\n    !lineEditorState ||\n    !(\n      connectLineTo ||\n      (lineEditorState.type !== \"control\" &&\n        hoverState?.activePointIndex !== undefined)\n    )\n  ) {\n    return null;\n  }\n\n  const {\n    type,\n    source,\n    target,\n    edge: { view },\n  } = lineEditorState;\n  const { exitPosition, entryPosition, vertices } = view ?? {};\n\n  const lineSettings = pick(view, [\"type\", \"curveType\"]);\n\n  if (type === \"control\") {\n    const newVertices = getNewLineVertices(lineEditorState, connectLineTo!);\n\n    return getSmartLinePoints(source.view, target.view, {\n      ...lineSettings,\n      exitPosition,\n      entryPosition,\n      vertices: newVertices,\n    });\n  }\n\n  if (hoverState?.activePointIndex !== undefined) {\n    const position = hoverState.relativePoints[hoverState.activePointIndex];\n    // Assert `hoverState.cell` is `target`\n    return getSmartLinePoints(source.view, target.view, {\n      ...lineSettings,\n      ...(type === \"entry\"\n        ? {\n            exitPosition,\n            entryPosition: position,\n          }\n        : {\n            exitPosition: position,\n            entryPosition,\n          }),\n      vertices,\n    });\n  }\n\n  const [x1, y1] = connectLineTo!;\n\n  if (type === \"entry\") {\n    return getSmartLinePoints(\n      source.view,\n      { x: x1, y: y1, width: 0, height: 0 },\n      { ...lineSettings, exitPosition, vertices }\n    );\n  }\n\n  return getSmartLinePoints(\n    { x: x1, y: y1, width: 0, height: 0 },\n    target.view,\n    { ...lineSettings, entryPosition, vertices }\n  );\n}\n\nexport function getNewLineVertices(\n  lineEditorState: LineEditorStateOfControl,\n  connectLineTo: PositionTuple\n) {\n  const { control, linePoints } = lineEditorState;\n  const newVertices: NodePosition[] = [];\n  const [x1, y1] = connectLineTo!;\n  const exitPoint = linePoints[0];\n  const entryPoint = linePoints[linePoints.length - 1];\n\n  // If moving the first control, prepend a vertex to connect the control to the source\n  if (control.index === 0) {\n    newVertices.push(\n      control.direction === \"ns\"\n        ? { x: exitPoint.x, y: y1 }\n        : { x: x1, y: exitPoint.y }\n    );\n  }\n\n  // Adjust the related two controls, and leave other controls unchanged\n  for (let i = 1; i < linePoints.length - 1; i++) {\n    const vertex = linePoints[i];\n    newVertices.push(\n      i === control.index || i === control.index + 1\n        ? control.direction === \"ns\"\n          ? { x: vertex.x, y: y1 }\n          : { x: x1, y: vertex.y }\n        : vertex\n    );\n  }\n\n  // If moving the last control, append a vertex to connect the control to the target\n  if (control.index === linePoints.length - 2) {\n    newVertices.push(\n      control.direction === \"ns\"\n        ? { x: entryPoint.x, y: y1 }\n        : { x: x1, y: entryPoint.y }\n    );\n  }\n\n  return simplifyVertices(exitPoint, newVertices, entryPoint);\n}\n","// istanbul ignore file: experimental\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport classNames from \"classnames\";\nimport type { ComputedLineConnecterConf } from \"./interfaces\";\nimport type {\n  LineMarkerConf,\n  NodePosition,\n  PositionTuple,\n  TransformLiteral,\n} from \"../diagram/interfaces\";\nimport { curveLine } from \"../diagram/lines/curveLine\";\nimport { useHoverStateContext } from \"./HoverStateContext\";\nimport {\n  getEditingLinePoints,\n  getNewLineVertices,\n} from \"../shared/canvas/processors/getEditingLinePoints\";\nimport { getMarkers } from \"../shared/canvas/useLineMarkers\";\n\nexport interface EditingLineComponentProps {\n  transform: TransformLiteral;\n  options: ComputedLineConnecterConf;\n}\n\nexport function EditingLineComponent({\n  transform,\n  options,\n}: EditingLineComponentProps): JSX.Element {\n  const [connectLineTo, setConnectLineTo] = useState<PositionTuple | null>(\n    null\n  );\n  const {\n    activeEditableLine,\n    hoverState,\n    lineEditorState,\n    setLineEditorState,\n    onChangeEdgeView,\n  } = useHoverStateContext();\n  const movedRef = useRef(false);\n\n  useEffect(() => {\n    if (!lineEditorState) {\n      setTimeout(() => {\n        movedRef.current = false;\n      }, 0);\n    }\n  }, [lineEditorState]);\n\n  useEffect(() => {\n    if (!lineEditorState) {\n      return;\n    }\n    movedRef.current = false;\n    const { type, offset, from } = lineEditorState;\n    // Set connect line to based on the mouse position and the transform\n    const getConnectTo = (e: MouseEvent): PositionTuple => {\n      const position: NodePosition = {\n        x: (e.clientX - transform.x - offset[0]) / transform.k,\n        y: (e.clientY - transform.y - offset[1]) / transform.k,\n      };\n      let diff = Infinity;\n      if (type === \"control\" && !e.altKey) {\n        // Snap to other points\n        const { linePoints, control } = lineEditorState;\n        const axis = control.direction === \"ns\" ? \"y\" : \"x\";\n        const original = control[axis];\n        const otherPoints = linePoints.filter(\n          (_, i) =>\n            i === 0 ||\n            i === linePoints.length - 1 ||\n            (i !== control.index && i !== control.index + 1)\n        );\n        const snapDistance = 5;\n        for (const point of otherPoints) {\n          const newDiff = Math.abs(point[axis] - position[axis]);\n          if (newDiff <= snapDistance && newDiff < diff) {\n            position[axis] = point[axis];\n            diff = newDiff;\n            if (!movedRef.current && original !== position[axis]) {\n              movedRef.current = true;\n            }\n          }\n        }\n      }\n      if (diff === Infinity && !movedRef.current) {\n        const movementX = (e.clientX - from[0]) / transform.k;\n        const movementY = (e.clientY - from[1]) / transform.k;\n        movedRef.current = movementX ** 2 + movementY ** 2 >= 9;\n      }\n      return [position.x, position.y];\n    };\n    const onMouseMove = (e: MouseEvent) => {\n      const newConnectTo = getConnectTo(e);\n      if (movedRef.current) {\n        setConnectLineTo(newConnectTo);\n      }\n    };\n    function onMouseUp(e: MouseEvent) {\n      e.preventDefault();\n      reset();\n      if (lineEditorState?.type === \"control\") {\n        const newConnectTo = getConnectTo(e);\n        if (movedRef.current) {\n          const {\n            source,\n            target,\n            edge: { view },\n          } = lineEditorState;\n          onChangeEdgeView?.(source, target, {\n            ...view,\n            vertices: getNewLineVertices(lineEditorState, newConnectTo),\n          });\n        }\n      }\n    }\n    function reset() {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", onMouseUp);\n      setConnectLineTo(null);\n      setLineEditorState(null);\n    }\n    document.addEventListener(\"mousemove\", onMouseMove);\n    document.addEventListener(\"mouseup\", onMouseUp);\n\n    return reset;\n  }, [lineEditorState, transform, setLineEditorState, onChangeEdgeView]);\n\n  useEffect(() => {\n    if (!activeEditableLine) {\n      return;\n    }\n    const handleBodyClick = (e: MouseEvent) => {\n      if (movedRef.current) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    };\n    document.body.addEventListener(\"click\", handleBodyClick);\n    return () => {\n      document.body.removeEventListener(\"click\", handleBodyClick);\n    };\n  }, [activeEditableLine]);\n\n  const line = useMemo(() => {\n    const points = getEditingLinePoints(\n      lineEditorState,\n      connectLineTo,\n      hoverState\n    );\n    return curveLine(\n      points,\n      lineEditorState?.edge.view?.type === \"curve\"\n        ? lineEditorState.edge.view.curveType\n        : \"curveLinear\",\n      0,\n      1\n    );\n  }, [connectLineTo, hoverState, lineEditorState]);\n  let markerStart: string | undefined;\n  let markerEnd: string | undefined;\n  const lineMarkers: LineMarkerConf[] = getMarkers(options);\n  for (const marker of lineMarkers) {\n    if (marker.placement === \"start\") {\n      markerStart = options.$editingStartMarkerUrl;\n    } else {\n      markerEnd = options.$editingEndMarkerUrl;\n    }\n  }\n\n  return (\n    <path\n      className={classNames(\"editing-line\", {\n        editing: !!(lineEditorState && connectLineTo),\n      })}\n      d={line}\n      fill=\"none\"\n      stroke={options.editingStrokeColor}\n      markerStart={markerStart}\n      markerEnd={markerEnd}\n    />\n  );\n}\n","// istanbul ignore file: nothing logical to test\nimport React from \"react\";\nimport type {\n  DecoratorCell,\n  EdgeView,\n  EditableLineInfo,\n  LineEditorState,\n  NodeCell,\n  SmartConnectLineState,\n} from \"./interfaces\";\nimport type { NodePosition } from \"../diagram/interfaces\";\n\nexport interface HoverState {\n  // Currently only support node cell\n  cell: NodeCell | DecoratorCell;\n  relativePoints: ReadonlyArray<NodePosition>;\n  points: ReadonlyArray<NodePosition>;\n  activePointIndex?: number;\n}\n\nexport const HoverStateContext = React.createContext<{\n  rootRef: React.RefObject<SVGSVGElement>;\n  smartConnectLineState: SmartConnectLineState | null;\n  unsetHoverStateTimeoutRef: React.MutableRefObject<number | null>;\n  hoverState: HoverState | null;\n  activeEditableLine: EditableLineInfo | null;\n  lineEditorState: LineEditorState | null;\n  setLineEditorState: React.Dispatch<\n    React.SetStateAction<LineEditorState | null>\n  >;\n  setActiveEditableLine: React.Dispatch<\n    React.SetStateAction<EditableLineInfo | null>\n  >;\n  setHoverState: React.Dispatch<React.SetStateAction<HoverState | null>>;\n  setSmartConnectLineState: React.Dispatch<\n    React.SetStateAction<SmartConnectLineState | null>\n  >;\n  onConnect?: (\n    source: NodeCell | DecoratorCell,\n    target: NodeCell | DecoratorCell,\n    exitPosition: NodePosition,\n    entryPosition: NodePosition | undefined\n  ) => void;\n  onChangeEdgeView?: (\n    source: NodeCell | DecoratorCell,\n    target: NodeCell | DecoratorCell,\n    view: EdgeView\n  ) => void;\n}>({\n  rootRef: { current: null },\n  smartConnectLineState: null,\n  unsetHoverStateTimeoutRef: { current: null },\n  hoverState: null,\n  activeEditableLine: null,\n  lineEditorState: null,\n  setLineEditorState: () => {},\n  setActiveEditableLine: () => {},\n  setHoverState: () => {},\n  setSmartConnectLineState: () => {},\n});\n\nexport function useHoverStateContext() {\n  return React.useContext(HoverStateContext);\n}\n","// istanbul ignore file: experimental\nimport React, { useCallback, useEffect, useRef } from \"react\";\nimport { useHoverStateContext } from \"./HoverStateContext\";\nimport type { ActiveTarget, NodeCell } from \"./interfaces\";\nimport { targetIsActive } from \"./processors/targetIsActive\";\nimport type { NodePosition } from \"../diagram/interfaces\";\nimport { DEFAULT_NODE_PADDING_FOR_SMART_LINES } from \"./constants\";\n\nconst HELPER_IMAGE =\n  \"data:image/svg+xml;base64,PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSI1cHgiIGhlaWdodD0iNXB4IiB2ZXJzaW9uPSIxLjEiPjxwYXRoIGQ9Im0gMCAwIEwgNSA1IE0gMCA1IEwgNSAwIiBzdHJva2Utd2lkdGg9IjIiIHN0eWxlPSJzdHJva2Utb3BhY2l0eTowLjQiIHN0cm9rZT0iI2ZmZmZmZiIvPjxwYXRoIGQ9Im0gMCAwIEwgNSA1IE0gMCA1IEwgNSAwIiBzdHJva2U9IiMyOWI2ZjIiLz48L3N2Zz4=\";\nconst HELPER_RADIUS = 5;\nconst HELPER_BG_RADIUS = 8;\nconst HALF_HELPER_RADIUS = HELPER_RADIUS / 2;\n\nexport interface LineConnectorComponentProps {\n  activeTarget: ActiveTarget | null;\n  scale: number;\n  disabled?: boolean;\n}\n\nexport function LineConnectorComponent({\n  activeTarget,\n  scale,\n  disabled,\n}: LineConnectorComponentProps): JSX.Element | null {\n  const {\n    unsetHoverStateTimeoutRef,\n    hoverState,\n    setHoverState,\n    smartConnectLineState,\n    lineEditorState,\n  } = useHoverStateContext();\n\n  const unsetTimeout = useCallback(() => {\n    if (unsetHoverStateTimeoutRef.current !== null) {\n      clearTimeout(unsetHoverStateTimeoutRef.current);\n      unsetHoverStateTimeoutRef.current = null;\n    }\n  }, [unsetHoverStateTimeoutRef]);\n\n  const unsetActivePointIndex = useCallback(() => {\n    unsetTimeout();\n    setHoverState((prev) =>\n      prev?.activePointIndex === undefined\n        ? prev\n        : { ...hoverState!, activePointIndex: undefined }\n    );\n  }, [hoverState, setHoverState, unsetTimeout]);\n\n  const unsetHoverState = useCallback(() => {\n    unsetHoverStateTimeoutRef.current = setTimeout(() => {\n      setHoverState(null);\n    }) as unknown as number;\n  }, [setHoverState, unsetHoverStateTimeoutRef]);\n\n  const available =\n    !disabled &&\n    hoverState &&\n    (!!smartConnectLineState ||\n      (lineEditorState\n        ? lineEditorState.type === \"entry\"\n          ? hoverState.cell === lineEditorState.target\n          : lineEditorState.type === \"exit\" &&\n            hoverState.cell === lineEditorState.source\n        : !targetIsActive(hoverState.cell, activeTarget) &&\n          !hasActiveEdge(activeTarget)));\n\n  const padding = DEFAULT_NODE_PADDING_FOR_SMART_LINES;\n  const halfPadding = padding / 2;\n\n  return (\n    <g onMouseEnter={unsetActivePointIndex} onMouseLeave={unsetHoverState}>\n      {available && (\n        <>\n          <rect\n            x={hoverState.cell.view.x - halfPadding}\n            y={hoverState.cell.view.y - halfPadding}\n            width={hoverState.cell.view.width + padding}\n            height={hoverState.cell.view.height + padding}\n            fill=\"none\"\n            stroke=\"transparent\"\n            strokeWidth={(HELPER_BG_RADIUS * 2) / scale}\n            pointerEvents=\"stroke\"\n          />\n          {hoverState.activePointIndex !== undefined && (\n            <circle\n              cx={hoverState.points[hoverState.activePointIndex].x}\n              cy={hoverState.points[hoverState.activePointIndex].y}\n              r={HELPER_BG_RADIUS / scale}\n              fill=\"lightgreen\"\n              fillOpacity={0.5}\n              pointerEvents=\"none\"\n            />\n          )}\n          {hoverState.points.map((point, index) => (\n            <ConnectPointComponent\n              key={index}\n              index={index}\n              point={point}\n              scale={scale}\n              unsetActivePointIndex={unsetActivePointIndex}\n              unsetTimeout={unsetTimeout}\n            />\n          ))}\n        </>\n      )}\n    </g>\n  );\n}\n\ninterface ConnectPointComponentProps {\n  index: number;\n  point: NodePosition;\n  scale: number;\n  unsetTimeout: () => void;\n  unsetActivePointIndex: () => void;\n}\n\nfunction ConnectPointComponent({\n  index,\n  point,\n  scale,\n  unsetTimeout,\n  unsetActivePointIndex,\n}: ConnectPointComponentProps): JSX.Element {\n  const {\n    rootRef,\n    smartConnectLineState,\n    hoverState,\n    setHoverState,\n    setSmartConnectLineState,\n    onConnect,\n    lineEditorState,\n    setLineEditorState,\n    onChangeEdgeView,\n  } = useHoverStateContext();\n  const ref = useRef<SVGGElement>(null);\n\n  useEffect(() => {\n    const g = ref.current;\n    const handleMouseEnter = (e: MouseEvent) => {\n      // There is a chance that mouseenter will not be triggered when the element is shown aync.\n      // So we also listen to the mousemove event, but only once.\n      if (e.type === \"mousemove\") {\n        g?.removeEventListener(e.type, handleMouseEnter);\n      }\n      unsetTimeout();\n      setHoverState((prev) =>\n        prev && prev.activePointIndex !== index\n          ? { ...hoverState!, activePointIndex: index }\n          : prev\n      );\n    };\n    g?.addEventListener(\"mouseenter\", handleMouseEnter);\n    g?.addEventListener(\"mousemove\", handleMouseEnter);\n    return () => {\n      g?.removeEventListener(\"mouseenter\", handleMouseEnter);\n      g?.removeEventListener(\"mousemove\", handleMouseEnter);\n    };\n  }, [hoverState, index, setHoverState, unsetTimeout]);\n\n  useEffect(() => {\n    if (lineEditorState) {\n      return;\n    }\n    const handleMouseDown = (e: MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      const rect = rootRef.current!.getBoundingClientRect();\n      const originalPoint = hoverState!.points[index];\n      setSmartConnectLineState({\n        source: hoverState!.cell as NodeCell,\n        from: [originalPoint.x, originalPoint.y],\n        offset: [rect.left, rect.top],\n        exitPosition: hoverState!.relativePoints[index],\n      });\n    };\n    const g = ref.current;\n    g?.addEventListener(\"mousedown\", handleMouseDown);\n    return () => {\n      g?.removeEventListener(\"mousedown\", handleMouseDown);\n    };\n  }, [hoverState, index, lineEditorState, rootRef, setSmartConnectLineState]);\n\n  useEffect(() => {\n    const handleMouseUp = (e: MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      if (smartConnectLineState) {\n        if (smartConnectLineState.source !== hoverState?.cell) {\n          onConnect?.(\n            smartConnectLineState.source,\n            hoverState!.cell,\n            smartConnectLineState.exitPosition,\n            hoverState!.relativePoints[hoverState!.activePointIndex!]\n          );\n        }\n        setSmartConnectLineState(null);\n      } else if (lineEditorState) {\n        const position =\n          hoverState!.relativePoints[hoverState!.activePointIndex!];\n        const {\n          type,\n          source,\n          target,\n          edge: { view },\n        } = lineEditorState;\n        if (type === \"entry\") {\n          onChangeEdgeView?.(source, target, {\n            ...view,\n            entryPosition: position,\n          });\n        } else {\n          onChangeEdgeView?.(source, target, {\n            ...view,\n            exitPosition: position,\n          });\n        }\n        setLineEditorState(null);\n      }\n    };\n    const g = ref.current;\n    g?.addEventListener(\"mouseup\", handleMouseUp);\n    return () => {\n      g?.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [\n    smartConnectLineState,\n    hoverState,\n    onConnect,\n    setSmartConnectLineState,\n    lineEditorState,\n    onChangeEdgeView,\n    setLineEditorState,\n  ]);\n\n  return (\n    <g ref={ref} onMouseLeave={unsetActivePointIndex}>\n      <circle\n        cx={point.x}\n        cy={point.y}\n        r={HELPER_BG_RADIUS}\n        fill=\"transparent\"\n      />\n      <image\n        x={point.x - HALF_HELPER_RADIUS / scale}\n        y={point.y - HALF_HELPER_RADIUS / scale}\n        width={HELPER_RADIUS / scale}\n        height={HELPER_RADIUS / scale}\n        xlinkHref={HELPER_IMAGE}\n        preserveAspectRatio=\"none\"\n      />\n    </g>\n  );\n}\n\nfunction hasActiveEdge(activeTarget: ActiveTarget | null) {\n  return (\n    activeTarget &&\n    (activeTarget.type === \"edge\" ||\n      (activeTarget.type === \"multi\" &&\n        activeTarget.targets.some((target) => target.type === \"edge\")))\n  );\n}\n","// istanbul ignore file: experimental\nimport React, { useEffect, useMemo, useRef } from \"react\";\nimport type { NodePosition } from \"../diagram/interfaces\";\nimport { useHoverStateContext } from \"./HoverStateContext\";\nimport type { ControlPoint } from \"./interfaces\";\nimport { isStraightType } from \"./processors/asserts\";\n\nconst POINT_HELPER_IMAGE =\n  \"data:image/svg+xml;base64,PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMnB4IiBoZWlnaHQ9IjIycHgiIHZlcnNpb249IjEuMSI+PGNpcmNsZSBjeD0iMTEiIGN5PSIxMSIgcj0iNyIgc3Ryb2tlPSIjZmZmIiBmaWxsPSIjMjliNmYyIi8+PGNpcmNsZSBjeD0iMTEiIGN5PSIxMSIgcj0iMyIgc3Ryb2tlPSIjZmZmIiBmaWxsPSJ0cmFuc3BhcmVudCIvPjwvc3ZnPg==\";\nconst ANCHORED_POINT_HELPER_IMAGE =\n  \"data:image/svg+xml;base64,PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMnB4IiBoZWlnaHQ9IjIycHgiIHZlcnNpb249IjEuMSI+PGNpcmNsZSBjeD0iMTEiIGN5PSIxMSIgcj0iNyIgc3Ryb2tlPSIjZmZmIiBmaWxsPSIjMDFiZDIyIi8+PHBhdGggZD0ibSA4IDggTCAxNCAxNE0gOCAxNCBMIDE0IDgiIHN0cm9rZT0iI2ZmZiIvPjwvc3ZnPg==\";\nconst VERTEX_HELPER_IMAGE =\n  \"data:image/svg+xml;base64,PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj48c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxOHB4IiBoZWlnaHQ9IjE4cHgiIHZlcnNpb249IjEuMSI+PGNpcmNsZSBjeD0iOSIgY3k9IjkiIHI9IjUiIHN0cm9rZT0iI2ZmZiIgZmlsbD0iIzI5YjZmMiIvPjwvc3ZnPg==\";\nconst POINT_HELPER_BG_SIZE = 22;\n\nexport interface LineEditorComponentProps {\n  scale: number;\n}\n\nexport function LineEditorComponent({\n  scale,\n}: LineEditorComponentProps): JSX.Element | null {\n  const { rootRef, activeEditableLine, setLineEditorState } =\n    useHoverStateContext();\n  const exitRef = useRef<SVGImageElement>(null);\n  const entryRef = useRef<SVGImageElement>(null);\n  const controlPointsRef = useRef<(SVGImageElement | null)[]>([]);\n\n  useEffect(() => {\n    const exit = exitRef.current;\n    const entry = entryRef.current;\n    if (!exit || !entry || !activeEditableLine) {\n      return;\n    }\n    const handleMouseDownFactory = (type: \"exit\" | \"entry\") => {\n      return (e: MouseEvent) => {\n        e.stopPropagation();\n        e.preventDefault();\n        const rect = rootRef.current!.getBoundingClientRect();\n        setLineEditorState({\n          ...activeEditableLine,\n          offset: [rect.left, rect.top],\n          from: [e.clientX, e.clientY],\n          type,\n        });\n      };\n    };\n    const handleStartMouseDown = handleMouseDownFactory(\"exit\");\n    const handleEndMouseDown = handleMouseDownFactory(\"entry\");\n    exit.addEventListener(\"mousedown\", handleStartMouseDown);\n    entry.addEventListener(\"mousedown\", handleEndMouseDown);\n    return () => {\n      exit.removeEventListener(\"mousedown\", handleStartMouseDown);\n      entry.removeEventListener(\"mousedown\", handleEndMouseDown);\n    };\n  }, [activeEditableLine, rootRef, setLineEditorState]);\n\n  const controlPoints = useMemo(() => {\n    return activeEditableLine &&\n      !isStraightType(activeEditableLine.edge.view?.type)\n      ? getControlPoints(activeEditableLine!.linePoints)\n      : [];\n  }, [activeEditableLine]);\n\n  useEffect(() => {\n    if (!activeEditableLine) {\n      return;\n    }\n    const controlElements = controlPointsRef.current;\n    const handleMouseDownFactory = (control: ControlPoint) => {\n      return (e: MouseEvent) => {\n        e.stopPropagation();\n        e.preventDefault();\n        const rect = rootRef.current!.getBoundingClientRect();\n        setLineEditorState({\n          ...activeEditableLine!,\n          offset: [rect.left, rect.top],\n          from: [e.clientX, e.clientY],\n          type: \"control\",\n          control,\n        });\n      };\n    };\n    const handlers = controlPoints.map((control) =>\n      handleMouseDownFactory(control)\n    );\n    controlElements.forEach((el, i) => {\n      el?.addEventListener(\"mousedown\", handlers[i]);\n    });\n    return () => {\n      controlElements.forEach((el, i) => {\n        el?.removeEventListener(\"mousedown\", handlers[i]);\n      });\n    };\n  }, [activeEditableLine, controlPoints, rootRef, setLineEditorState]);\n\n  const gRef = useRef<SVGGElement>(null);\n  useEffect(() => {\n    const g = gRef.current;\n    const onClick = (e: MouseEvent) => {\n      e.stopPropagation();\n      e.preventDefault();\n    };\n    g?.addEventListener(\"click\", onClick);\n    return () => {\n      g?.removeEventListener(\"click\", onClick);\n    };\n  }, []);\n\n  if (!activeEditableLine) {\n    return null;\n  }\n  const {\n    linePoints,\n    edge: { view },\n  } = activeEditableLine;\n  const { exitPosition, entryPosition } = view ?? {};\n\n  const commonProps: React.SVGAttributes<SVGImageElement> = {\n    width: POINT_HELPER_BG_SIZE / scale,\n    height: POINT_HELPER_BG_SIZE / scale,\n    preserveAspectRatio: \"none\",\n    cursor: \"pointer\",\n    pointerEvents: \"fill\",\n  };\n  const exitPoint = linePoints[0];\n  const entryPoint = linePoints[linePoints.length - 1];\n  const offset = POINT_HELPER_BG_SIZE / scale / 2;\n\n  return (\n    <g ref={gRef}>\n      <image\n        ref={exitRef}\n        {...commonProps}\n        x={exitPoint.x - offset}\n        y={exitPoint.y - offset}\n        xlinkHref={\n          exitPosition ? ANCHORED_POINT_HELPER_IMAGE : POINT_HELPER_IMAGE\n        }\n      />\n      {controlPoints.map((point, i) => (\n        <image\n          key={i}\n          ref={(el) => {\n            controlPointsRef.current[i] = el;\n          }}\n          {...commonProps}\n          x={point.x - offset}\n          y={point.y - offset}\n          xlinkHref={VERTEX_HELPER_IMAGE}\n          cursor={point.direction === \"ns\" ? \"row-resize\" : \"col-resize\"}\n        />\n      ))}\n      <image\n        ref={entryRef}\n        {...commonProps}\n        x={entryPoint.x - offset}\n        y={entryPoint.y - offset}\n        xlinkHref={\n          entryPosition ? ANCHORED_POINT_HELPER_IMAGE : POINT_HELPER_IMAGE\n        }\n      />\n    </g>\n  );\n}\n\nfunction getControlPoints(linePoints: NodePosition[]): ControlPoint[] {\n  const controlPoints: ControlPoint[] = [];\n  let prev = linePoints[0];\n  let cursor = 1;\n  while (cursor < linePoints.length) {\n    const next = linePoints[cursor];\n    const ns = prev.y === next.y;\n    const ew = prev.x === next.x;\n    if (!(ns && ew)) {\n      const direction = ns ? \"ns\" : \"ew\";\n      controlPoints.push({\n        direction,\n        index: cursor - 1,\n        x: (prev.x + next.x) / 2,\n        y: (prev.y + next.y) / 2,\n      });\n    }\n    prev = next;\n    cursor++;\n  }\n\n  return controlPoints;\n}\n","// istanbul ignore file: experimental\nimport React, { useEffect, useMemo, useState } from \"react\";\nimport classNames from \"classnames\";\nimport type { ComputedLineConnecterConf, LineSettings } from \"./interfaces\";\nimport type {\n  LineMarkerConf,\n  PositionTuple,\n  TransformLiteral,\n} from \"../diagram/interfaces\";\nimport { curveLine } from \"../diagram/lines/curveLine\";\nimport { useHoverStateContext } from \"./HoverStateContext\";\nimport { getConnectLinePoints } from \"../shared/canvas/processors/getConnectLinePoints\";\nimport { getMarkers } from \"../shared/canvas/useLineMarkers\";\n\nexport interface SmartConnectLineComponentProps {\n  transform: TransformLiteral;\n  lineSettings?: LineSettings;\n  options: ComputedLineConnecterConf;\n}\n\nexport function SmartConnectLineComponent({\n  transform,\n  lineSettings,\n  options,\n}: SmartConnectLineComponentProps): JSX.Element {\n  const [connectLineTo, setConnectLineTo] = useState<PositionTuple | null>(\n    null\n  );\n  const { hoverState, smartConnectLineState, setSmartConnectLineState } =\n    useHoverStateContext();\n\n  useEffect(() => {\n    if (!smartConnectLineState) {\n      return;\n    }\n    function onMouseMove(e: MouseEvent) {\n      // Set connect line to based on the mouse position and the transform\n      setConnectLineTo([\n        (e.clientX - transform.x - smartConnectLineState!.offset[0]) /\n          transform.k,\n        (e.clientY - transform.y - smartConnectLineState!.offset[1]) /\n          transform.k,\n      ]);\n    }\n    function onMouseUp(e: MouseEvent) {\n      e.preventDefault();\n      reset();\n    }\n    function reset() {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", onMouseUp);\n      setConnectLineTo(null);\n      setSmartConnectLineState(null);\n    }\n    document.addEventListener(\"mousemove\", onMouseMove);\n    document.addEventListener(\"mouseup\", onMouseUp);\n\n    return reset;\n  }, [setSmartConnectLineState, smartConnectLineState, transform]);\n\n  const line = useMemo(() => {\n    const points = getConnectLinePoints(\n      smartConnectLineState,\n      connectLineTo,\n      hoverState,\n      lineSettings\n    );\n    return curveLine(\n      points,\n      options.type === \"curve\" ? options.curveType : \"curveLinear\",\n      0,\n      1\n    );\n  }, [connectLineTo, hoverState, smartConnectLineState, options, lineSettings]);\n\n  let markerStart: string | undefined;\n  let markerEnd: string | undefined;\n  const lineMarkers: LineMarkerConf[] = getMarkers(options);\n  for (const marker of lineMarkers) {\n    if (marker.placement === \"start\") {\n      markerStart = options.$markerStartUrl;\n    } else {\n      markerEnd = options.$markerEndUrl;\n    }\n  }\n\n  return (\n    <path\n      className={classNames(\"connect-line\", {\n        connecting: !!(smartConnectLineState && connectLineTo),\n      })}\n      d={line}\n      fill=\"none\"\n      stroke={options.strokeColor}\n      strokeWidth={options.strokeWidth}\n      markerStart={markerStart}\n      markerEnd={markerEnd}\n    />\n  );\n}\n","import type { NodePosition, PositionTuple } from \"../../../diagram/interfaces\";\nimport type { HoverState } from \"../../../draw-canvas/HoverStateContext\";\nimport type {\n  LineSettings,\n  SmartConnectLineState,\n} from \"../../../draw-canvas/interfaces\";\nimport { getSmartLinePoints } from \"./getSmartLinePoints\";\n\nexport function getConnectLinePoints(\n  smartConnectLineState: SmartConnectLineState | null,\n  connectLineTo: PositionTuple | null,\n  hoverState: HoverState | null,\n  lineSettings?: LineSettings\n): NodePosition[] | null {\n  if (\n    !smartConnectLineState ||\n    !(connectLineTo || hoverState?.activePointIndex !== undefined)\n  ) {\n    return null;\n  }\n\n  const sourceView = smartConnectLineState.source.view;\n  if (hoverState?.activePointIndex !== undefined) {\n    return getSmartLinePoints(sourceView, hoverState.cell.view, {\n      ...lineSettings,\n      exitPosition: smartConnectLineState.exitPosition,\n      entryPosition: hoverState.relativePoints[hoverState.activePointIndex],\n    });\n  }\n\n  const [x1, y1] = connectLineTo!;\n\n  return getSmartLinePoints(\n    sourceView,\n    { x: x1, y: y1, width: 0, height: 0 },\n    {\n      ...lineSettings,\n      exitPosition: smartConnectLineState.exitPosition,\n    }\n  );\n}\n","export const SYMBOL_FOR_SIZE_INITIALIZED = Symbol.for(\"size-initialized\");\nexport const SYMBOL_FOR_LAYOUT_INITIALIZED = Symbol.for(\"layout-initialized\");\nexport const DEFAULT_NODE_SIZE = 20;\nexport const DEFAULT_NODE_GAP = 36;\nexport const DEFAULT_AREA_WIDTH = 180;\nexport const DEFAULT_AREA_HEIGHT = 120;\nexport const DEFAULT_SCALE_RANGE_MIN = 0.5;\nexport const DEFAULT_SCALE_RANGE_MAX = 2;\nexport const DEFAULT_LINE_STROKE_COLOR = \"gray\";\nexport const DEFAULT_LINE_STROKE_WIDTH = 1;\nexport const DEFAULT_LINE_INTERACT_STROKE_WIDTH = 15;\nexport const DEFAULT_LINE_INTERACT_SHOW_START_ARROW = false;\nexport const DEFAULT_LINE_INTERACT_SHOW_END_ARROW = true;\nexport const DEFAULT_LINE_INTERACT_ANIMATE_DURATION = 1;\nexport const DEFAULT_DEGRADED_THRESHOLD = 500;\nexport const DEFAULT_SNAP_GRID_SIZE = 10;\nexport const DEFAULT_SNAP_OBJECT_DISTANCE = 5;\n/** Padding left + padding right, as well as top + bottom */\nexport const DEFAULT_NODE_PADDING_FOR_LINES = 5;\n/** Padding left + padding right, as well as top + bottom */\nexport const DEFAULT_NODE_PADDING_FOR_SMART_LINES = 0;\n\nexport const POINT_HELPER_RADIUS = 5;\n","import type {\n  Cell,\n  DecoratorCell,\n  EdgeCell,\n  InitialCell,\n  InitialNodeCell,\n  LayoutType,\n  LineType,\n  NodeCell,\n} from \"../interfaces\";\nimport { MoveCellPayload } from \"../reducers/interfaces\";\n\nexport function isNodeCell(cell: Cell | MoveCellPayload): cell is NodeCell {\n  return cell.type === \"node\";\n}\n\nexport function isDecoratorCell(cell: Cell): cell is DecoratorCell {\n  return cell.type === \"decorator\";\n}\n\nexport function isInitialNodeCell(cell: InitialCell): cell is InitialNodeCell {\n  return cell.type === \"node\";\n}\n\nexport function isEdgeCell(cell: Cell): cell is EdgeCell {\n  return cell.type === \"edge\";\n}\n\nexport function isNodeOrEdgeCell(cell: Cell): cell is NodeCell | EdgeCell {\n  return cell.type === \"node\" || cell.type === \"edge\";\n}\n\nexport function isNodeOrAreaDecoratorCell(\n  cell: Cell\n): cell is NodeCell | DecoratorCell {\n  return (\n    cell.type === \"node\" ||\n    (cell.type === \"decorator\" && cell.decorator === \"area\")\n  );\n}\n\nexport function isEdgeSide(\n  cell: Cell,\n  allowEdgeToArea: boolean | undefined\n): cell is NodeCell | DecoratorCell {\n  return (\n    cell.type === \"node\" ||\n    (!!allowEdgeToArea &&\n      cell.type === \"decorator\" &&\n      cell.decorator === \"area\")\n  );\n}\n\nexport function isNodeOrTextDecoratorCell(\n  cell: Cell | MoveCellPayload\n): cell is NodeCell | DecoratorCell {\n  return (\n    cell.type === \"node\" ||\n    (cell.type === \"decorator\" && cell.decorator === \"text\")\n  );\n}\n\nexport function isTextDecoratorCell(cell: Cell): cell is DecoratorCell {\n  return cell.type === \"decorator\" && cell.decorator === \"text\";\n}\nexport function isContainerDecoratorCell(\n  cell: Cell | MoveCellPayload\n): cell is DecoratorCell {\n  return cell.type === \"decorator\" && cell.decorator === \"container\";\n}\n\nexport function isNoManualLayout(layout: LayoutType) {\n  return ![\"manual\", undefined].includes(layout!);\n}\n\nexport function isStraightType(type: LineType | undefined) {\n  return !(type === \"polyline\" || type === \"curve\");\n}\n","import { pick } from \"lodash\";\nimport type { ActiveTargetOfSingular, Cell } from \"../interfaces\";\n\nexport function cellToTarget(cell: Cell): ActiveTargetOfSingular {\n  return cell.type === \"edge\"\n    ? pick(cell, [\"type\", \"source\", \"target\", \"data\"])\n    : pick(cell, [\"type\", \"id\", \"data\"]);\n}\n","import type { ActiveTarget, Cell, ConnectLineState } from \"../interfaces\";\nimport { targetIsActive } from \"./targetIsActive\";\n\nexport function getUnrelatedCells(\n  cells: Cell[],\n  connectLineState: ConnectLineState | null,\n  activeTarget: ActiveTarget | null,\n  allowEdgeToArea?: boolean\n): Cell[] {\n  const unrelated: Cell[] = [];\n  if (connectLineState) {\n    const existedTargets = new Set<string>();\n    for (const cell of cells) {\n      if (cell.type === \"edge\" && cell.source === connectLineState.source.id) {\n        existedTargets.add(cell.target);\n      }\n    }\n    for (const cell of cells) {\n      switch (cell.type) {\n        case \"node\":\n          if (existedTargets.has(cell.id)) {\n            unrelated.push(cell);\n          }\n          break;\n        case \"decorator\":\n          if (\n            !allowEdgeToArea ||\n            cell.decorator == \"text\" ||\n            existedTargets.has(cell.id)\n          ) {\n            unrelated.push(cell);\n          }\n          break;\n        default:\n          unrelated.push(cell);\n      }\n    }\n  } else {\n    switch (activeTarget?.type) {\n      case \"multi\": {\n        const nodesMap = new Map<string, Cell>();\n        const activeNodeIds = new Set<string>();\n        const relatedNodeIds = new Set<string>();\n        for (const active of activeTarget.targets) {\n          if (active.type === \"node\") {\n            activeNodeIds.add(active.id);\n            relatedNodeIds.add(active.id);\n          }\n        }\n        for (const cell of cells) {\n          if (cell.type === \"node\") {\n            nodesMap.set(cell.id, cell);\n          } else if (cell.type === \"edge\") {\n            if (activeNodeIds.has(cell.source)) {\n              relatedNodeIds.add(cell.target);\n            } else if (activeNodeIds.has(cell.target)) {\n              relatedNodeIds.add(cell.source);\n            } else if (!targetIsActive(cell, activeTarget)) {\n              unrelated.push(cell);\n            }\n          } else if (!targetIsActive(cell, activeTarget)) {\n            unrelated.push(cell);\n          }\n        }\n        for (const [id, cell] of nodesMap) {\n          if (!relatedNodeIds.has(id)) {\n            unrelated.push(cell);\n          }\n        }\n        break;\n      }\n\n      case \"node\": {\n        const nodesMap = new Map<string, Cell>();\n        const relatedNodeIds = new Set<string>([activeTarget.id]);\n        for (const cell of cells) {\n          if (cell.type === \"node\") {\n            nodesMap.set(cell.id, cell);\n          } else if (cell.type === \"edge\") {\n            if (cell.source === activeTarget.id) {\n              relatedNodeIds.add(cell.target);\n            } else if (cell.target === activeTarget.id) {\n              relatedNodeIds.add(cell.source);\n            } else {\n              unrelated.push(cell);\n            }\n          } else {\n            unrelated.push(cell);\n          }\n        }\n        for (const [id, cell] of nodesMap) {\n          if (!relatedNodeIds.has(id)) {\n            unrelated.push(cell);\n          }\n        }\n        break;\n      }\n\n      case \"edge\":\n        for (const cell of cells) {\n          if (\n            !(cell.type === \"edge\"\n              ? targetIsActive(cell, activeTarget)\n              : cell.type === \"node\" &&\n                (cell.id === activeTarget.source ||\n                  cell.id === activeTarget.target))\n          ) {\n            unrelated.push(cell);\n          }\n        }\n        break;\n    }\n  }\n\n  return unrelated;\n}\n","import type { ActiveTarget, Cell } from \"../interfaces\";\nimport { targetIsActive } from \"./targetIsActive\";\n\nexport type KeyboardAction = KeyboardActionDeleteCells;\n\nexport interface KeyboardActionDeleteCells {\n  action: \"delete-cells\";\n  cells: Cell[];\n}\n\nexport function handleKeyboard(\n  event: KeyboardEvent,\n  {\n    cells,\n    activeTarget,\n  }: {\n    cells: Cell[];\n    activeTarget: ActiveTarget | null | undefined;\n  }\n): KeyboardAction | undefined {\n  const activeCells = cells.filter((cell) =>\n    targetIsActive(cell, activeTarget)\n  );\n\n  if (activeCells.length === 0) {\n    return;\n  }\n\n  const key =\n    event.key ||\n    /* istanbul ignore next: compatibility */ event.keyCode ||\n    /* istanbul ignore next: compatibility */ event.which;\n\n  switch (key) {\n    case \"Backspace\":\n    case 8:\n    case \"Delete\":\n    case 46: {\n      event.preventDefault();\n      event.stopPropagation();\n      return {\n        action: \"delete-cells\",\n        cells: activeCells,\n      };\n    }\n  }\n}\n","import type { PositionTuple, TransformLiteral } from \"../../diagram/interfaces\";\nimport type { NodeView } from \"../interfaces\";\n\nexport interface HandleLassoOptions {\n  transform: TransformLiteral;\n  offset: PositionTuple;\n  onLassoing(rect: NodeView): void;\n  onLassoed(rect: NodeView): void;\n}\n\nexport function handleLasso(\n  event: MouseEvent,\n  { transform, offset, onLassoing, onLassoed }: HandleLassoOptions\n) {\n  if (event.ctrlKey || event.button) {\n    return;\n  }\n\n  event.stopPropagation();\n\n  const from: PositionTuple = [event.clientX, event.clientY];\n  const x0 = (event.clientX - offset[0] - transform.x) / transform.k;\n  const y0 = (event.clientY - offset[1] - transform.y) / transform.k;\n\n  function getMovement(e: MouseEvent): PositionTuple {\n    return [\n      (e.clientX - from[0]) / transform.k,\n      (e.clientY - from[1]) / transform.k,\n    ];\n  }\n\n  let moved = false;\n\n  const handleMove = (e: MouseEvent, finished?: boolean) => {\n    // Respect the scale\n    const movement = getMovement(e);\n    if (!moved) {\n      moved = movement[0] ** 2 + movement[1] ** 2 >= 9;\n    }\n    if (moved) {\n      let [width, height] = movement;\n      let x = x0;\n      let y = y0;\n      if (width < 0) {\n        x = x0 + width;\n        width = -width;\n      }\n      if (height < 0) {\n        y = y0 + height;\n        height = -height;\n      }\n      (finished ? onLassoed : onLassoing)({\n        x,\n        y,\n        width,\n        height,\n      });\n    }\n  };\n\n  const onMouseMove = (e: MouseEvent) => {\n    handleMove(e);\n  };\n  const onMouseUp = (e: MouseEvent) => {\n    handleMove(e, true);\n    moved = false;\n    document.removeEventListener(\"mousemove\", onMouseMove);\n    document.removeEventListener(\"mouseup\", onMouseUp);\n  };\n  document.addEventListener(\"mousemove\", onMouseMove);\n  document.addEventListener(\"mouseup\", onMouseUp);\n}\n","import { Cell, DecoratorCell, NodeCell } from \"../interfaces\";\nimport { MoveCellPayload } from \"../reducers/interfaces\";\nimport { isContainerDecoratorCell, isNodeCell } from \"./asserts\";\n\nexport function handleNodeContainedChange(\n  payloads: MoveCellPayload[],\n  cells: Cell[],\n  onContainerContainerChange?: (detail: MoveCellPayload[]) => void\n) {\n  const nodeCells = cells.filter((c): c is NodeCell => isNodeCell(c));\n  const containerIds = payloads\n    .filter((p) => isContainerDecoratorCell(p))\n    .map((v) => v.id);\n  const nodePayloads = payloads.filter((p) => {\n    const nodeCell = nodeCells.find((v) => v.id === p.id)!;\n    const includeNodeFlag =\n      nodeCell?.containerId && containerIds.includes(nodeCell.containerId);\n    return isNodeCell(p) && !includeNodeFlag;\n  });\n  nodePayloads.forEach((payload) => {\n    const left = payload.x;\n    const right = payload.x + payload.width!;\n    const top = payload.y;\n    const bottom = payload.y + payload!.height!;\n    const containerDecoratorCells = cells.filter(\n      (cell): cell is DecoratorCell => isContainerDecoratorCell(cell)\n    );\n    for (const containerCell of containerDecoratorCells) {\n      const containerLeft = containerCell.view.x;\n      const containerRight = containerCell.view.x + containerCell.view.width;\n      const containerTop = containerCell.view.y;\n      const containerBottom = containerCell.view.y + containerCell.view.height;\n      if (\n        left >= containerLeft &&\n        right <= containerRight &&\n        top >= containerTop &&\n        bottom <= containerBottom\n      ) {\n        payload.containerCell = containerCell;\n        break; //A node can be associated with only one container\n      }\n    }\n  });\n  let containedChanges = [];\n  containedChanges = nodePayloads.filter((payload) => {\n    const nodeCell = nodeCells.find((c) => c.id === payload.id);\n    const containerId = nodeCell?.containerId;\n    const containerCellId = payload.containerCell?.id;\n    //combocombo\n    return containerId !== containerCellId;\n  });\n  if (containedChanges.length > 0) {\n    onContainerContainerChange?.(containedChanges);\n  }\n  return containedChanges;\n}\n","import type { SizeTuple } from \"../../diagram/interfaces\";\nimport type { Cell, InitialCell, NodeCell } from \"../interfaces\";\nimport { isInitialNodeCell } from \"./asserts\";\n\nexport function initializeCells(\n  initialCells: InitialCell[] | undefined,\n  {\n    defaultNodeSize,\n  }: {\n    defaultNodeSize: SizeTuple;\n  }\n): Cell[] {\n  const originalCells = initialCells ?? [];\n  const finalCells: Cell[] = originalCells.map<Cell>((cell) => {\n    if (\n      !isInitialNodeCell(cell) ||\n      (cell.view?.width !== undefined && cell.view?.height !== undefined)\n    ) {\n      return cell as NodeCell;\n    }\n    return {\n      ...cell,\n      view: {\n        width: defaultNodeSize[0],\n        height: defaultNodeSize[1],\n        ...cell.view,\n      },\n    } as NodeCell;\n  });\n  return finalCells;\n}\n","import type {\n  ActiveTarget,\n  ActiveTargetOfEdge,\n  ActiveTargetOfMulti,\n  ActiveTargetOfNode,\n} from \"../interfaces\";\n\nexport function sameTarget(\n  a: ActiveTarget | null | undefined,\n  b: ActiveTarget | null | undefined\n): boolean {\n  return a\n    ? !!b &&\n        a.type === b.type &&\n        (a.type === \"multi\"\n          ? a.targets.length === (b as ActiveTargetOfMulti).targets.length &&\n            a.targets.every((targetA) =>\n              (b as ActiveTargetOfMulti).targets.some((targetB) =>\n                sameTarget(targetA, targetB)\n              )\n            )\n          : a.type === \"node\" || a.type === \"decorator\"\n            ? a.id === (b as ActiveTargetOfNode).id\n            : a.source === (b as ActiveTargetOfEdge).source &&\n              a.target === (b as ActiveTargetOfEdge).target)\n    : !b;\n}\n","import type { ActiveTarget, ActiveTargetOfSingular } from \"../interfaces\";\nimport { sameTarget } from \"./sameTarget\";\n\nexport function targetIsActive(\n  target: ActiveTargetOfSingular,\n  activeTarget: ActiveTarget | null | undefined\n): boolean {\n  return (\n    !!activeTarget &&\n    (activeTarget.type === \"multi\"\n      ? activeTarget.targets\n      : [activeTarget]\n    ).some((active) => sameTarget(active, target))\n  );\n}\n","import type { TransformLiteral } from \"../../diagram/interfaces\";\nimport type { Cell } from \"../interfaces\";\nimport { isEdgeCell } from \"./asserts\";\n\nexport interface TransformToCenterOptions {\n  canvasWidth: number;\n  canvasHeight: number;\n  scaleRange?: [min: number, max: number];\n}\n\nexport function transformToCenter(\n  cells: Cell[],\n  { canvasWidth, canvasHeight, scaleRange }: TransformToCenterOptions\n): TransformLiteral {\n  let left = Infinity;\n  let top = Infinity;\n  let right = -Infinity;\n  let bottom = -Infinity;\n  let empty = true;\n  for (const cell of cells) {\n    if (!isEdgeCell(cell)) {\n      empty = false;\n      const { view } = cell;\n      const r = view.x + view.width;\n      const b = view.y + view.height;\n      if (view.x < left) {\n        left = view.x;\n      }\n      if (r > right) {\n        right = r;\n      }\n      if (view.y < top) {\n        top = view.y;\n      }\n      if (b > bottom) {\n        bottom = b;\n      }\n    }\n  }\n\n  const width = right - left;\n  const height = bottom - top;\n\n  const scale =\n    scaleRange && !empty && (width > canvasWidth || height > canvasHeight)\n      ? Math.max(\n          Math.min(canvasWidth / width, canvasHeight / height, scaleRange[1]),\n          scaleRange[0]\n        )\n      : 1;\n\n  const x = empty ? 0 : (canvasWidth - width * scale) / 2 - left * scale;\n  const y = empty ? 0 : (canvasHeight - height * scale) / 2 - top * scale;\n\n  return { x, y, k: scale };\n}\n","import { without } from \"lodash\";\nimport type {\n  RangeTuple,\n  SizeTuple,\n  TransformLiteral,\n} from \"../../diagram/interfaces\";\nimport { DEFAULT_NODE_GAP, SYMBOL_FOR_SIZE_INITIALIZED } from \"../constants\";\nimport type {\n  Cell,\n  InitialCell,\n  LayoutType,\n  NodeCell,\n  NodeId,\n  NodeView,\n} from \"../interfaces\";\nimport { isDecoratorCell, isEdgeCell, isNodeCell } from \"./asserts\";\nimport { initializeCells } from \"./initializeCells\";\nimport { transformToCenter } from \"./transformToCenter\";\nimport { forceLayout } from \"../../shared/canvas/forceLayout\";\nimport { dagreLayout } from \"../../shared/canvas/dagreLayout\";\nimport { sameTarget } from \"./sameTarget\";\n\nexport function updateCells({\n  cells,\n  layout,\n  previousCells,\n  defaultNodeSize,\n  canvasWidth,\n  canvasHeight,\n  scaleRange,\n  transform,\n  reason,\n  parent,\n  allowEdgeToArea,\n}: {\n  cells: InitialCell[] | undefined;\n  layout?: LayoutType;\n  previousCells: Cell[];\n  defaultNodeSize: SizeTuple;\n  canvasWidth: number;\n  canvasHeight: number;\n  scaleRange: RangeTuple;\n  transform: TransformLiteral;\n  reason?: \"add-related-nodes\";\n  parent?: NodeId;\n  allowEdgeToArea?: boolean;\n}): {\n  cells: Cell[];\n  updated: Cell[];\n  shouldReCenter: boolean;\n} {\n  const isManualLayout = layout !== \"force\" && layout !== \"dagre\";\n  const newCells = initializeCells(cells, { defaultNodeSize });\n  const updateCandidates: NodeCell[] = [];\n  let shouldReCenter = false;\n\n  const previousSizeInitializedNodes = new Map<string, NodeCell>();\n  let previousShouldCentered = false;\n  for (const cell of previousCells) {\n    if (isDecoratorCell(cell)) {\n      previousShouldCentered = true;\n    } else if (isNodeCell(cell)) {\n      previousShouldCentered = true;\n      if (cell[SYMBOL_FOR_SIZE_INITIALIZED]) {\n        previousSizeInitializedNodes.set(cell.id, cell);\n      }\n    }\n  }\n\n  const nodesMap = new Map<string, NodeCell>();\n  for (const cell of newCells) {\n    if (isNodeCell(cell)) {\n      nodesMap.set(cell.id, cell);\n      const previousNode = previousSizeInitializedNodes.get(cell.id);\n      if (previousNode) {\n        cell.view.width = previousNode.view.width;\n        cell.view.height = previousNode.view.height;\n        cell[SYMBOL_FOR_SIZE_INITIALIZED] = true;\n      }\n    }\n  }\n\n  let handled = false;\n\n  if (reason === \"add-related-nodes\" && parent) {\n    // Place these unpositioned downstream nodes below the parent node, and\n    // on the right side of the positioned siblings.\n    const downstreamNodeIds = new Set<string>();\n    for (const cell of newCells) {\n      if (\n        isEdgeCell(cell) &&\n        cell.source === parent &&\n        cell.target !== parent\n      ) {\n        downstreamNodeIds.add(cell.target);\n      }\n    }\n    const parentNode = nodesMap.get(parent);\n    if (parentNode?.view.x !== undefined && parentNode.view.y !== undefined) {\n      handled = true;\n      /**\n       * \n       */\n      if (isManualLayout) {\n        for (const cell of newCells) {\n          if (\n            (isNodeCell(cell) && cell.view.x === undefined) ||\n            (isNodeCell(cell) && cell.view.y === undefined)\n          ) {\n            downstreamNodeIds.add(cell.id);\n          }\n        }\n      }\n      const downstreamNodes = [...downstreamNodeIds]\n        .map((id) => nodesMap.get(id))\n        .filter(Boolean) as NodeCell[];\n      let rightMostNode: NodeCell | undefined = undefined;\n      for (const node of downstreamNodes) {\n        if (node.view.x !== undefined && node.view.y !== undefined) {\n          // Find the rightmost node that is below the parent node.\n          if (\n            (!rightMostNode || node.view.x > rightMostNode.view.x) &&\n            node.view.y > parentNode.view.y\n          ) {\n            rightMostNode = node;\n          }\n        } else {\n          // Unpositioned nodes\n          updateCandidates.push(node);\n        }\n      }\n      if (updateCandidates.length > 0 && isManualLayout) {\n        let nextX: number;\n        let nextY: number;\n        if (rightMostNode) {\n          // Place unpositioned nodes on the right side of the rightmost positioned siblings.\n          nextX =\n            rightMostNode.view.x + rightMostNode.view.width + DEFAULT_NODE_GAP;\n          nextY = rightMostNode.view.y;\n        } else {\n          // If there are no positioned siblings, just place them below the parent.\n          const totalWidth = updateCandidates.reduce(\n            (acc, node) => acc + node.view.width + DEFAULT_NODE_GAP,\n            -DEFAULT_NODE_GAP\n          );\n          nextX =\n            parentNode.view.x - totalWidth / 2 + parentNode.view.width / 2;\n          nextY = parentNode.view.y + parentNode.view.height + DEFAULT_NODE_GAP;\n        }\n        for (const node of updateCandidates) {\n          node.view.x = nextX;\n          node.view.y = nextY;\n          nextX += node.view.width + DEFAULT_NODE_GAP;\n        }\n      }\n    }\n  }\n\n  if (!handled) {\n    // By default, place unpositioned nodes in a grid.\n    let maxWidth = defaultNodeSize[0];\n    let maxHeight = defaultNodeSize[1];\n    const positionedNodes: NodeCell[] = [];\n    let hasDecorators = false;\n    for (const cell of newCells) {\n      if (isNodeCell(cell)) {\n        if (cell.view.width > maxWidth) {\n          maxWidth = cell.view.width;\n        }\n        if (cell.view.height > maxHeight) {\n          maxHeight = cell.view.height;\n        }\n        if (cell.view.x === undefined || cell.view.y === undefined) {\n          updateCandidates.push(cell);\n        } else {\n          positionedNodes.push(cell);\n        }\n      } else if (isDecoratorCell(cell)) {\n        hasDecorators = true;\n      }\n    }\n\n    if (isManualLayout) {\n      if (!previousShouldCentered) {\n        // If the previous cells are not centered, use the centered transform instead.\n        transform = transformToCenter(without(newCells, ...updateCandidates), {\n          canvasWidth,\n          canvasHeight,\n          scaleRange,\n        });\n      }\n\n      let getNodeView: (id: NodeId) => NodeView;\n\n      // If there is no positioned nodes, or only one while without decorators,\n      // then there is no relative positions, we can place the nodes with dagre layout.\n      // Otherwise, use the force layout.\n      if (\n        positionedNodes.length === 0 ||\n        (positionedNodes.length === 1 && !hasDecorators)\n      ) {\n        // The positioned node (if exists) will be updated.\n        updateCandidates.push(...positionedNodes);\n        ({ getNodeView } = dagreLayout({ cells: newCells, allowEdgeToArea }));\n        // Only re-center when there is no cells previous,\n        // or the cell ids are not changed (this happens when updateCells called by backend right after dropNode).\n        shouldReCenter =\n          previousCells.length === 0 ||\n          (previousCells.length === newCells.length &&\n            previousCells.every((cell, index) =>\n              sameTarget(cell, newCells[index])\n            ));\n      } else {\n        ({ getNodeView } = forceLayout({\n          cells: newCells,\n          fixedPosition: true,\n          allowEdgeToArea,\n          center: [\n            (canvasWidth / 2 - transform.x) / transform.k,\n            (canvasHeight / 2 - transform.y) / transform.k,\n          ],\n        }));\n      }\n\n      for (const cell of newCells) {\n        if (isNodeCell(cell)) {\n          const view = getNodeView(cell.id);\n          cell.view.x = view.x;\n          cell.view.y = view.y;\n        }\n      }\n    }\n  }\n\n  return { cells: newCells, updated: updateCandidates, shouldReCenter };\n}\n","import type { Reducer } from \"react\";\nimport type { DrawCanvasAction } from \"./interfaces\";\nimport type { Cell, EdgeCell, NodeCell } from \"../interfaces\";\nimport { isNodeCell } from \"../processors/asserts\";\nimport { SYMBOL_FOR_SIZE_INITIALIZED } from \"../constants\";\n\nexport const cells: Reducer<Cell[], DrawCanvasAction> = (state, action) => {\n  switch (action.type) {\n    case \"drop-node\":\n      return insertCellAfter(\n        state,\n        action.payload,\n        (cell) => !(cell.type === \"decorator\" && cell.decorator === \"text\")\n      );\n    case \"drop-decorator\": {\n      if (action.payload.decorator === \"text\") {\n        return [...state, action.payload];\n      }\n      return insertCellAfter(\n        state,\n        action.payload,\n        (cell) => cell.type === \"decorator\" && cell.decorator === \"area\"\n      );\n    }\n    case \"add-nodes\": {\n      const index =\n        state.findLastIndex(\n          (cell) => !(cell.type === \"decorator\" && cell.decorator === \"text\")\n        ) + 1;\n      return [\n        ...state.slice(0, index),\n        ...action.payload,\n        ...state.slice(index),\n      ];\n    }\n    case \"add-edge\": {\n      const existedEdgeIndex = state.findIndex(\n        (cell) =>\n          cell.type === \"edge\" &&\n          cell.source === action.payload.source &&\n          cell.target === action.payload.target\n      );\n      if (existedEdgeIndex === -1) {\n        // Add the edge to just next to the previous last edge or area decorator.\n        // If not found, append to the start.\n        return insertCellAfter(\n          state,\n          action.payload,\n          (cell) =>\n            cell.type === \"edge\" ||\n            (cell.type === \"decorator\" && cell.decorator === \"area\")\n        );\n      }\n      return [\n        ...state.slice(0, existedEdgeIndex),\n        action.payload,\n        ...state.slice(existedEdgeIndex + 1),\n      ];\n    }\n    case \"change-edge-view\": {\n      const existedEdgeIndex = state.findIndex(\n        (cell) =>\n          cell.type === \"edge\" &&\n          cell.source === action.payload.source &&\n          cell.target === action.payload.target\n      );\n      return existedEdgeIndex === -1\n        ? state\n        : [\n            ...state.slice(0, existedEdgeIndex),\n            {\n              ...(state[existedEdgeIndex] as EdgeCell),\n              view: {\n                ...(state[existedEdgeIndex] as EdgeCell).view,\n                ...action.payload.view,\n              },\n            },\n            ...state.slice(existedEdgeIndex + 1),\n          ];\n    }\n    case \"move-cells\": {\n      let matched = false;\n      const newState = state.map((cell) => {\n        const newCell = action.payload.find(\n          (move) => cell.type === move.type && cell.id === move.id\n        );\n        if (newCell) {\n          matched = true;\n          return {\n            ...(cell as NodeCell),\n            view: { ...(cell as NodeCell).view, x: newCell.x, y: newCell.y },\n          };\n        }\n        return cell;\n      });\n      return matched ? newState : state;\n    }\n    case \"resize-cell\": {\n      const { type, id, width, height } = action.payload;\n      const index = state.findIndex(\n        (cell) => cell.type === type && cell.id === id\n      );\n      if (index !== -1) {\n        const node = state[index] as NodeCell;\n        return [\n          ...state.slice(0, index),\n          { ...node, view: { ...node.view, width, height } },\n          ...state.slice(index + 1),\n        ];\n      }\n      return state;\n    }\n    case \"update-cells\":\n      return action.payload;\n    case \"update-node-size\":\n      return state.map((cell) =>\n        isNodeCell(cell) && cell.id === action.payload.id\n          ? {\n              ...cell,\n              [SYMBOL_FOR_SIZE_INITIALIZED]: true,\n              view: action.payload.size\n                ? {\n                    ...cell.view,\n                    width: action.payload.size[0],\n                    height: action.payload.size[1],\n                  }\n                : cell.view,\n            }\n          : cell\n      );\n  }\n  return state;\n};\n\nfunction insertCellAfter(\n  cells: Cell[],\n  newCell: Cell,\n  after: (cell: Cell) => boolean\n) {\n  const index = cells.findLastIndex(after) + 1;\n  return [...cells.slice(0, index), newCell, ...cells.slice(index)];\n}\n","import { Reducer } from \"react\";\nimport type { DrawCanvasAction, DrawCanvasState } from \"./interfaces\";\nimport { cells } from \"./cells\";\nimport { layoutKey } from \"./layoutKey\";\n\ntype ReducersMapObject<S, A> = {\n  [K in keyof S]: Reducer<S[K], A>;\n};\n\nfunction combineReducers<S, A>(\n  reducers: ReducersMapObject<S, A>\n): Reducer<S, A> {\n  return ((state, action) =>\n    Object.fromEntries(\n      Object.entries<Reducer<any, A>>(reducers).map(([key, value]) => [\n        key,\n        value(state[key as keyof S], action),\n      ])\n    )) as Reducer<S, A>;\n}\n\nexport const rootReducer = combineReducers<DrawCanvasState, DrawCanvasAction>({\n  cells,\n  layoutKey,\n});\n","import type { Reducer } from \"react\";\nimport type { DrawCanvasAction } from \"./interfaces\";\n\nexport const layoutKey: Reducer<number, DrawCanvasAction> = (state, action) => {\n  switch (action.type) {\n    case \"update-node-size\":\n      return action.layoutKey;\n    default:\n      return state;\n  }\n};\n","import * as React from \"react\";\nconst SvgCenter = props => <svg xmlns=\"http://www.w3.org/2000/svg\" width={24} height={24} viewBox=\"0 0 24 24\" {...props}><path d=\"M12 0a.5.5 0 0 1 .5.5v2.013a9.5 9.5 0 0 1 8.987 8.988L23.5 11.5a.5.5 0 0 1 0 1h-2.013a9.5 9.5 0 0 1-8.987 8.987V23.5a.5.5 0 0 1-1 0v-2.013A9.5 9.5 0 0 1 2.514 12.5H.5a.5.5 0 0 1 0-1h2.013A9.5 9.5 0 0 1 11.5 2.514V.5A.5.5 0 0 1 12 0M3.514 11.5H7.5a.5.5 0 0 1 0 1H3.514a8.5 8.5 0 0 0 7.987 7.986L11.5 16.5a.5.5 0 0 1 1 0v3.986a8.5 8.5 0 0 0 7.986-7.986H16.5a.5.5 0 0 1 0-1h3.986A8.5 8.5 0 0 0 12.5 3.515V7.5a.5.5 0 0 1-1 0V3.514a8.5 8.5 0 0 0-7.986 7.987zm8.486-1a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3\" /></svg>;\nexport default SvgCenter;","import * as React from \"react\";\nconst SvgZoomIn = props => <svg xmlns=\"http://www.w3.org/2000/svg\" width={128} height={128} className=\"icon\" viewBox=\"0 0 1024 1024\" {...props}><path d=\"M512 76.8A435.2 435.2 0 1 0 947.2 512 435.71 435.71 0 0 0 512 76.8m0 819.2a384 384 0 1 1 384-384 384 384 0 0 1-384 384\" /><path d=\"M744.448 486.4h-204.8V281.6a25.6 25.6 0 1 0-51.2 0v204.8h-204.8a25.6 25.6 0 0 0 0 51.2h204.8v204.8a25.6 25.6 0 0 0 51.2 0V537.6h204.8a25.6 25.6 0 0 0 0-51.2\" /></svg>;\nexport default SvgZoomIn;","import * as React from \"react\";\nconst SvgZoomOut = props => <svg xmlns=\"http://www.w3.org/2000/svg\" width={128} height={128} className=\"icon\" viewBox=\"0 0 1024 1024\" {...props}><path d=\"M512 76.8A435.2 435.2 0 1 0 947.2 512 435.71 435.71 0 0 0 512 76.8m0 819.2a384 384 0 1 1 384-384 384 384 0 0 1-384 384\" /><path d=\"M744.448 486.4H280.064a25.6 25.6 0 1 0 0 51.2h464.384a25.6 25.6 0 0 0 0-51.2\" /></svg>;\nexport default SvgZoomOut;","import React, { useCallback, useMemo, useRef } from \"react\";\nimport { ConfigProvider, Slider, theme } from \"antd\";\nimport { StyleProvider, createCache } from \"@ant-design/cssinjs\";\nimport { useCurrentTheme } from \"@next-core/react-runtime\";\nimport type { RangeTuple } from \"../../diagram/interfaces\";\nimport CenterSVG from \"./icons/center.svg\";\nimport ZoomInSVG from \"./icons/zoom-in.svg\";\nimport ZoomOutSVG from \"./icons/zoom-out.svg\";\n\nexport interface ZoomBarComponentProps {\n  shadowRoot: ShadowRoot;\n  scale: number;\n  scaleRange: RangeTuple;\n  onZoomChange(value: number): void;\n  onReCenter(): void;\n}\n\nexport function ZoomBarComponent({\n  shadowRoot,\n  scale,\n  scaleRange,\n  onZoomChange,\n  onReCenter,\n}: ZoomBarComponentProps): JSX.Element | null {\n  const currentTheme = useCurrentTheme();\n  const cache = useMemo(() => createCache(), []);\n  const zoomBarRef = useRef<HTMLDivElement | null>(null);\n  const min = scaleRange[0] * 100;\n  const max = scaleRange[1] * 100;\n  const value = scale * 100;\n  const step = 5;\n\n  const tooltip = useMemo(() => {\n    return {\n      formatter: (value: number | undefined) => `${value}%`,\n      placement: \"left\" as const,\n      getPopupContainer: () => zoomBarRef.current!,\n    };\n  }, []);\n\n  const onZoomIn = useCallback(() => {\n    onZoomChange(Math.min(value + step, max));\n  }, [max, onZoomChange, value]);\n\n  const onZoomOut = useCallback(() => {\n    onZoomChange(Math.max(value - step, min));\n  }, [min, onZoomChange, value]);\n\n  return (\n    <ConfigProvider\n      theme={{\n        algorithm:\n          currentTheme === \"dark-v2\"\n            ? theme.darkAlgorithm\n            : theme.defaultAlgorithm,\n      }}\n    >\n      <StyleProvider\n        container={shadowRoot}\n        // Auto clear injected styles after unmount\n        autoClear\n        cache={cache}\n        // Set hashPriority to \"high\" to disable `:where()` usage for compatibility\n        hashPriority=\"high\"\n      >\n        <div className=\"zoom-bar\" ref={zoomBarRef}>\n          <div className=\"center-button\" onClick={onReCenter} role=\"button\">\n            <CenterSVG />\n          </div>\n          <div className=\"zoom-slider\">\n            <div className=\"zoom-button\" role=\"button\" onClick={onZoomIn}>\n              <ZoomInSVG />\n            </div>\n            <Slider\n              min={min}\n              max={max}\n              value={value}\n              step={step}\n              vertical\n              included={false}\n              tooltip={tooltip}\n              onChange={onZoomChange}\n            />\n            <div className=\"zoom-button\" role=\"button\" onClick={onZoomOut}>\n              <ZoomOutSVG />\n            </div>\n          </div>\n        </div>\n      </StyleProvider>\n    </ConfigProvider>\n  );\n}\n","import { pick } from \"lodash\";\nimport dagre from \"@dagrejs/dagre\";\nimport { extractPartialRectTuple } from \"../../diagram/processors/extractPartialRectTuple\";\nimport type {\n  Cell,\n  ForceNode,\n  LayoutOptionsDagre,\n  NodeId,\n  NodeView,\n} from \"../../draw-canvas/interfaces\";\nimport {\n  isEdgeCell,\n  isNodeCell,\n  isNodeOrAreaDecoratorCell,\n} from \"../../draw-canvas/processors/asserts\";\nimport type { FullRectTuple } from \"../../diagram/interfaces\";\n\nexport interface DagreLayoutOptions {\n  cells: Cell[];\n  layoutOptions?: LayoutOptionsDagre;\n  allowEdgeToArea?: boolean;\n}\n\nexport function dagreLayout({\n  cells,\n  layoutOptions,\n  allowEdgeToArea,\n}: DagreLayoutOptions): {\n  getNodeView: (id: NodeId) => NodeView;\n  nodePaddings: FullRectTuple;\n} {\n  const { nodePadding, ...dagreGraphOptions } = {\n    nodePadding: 0,\n    rankdir: \"TB\",\n    ranksep: 50,\n    edgesep: 10,\n    nodesep: 50,\n    // align: undefined,\n    ...pick(layoutOptions, [\n      \"nodePadding\",\n      \"rankdir\",\n      \"ranksep\",\n      \"edgesep\",\n      \"nodesep\",\n      \"align\",\n    ]),\n  };\n  const nodePaddings = extractPartialRectTuple(nodePadding);\n\n  if (!cells.some(isNodeCell)) {\n    // Dagre cannot render empty nodes\n    return {\n      getNodeView: () => null!,\n      nodePaddings,\n    };\n  }\n\n  const graph = new dagre.graphlib.Graph<ForceNode>();\n  graph.setGraph(dagreGraphOptions);\n  // Default to assigning a new object as a label for each new edge.\n  graph.setDefaultEdgeLabel(function () {\n    return {};\n  });\n  for (const cell of cells) {\n    if (\n      (allowEdgeToArea && isNodeOrAreaDecoratorCell(cell)) ||\n      isNodeCell(cell)\n    ) {\n      graph.setNode(cell.id, {\n        id: cell.id,\n        width: cell.view.width + nodePaddings[1] + nodePaddings[3],\n        height: cell.view.height + nodePaddings[0] + nodePaddings[2],\n      });\n    } else if (isEdgeCell(cell)) {\n      graph.setEdge(cell.source, cell.target);\n    }\n  }\n  dagre.layout(graph);\n\n  return {\n    getNodeView: (id: NodeId) => graph.node(id),\n    nodePaddings,\n  };\n}\n","import { pick } from \"lodash\";\nimport {\n  forceCollide,\n  forceLink,\n  forceManyBody,\n  forceSimulation,\n  forceX,\n  forceY,\n  type Simulation,\n} from \"d3-force\";\nimport type {\n  Cell,\n  ForceCollideOptions,\n  ForceLink,\n  ForceNode,\n  LayoutOptionsForce,\n  NodeId,\n  NodeView,\n} from \"../../draw-canvas/interfaces\";\nimport {\n  isEdgeCell,\n  isNodeCell,\n  isNodeOrAreaDecoratorCell,\n} from \"../../draw-canvas/processors/asserts\";\nimport { extractPartialRectTuple } from \"../../diagram/processors/extractPartialRectTuple\";\nimport type { FullRectTuple, PositionTuple } from \"../../diagram/interfaces\";\n\nexport interface ForceLayoutOptions {\n  cells: Cell[];\n  layoutOptions?: LayoutOptionsForce;\n  center?: PositionTuple;\n  fixedPosition?: boolean;\n  allowEdgeToArea?: boolean;\n}\n\nexport function forceLayout({\n  cells,\n  layoutOptions,\n  center,\n  fixedPosition,\n  allowEdgeToArea,\n}: ForceLayoutOptions): {\n  getNodeView: (id: NodeId) => NodeView;\n  nodePaddings: FullRectTuple;\n} {\n  const { nodePadding, collide } = {\n    nodePadding: 0,\n    ...pick(layoutOptions, [\"nodePadding\"]),\n    collide:\n      layoutOptions?.collide !== false\n        ? ({\n            radiusDiff: 18,\n            strength: 1,\n            iterations: 1,\n            ...(layoutOptions?.collide === true\n              ? null\n              : (layoutOptions?.collide as ForceCollideOptions)),\n          } as Required<ForceCollideOptions>)\n        : (false as const),\n  };\n  const nodePaddings = extractPartialRectTuple(nodePadding);\n  const forceNodes: ForceNode[] = [];\n  const forceLinks: ForceLink[] = [];\n  const nodesMap = new Map<NodeId, ForceNode>();\n  for (const cell of cells) {\n    if (\n      (allowEdgeToArea && isNodeOrAreaDecoratorCell(cell)) ||\n      isNodeCell(cell)\n    ) {\n      const node: ForceNode = {\n        id: cell.id,\n        width: cell.view.width + nodePaddings[1] + nodePaddings[3],\n        height: cell.view.height + nodePaddings[0] + nodePaddings[2],\n        ...(fixedPosition ? { fx: cell.view.x, fy: cell.view.y } : null),\n      };\n      forceNodes.push(node);\n      nodesMap.set(node.id, node);\n    } else if (isEdgeCell(cell)) {\n      forceLinks.push({ source: cell.source, target: cell.target });\n    }\n  }\n\n  const linkSimulation = forceLink<ForceNode, ForceLink>(forceLinks).id(\n    (d) => d.id\n  );\n  const simulation = forceSimulation<ForceNode, ForceLink>(forceNodes)\n    .force(\"link\", linkSimulation)\n    .force(\"x\", forceX(center?.[0]))\n    .force(\"y\", forceY(center?.[1]))\n    .force(\"charge\", forceManyBody());\n\n  if (collide) {\n    simulation.force(\n      \"collide\",\n      forceCollide<ForceNode>()\n        .radius(\n          (d) =>\n            Math.sqrt(d.width ** 2 + d.height ** 2) / 2 + collide.radiusDiff\n        )\n        .strength(collide.strength)\n        .iterations(collide.iterations)\n    );\n  }\n\n  simulation.stop();\n  manuallyTickToTheEnd(simulation);\n\n  return {\n    getNodeView: (id: NodeId) => nodesMap.get(id) as NodeView,\n    nodePaddings,\n  };\n}\n\nfunction manuallyTickToTheEnd(\n  simulation: Simulation<ForceNode, ForceLink>\n): void {\n  // Manually tick to the end.\n  simulation.tick(\n    Math.ceil(\n      Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())\n    )\n  );\n}\n","import type { NodeRect } from \"../../../diagram/interfaces\";\nimport type { NodeView } from \"../../../draw-canvas/interfaces\";\n\nexport function nodeViewToNodeRect(view: NodeView, padding: number): NodeRect {\n  return {\n    x: view.x + view.width / 2,\n    y: view.y + view.height / 2,\n    width: view.width + padding,\n    height: view.height + padding,\n  };\n}\n","import { pull } from \"lodash\";\nimport type { NodePosition } from \"../../../diagram/interfaces\";\nimport { getConnectPointsOfRectangleWithDirection } from \"../shapes/Rectangle\";\nimport type {\n  BiDirection,\n  EdgeView,\n  NodeView,\n} from \"../../../draw-canvas/interfaces\";\nimport { getPolyLinePoints } from \"../../../diagram/lines/getPolyLinePoints\";\nimport { nodeViewToNodeRect } from \"./nodeViewToNodeRect\";\nimport {\n  DEFAULT_NODE_PADDING_FOR_LINES,\n  DEFAULT_NODE_PADDING_FOR_SMART_LINES,\n} from \"../../../draw-canvas/constants\";\nimport { getDirectLinePoints } from \"../../../diagram/lines/getDirectLinePoints\";\nimport { isStraightType } from \"../../../draw-canvas/processors/asserts\";\n\nconst DEFAULT_DIRECTIONS = [\"right\", \"top\", \"left\", \"bottom\"] as const;\n\nexport function getSmartLinePoints(\n  sourceView: NodeView,\n  targetView: NodeView,\n  edgeView: EdgeView | undefined,\n  parallelGap?: number\n): NodePosition[] | null {\n  const {\n    type,\n    vertices,\n    exitPosition: originalExit,\n    entryPosition: originalEntry,\n  } = edgeView ?? {};\n\n  if (isStraightType(type)) {\n    return getDirectLinePoints(\n      nodeViewToNodeRect(\n        sourceView,\n        originalExit\n          ? DEFAULT_NODE_PADDING_FOR_SMART_LINES\n          : DEFAULT_NODE_PADDING_FOR_LINES\n      ),\n      nodeViewToNodeRect(\n        targetView,\n        originalEntry\n          ? DEFAULT_NODE_PADDING_FOR_SMART_LINES\n          : DEFAULT_NODE_PADDING_FOR_LINES\n      ),\n      parallelGap,\n      edgeView\n    );\n  }\n\n  if (vertices?.length) {\n    const firstVertex = vertices[0];\n    const lastVertex = vertices[vertices.length - 1];\n\n    let exitPoint: NodePosition;\n    let entryPoint: NodePosition;\n    let exitDirection: BiDirection | undefined;\n    let entryDirection: BiDirection | undefined;\n\n    // Auto decide the exit and entry position.\n    if (originalExit) {\n      exitPoint = getAbsolutePosition(sourceView, originalExit);\n    } else {\n      let possibleFirstNextPoint: NodePosition | undefined;\n      if (vertices.length > 1) {\n        // Decide exit point by the first two vertices.\n        possibleFirstNextPoint = vertices[1];\n      } else if (originalEntry) {\n        // Decide exit point by the entry position.\n        possibleFirstNextPoint = getAbsolutePosition(targetView, originalEntry);\n      }\n      if (possibleFirstNextPoint) {\n        exitPoint = getDefaultAbsolutePosition(\n          firstVertex,\n          sourceView,\n          firstVertex.y === possibleFirstNextPoint.y\n        );\n      } else {\n        // No other vertices nor the entry position, decide exit point by the\n        // relative position between the last vertex and the target node.\n        const prefer =\n          lastVertex.y < targetView.y ||\n          lastVertex.y > targetView.y + targetView.height\n            ? \"ns\"\n            : \"ew\";\n        ({ point: exitPoint, direction: exitDirection } =\n          fitEndpointAndDirection(sourceView, targetView, vertices, prefer));\n      }\n    }\n\n    if (originalEntry) {\n      entryPoint = getAbsolutePosition(targetView, originalEntry);\n    } else {\n      let possibleLastPreviousPoint: NodePosition | undefined;\n      if (vertices.length > 1) {\n        // Decide entry point by the last two vertices.\n        possibleLastPreviousPoint = vertices[vertices.length - 2];\n      } else if (originalExit) {\n        // Decide entry point by the exit position.\n        possibleLastPreviousPoint = getAbsolutePosition(\n          sourceView,\n          originalExit\n        );\n      }\n      if (possibleLastPreviousPoint) {\n        entryPoint = getDefaultAbsolutePosition(\n          lastVertex,\n          targetView,\n          lastVertex.y === possibleLastPreviousPoint.y\n        );\n      } else {\n        // No other vertices nor the exit position, decide entry point by the\n        // relative position between the first vertex and the source node.\n        const prefer =\n          firstVertex.x < sourceView.x ||\n          firstVertex.x > sourceView.x + sourceView.width\n            ? \"ew\"\n            : \"ns\";\n        ({ point: entryPoint, direction: entryDirection } =\n          fitEndpointAndDirection(\n            targetView,\n            sourceView,\n            vertices.slice().reverse(),\n            prefer\n          ));\n      }\n    }\n\n    const { x: sourceX, y: sourceY } = exitPoint;\n    const { x: targetX, y: targetY } = entryPoint;\n\n    const newLinePoints = [exitPoint, ...vertices, entryPoint];\n\n    const newVertices = [...vertices];\n\n    // If the first vertex is not on any axis of the source exit point,\n    // add a vertex to connect them.\n    if (firstVertex && firstVertex.x !== sourceX && firstVertex.y !== sourceY) {\n      newVertices.unshift(\n        exitDirection === \"ns\"\n          ? { x: sourceX, y: firstVertex.y }\n          : exitDirection === \"ew\"\n            ? { x: firstVertex.x, y: sourceY }\n            : firstVertex.x === newLinePoints[2].x\n              ? { x: sourceX, y: firstVertex.y }\n              : { x: firstVertex.x, y: sourceY }\n      );\n    }\n\n    // If the last vertex is not on any axis of the target entry point,\n    // add a vertex to connect them.\n    if (lastVertex && lastVertex.x !== targetX && lastVertex.y !== targetY) {\n      newVertices.push(\n        entryDirection === \"ns\"\n          ? { x: targetX, y: lastVertex.y }\n          : entryDirection === \"ew\"\n            ? { x: lastVertex.x, y: targetY }\n            : lastVertex.x === newLinePoints[newLinePoints.length - 3].x\n              ? { x: targetX, y: lastVertex.y }\n              : { x: lastVertex.x, y: targetY }\n      );\n    }\n\n    return [\n      exitPoint,\n      ...simplifyVertices(exitPoint, newVertices, entryPoint),\n      entryPoint,\n    ];\n  }\n\n  const exitPosition =\n    originalExit ?? getDefaultPosition(targetView, sourceView);\n  const entryPosition =\n    originalEntry ?? getDefaultPosition(sourceView, targetView);\n\n  const { x: sourceX, y: sourceY } = getAbsolutePosition(\n    sourceView,\n    exitPosition\n  );\n  const { x: targetX, y: targetY } = getAbsolutePosition(\n    targetView,\n    entryPosition\n  );\n\n  const connectPoints = getConnectPointsOfRectangleWithDirection();\n  const originalSourceDirections =\n    connectPoints.find((p) => p.x === exitPosition.x && p.y === exitPosition.y)\n      ?.d ?? DEFAULT_DIRECTIONS;\n  const originalTargetDirections =\n    connectPoints.find(\n      (p) => p.x === entryPosition.x && p.y === entryPosition.y\n    )?.d ?? DEFAULT_DIRECTIONS;\n  const sourceDirections = [...originalSourceDirections];\n  const targetDirections = [...originalTargetDirections];\n\n  if (sourceX < targetX) {\n    pull(sourceDirections, \"left\");\n    pull(targetDirections, \"right\");\n  } else {\n    pull(sourceDirections, \"right\");\n    pull(targetDirections, \"left\");\n  }\n\n  if (sourceY < targetY) {\n    pull(sourceDirections, \"top\");\n    pull(targetDirections, \"bottom\");\n  } else {\n    pull(sourceDirections, \"bottom\");\n    pull(targetDirections, \"top\");\n  }\n\n  const sourceDirection = sourceDirections[0] ?? originalSourceDirections[0];\n  const targetDirection = targetDirections[0] ?? originalTargetDirections[0];\n\n  const sourcePosition =\n    sourceDirection === \"left\" || sourceDirection === \"right\"\n      ? exitPosition.y\n      : exitPosition.x;\n  const targetPosition =\n    targetDirection === \"left\" || targetDirection === \"right\"\n      ? entryPosition.y\n      : entryPosition.x;\n\n  return getPolyLinePoints(\n    nodeViewToNodeRect(sourceView, DEFAULT_NODE_PADDING_FOR_SMART_LINES),\n    nodeViewToNodeRect(targetView, DEFAULT_NODE_PADDING_FOR_SMART_LINES),\n    sourceDirection,\n    targetDirection,\n    sourcePosition,\n    targetPosition\n  );\n}\n\nexport function simplifyVertices(\n  exitPoint: NodePosition,\n  vertices: NodePosition[],\n  entryPoint: NodePosition\n): NodePosition[] {\n  // Simplify the vertices, ignore all vertices that its previous and next points are on the same axis\n  // E.g, ignore two vertices of index 1 and index 3 for the following line.\n  //  0---1---2\n  //          |\n  //          3\n  //          |\n  //          4\n  const simplifiedVertices: NodePosition[] = [];\n  let prev = exitPoint;\n  let prevDirection: \"ns\" | \"ew\" | undefined;\n  let index = 0;\n  while (index < vertices.length) {\n    const vertex = vertices[index];\n    const isHorizontal = vertex.x !== prev.x;\n    const isVertical = vertex.y !== prev.y;\n    if (isHorizontal || isVertical) {\n      const direction = isHorizontal ? \"ew\" : \"ns\";\n      if (direction !== prevDirection) {\n        const next =\n          index === vertices.length - 1 ? entryPoint : vertices[index + 1];\n        const isHorizontalNext = next.x !== vertex.x;\n        const isVerticalNext = next.y !== vertex.y;\n        if (isHorizontalNext || isVerticalNext) {\n          const nextDirection = isHorizontalNext ? \"ew\" : \"ns\";\n          if (direction !== nextDirection) {\n            prevDirection = direction;\n            simplifiedVertices.push(vertex);\n            prev = vertex;\n          }\n        }\n      }\n    }\n    index++;\n  }\n\n  return simplifiedVertices;\n}\n\nfunction getDefaultPosition(\n  sourceView: NodeView,\n  targetView: NodeView\n): NodePosition {\n  if (targetView.y + targetView.height < sourceView.y) {\n    return { x: 0.5, y: 1 };\n  }\n  if (targetView.y > sourceView.y + sourceView.height) {\n    return { x: 0.5, y: 0 };\n  }\n  return targetView.x < sourceView.x ? { x: 1, y: 0.5 } : { x: 0, y: 0.5 };\n}\n\nfunction getAbsolutePosition(view: NodeView, position: NodePosition) {\n  const halfPadding = DEFAULT_NODE_PADDING_FOR_SMART_LINES / 2;\n  return {\n    x:\n      view.x -\n      halfPadding +\n      position.x * (view.width + DEFAULT_NODE_PADDING_FOR_SMART_LINES),\n    y:\n      view.y -\n      halfPadding +\n      position.y * (view.height + DEFAULT_NODE_PADDING_FOR_SMART_LINES),\n  };\n}\n\nfunction getDefaultAbsolutePosition(\n  sourceView: NodePosition,\n  targetView: NodeView,\n  flip?: boolean\n): NodePosition {\n  let xAxis: \"x\" | \"y\";\n  let yAxis: \"x\" | \"y\";\n  let xSize: \"width\" | \"height\";\n  let ySize: \"width\" | \"height\";\n  if (flip) {\n    xAxis = \"y\";\n    yAxis = \"x\";\n    xSize = \"height\";\n    ySize = \"width\";\n  } else {\n    xAxis = \"x\";\n    yAxis = \"y\";\n    xSize = \"width\";\n    ySize = \"height\";\n  }\n  let position: NodePosition | undefined;\n  if (targetView[yAxis] + targetView[ySize] < sourceView[yAxis]) {\n    position = { [xAxis]: 0.5, [yAxis]: 1 } as unknown as NodePosition;\n  }\n  if (targetView[yAxis] > sourceView[yAxis]) {\n    position = { [xAxis]: 0.5, [yAxis]: 0 } as unknown as NodePosition;\n  }\n  if (position) {\n    return getAbsolutePosition(targetView, position);\n  }\n\n  const xPosition = targetView[xAxis] < sourceView[xAxis] ? 1 : 0;\n\n  return {\n    [xAxis]:\n      targetView[xAxis] -\n      DEFAULT_NODE_PADDING_FOR_SMART_LINES / 2 +\n      xPosition * (targetView[xSize] + DEFAULT_NODE_PADDING_FOR_SMART_LINES),\n    [yAxis]: sourceView[yAxis],\n  } as unknown as NodePosition;\n}\n\nfunction fitEndpointAndDirection(\n  view: NodeView,\n  oppositeView: NodeView,\n  vertices: NodePosition[],\n  prefer: BiDirection\n): { point: NodePosition; direction: BiDirection } {\n  let point: NodePosition;\n  let direction: BiDirection;\n\n  let xAxis: \"x\" | \"y\";\n  let yAxis: \"x\" | \"y\";\n  let xSize: \"width\" | \"height\";\n  let ySize: \"width\" | \"height\";\n  let nsDirection: BiDirection;\n  let ewDirection: BiDirection;\n  if (prefer === \"ns\") {\n    xAxis = \"x\";\n    yAxis = \"y\";\n    xSize = \"width\";\n    ySize = \"height\";\n    nsDirection = \"ns\";\n    ewDirection = \"ew\";\n  } else {\n    xAxis = \"y\";\n    yAxis = \"x\";\n    xSize = \"height\";\n    ySize = \"width\";\n    nsDirection = \"ew\";\n    ewDirection = \"ns\";\n  }\n  const vertex = vertices[0];\n\n  if (\n    vertex[xAxis] >= view[xAxis] &&\n    vertex[xAxis] <= view[xAxis] + view[xSize]\n  ) {\n    if (vertex[yAxis] > view[yAxis] + view[ySize]) {\n      point = {\n        [xAxis]: vertex[xAxis],\n        [yAxis]: view[yAxis] + view[ySize],\n      } as unknown as NodePosition;\n      direction = nsDirection;\n    } else if (vertex[yAxis] < view[yAxis]) {\n      point = {\n        [xAxis]: vertex[xAxis],\n        [yAxis]: view[yAxis],\n      } as unknown as NodePosition;\n      direction = nsDirection;\n    } else {\n      const nextVertex = vertices[1] ?? oppositeView;\n      point = {\n        [xAxis]: vertex[xAxis],\n        [yAxis]:\n          nextVertex[yAxis] < vertex[yAxis]\n            ? vertex[yAxis]\n            : view[yAxis] + view[ySize],\n      } as unknown as NodePosition;\n      direction = nsDirection;\n    }\n  } else {\n    if (vertex[yAxis] < view[yAxis]) {\n      point = {\n        [xAxis]: view[xAxis] + view[xSize] / 2,\n        [yAxis]: view[yAxis],\n      } as unknown as NodePosition;\n      direction = nsDirection;\n    } else if (vertex[yAxis] > view[yAxis] + view[ySize]) {\n      point = {\n        [xAxis]: view[xAxis] + view[xSize] / 2,\n        [yAxis]: view[yAxis] + view[ySize],\n      } as unknown as NodePosition;\n      direction = nsDirection;\n    } else if (vertex[xAxis] < view[xAxis]) {\n      point = {\n        [xAxis]: view[xAxis],\n        [yAxis]: vertex[yAxis],\n      } as unknown as NodePosition;\n      direction = ewDirection;\n    } else {\n      point = {\n        [xAxis]: view[xAxis] + view[xSize],\n        [yAxis]: vertex[yAxis],\n      } as unknown as NodePosition;\n      direction = ewDirection;\n    }\n  }\n  return { point, direction: direction };\n}\n","import type { NodePosition } from \"../../../diagram/interfaces\";\nimport type { NodeConnectPoint } from \"../../../draw-canvas/interfaces\";\n\n//  *--*--*--*--*\n//  |           |\n//  *           *\n//  |           |\n//  *    Rect   *\n//  |           |\n//  *           *\n//  |           |\n//  *--*--*--*--*\nconst RectangleRelativeConnectPointsWithDirection: ReadonlyArray<NodeConnectPoint> =\n  [\n    {\n      x: 0,\n      y: 0,\n      d: [\"top\", \"left\"],\n    },\n    { x: 0.5, y: 0, d: [\"top\"] },\n    {\n      x: 1,\n      y: 0,\n      d: [\"top\", \"right\"],\n    },\n    { x: 0, y: 0.5, d: [\"left\"] },\n    { x: 1, y: 0.5, d: [\"right\"] },\n    {\n      x: 0,\n      y: 1,\n      d: [\"bottom\", \"left\"],\n    },\n    { x: 0.5, y: 1, d: [\"bottom\"] },\n    {\n      x: 1,\n      y: 1,\n      d: [\"bottom\", \"right\"],\n    },\n  ];\n\nconst RectangleRelativeConnectPoints: ReadonlyArray<NodePosition> =\n  RectangleRelativeConnectPointsWithDirection.map((p) => ({ x: p.x, y: p.y }));\n\nexport function getConnectPointsOfRectangleWithDirection() {\n  return RectangleRelativeConnectPointsWithDirection;\n}\n\nexport function getConnectPointsOfRectangle() {\n  return RectangleRelativeConnectPoints;\n}\n","import React, { useEffect, useRef, useState } from \"react\";\nimport type { ActiveTarget } from \"../../draw-canvas/interfaces\";\nimport { sameTarget } from \"../../draw-canvas/processors/sameTarget\";\n\nexport interface UseActiveTargetOptions {\n  rootRef: React.RefObject<SVGGElement>;\n  activeTarget?: ActiveTarget | null;\n  onActiveTargetChange(target: ActiveTarget | null): void;\n}\n\nexport type UseActiveTargetResult = ActiveTarget | null;\n\nexport function useActiveTarget({\n  rootRef,\n  activeTarget: _activeTarget,\n  onActiveTargetChange,\n}: UseActiveTargetOptions): UseActiveTargetResult {\n  const newActiveTarget = _activeTarget ?? null;\n  const [activeTarget, setActiveTarget] = useState<ActiveTarget | null>(\n    newActiveTarget\n  );\n\n  useEffect(() => {\n    setActiveTarget((previous) =>\n      sameTarget(previous, newActiveTarget) ? previous : newActiveTarget\n    );\n  }, [newActiveTarget]);\n\n  const activeTargetChangeInitialized = useRef(false);\n  useEffect(() => {\n    if (!activeTargetChangeInitialized.current) {\n      activeTargetChangeInitialized.current = true;\n      return;\n    }\n    onActiveTargetChange(activeTarget);\n  }, [activeTarget, onActiveTargetChange]);\n\n  useEffect(() => {\n    if (!activeTarget) {\n      return;\n    }\n    const resetActiveTarget = (e: MouseEvent) => {\n      const path = e.composedPath();\n      const rootIndex = path.indexOf(rootRef.current!);\n      // Reset active target to null when clicking outside of the cells container,\n      // Or inside the cells container but not on any cell.\n      if (rootIndex <= 0) {\n        setActiveTarget(null);\n      }\n    };\n    document.addEventListener(\"click\", resetActiveTarget);\n    return () => {\n      document.removeEventListener(\"click\", resetActiveTarget);\n    };\n  }, [activeTarget, rootRef]);\n\n  return activeTarget;\n}\n","import type { AlignOrigin, NormalizedAlignOrigin } from \"../interfaces\";\n\nconst KeywordMap = new Map([\n  [\"center\", 0.5],\n  [\"left\", 0],\n  [\"right\", 1],\n  [\"top\", 0],\n  [\"bottom\", 1],\n]);\n\nexport function normalizeAlignOrigin(\n  alignOrigin: AlignOrigin | undefined\n): NormalizedAlignOrigin {\n  const origin = alignOrigin ?? [0.5, 0.5];\n  return [\n    normalizeAlignAxis(origin[0], \"x\"),\n    normalizeAlignAxis(origin[1], \"y\"),\n  ];\n}\n\nfunction normalizeAlignAxis(value: string | number, axis: \"x\" | \"y\"): number {\n  if (typeof value === \"string\") {\n    const newX = KeywordMap.get(value);\n    if (newX !== undefined) {\n      return newX;\n    }\n    const matches = value.match(/^(-?\\d+(?:\\.\\d+)?)%$/);\n    if (matches) {\n      return Number(matches[1]) / 100;\n    }\n    // eslint-disable-next-line no-console\n    console.error(\"Unexpected align origin %s:\", axis, value);\n  } else if (typeof value === \"number\") {\n    return value;\n  } else {\n    // eslint-disable-next-line no-console\n    console.error(\n      \"Unexpected align origin %s, expected %s, received %s:\",\n      axis,\n      \"string | number\",\n      typeof value,\n      value\n    );\n  }\n\n  return 0.5;\n}\n","import { useCallback, useEffect, useRef, useState } from \"react\";\nimport type { ZoomBehavior } from \"d3-zoom\";\nimport type {\n  Cell,\n  LayoutOptions,\n  LayoutOptionsForce,\n  LayoutOptionsDagre,\n  LayoutType,\n  NodeId,\n  NodeView,\n} from \"../../draw-canvas/interfaces\";\nimport type { FullRectTuple, RangeTuple } from \"../../diagram/interfaces\";\nimport { useAutoCenter } from \"./useAutoCenter\";\nimport {\n  isNodeCell,\n  isNodeOrAreaDecoratorCell,\n  isNodeOrEdgeCell,\n} from \"../../draw-canvas/processors/asserts\";\nimport {\n  SYMBOL_FOR_LAYOUT_INITIALIZED,\n  SYMBOL_FOR_SIZE_INITIALIZED,\n} from \"../../draw-canvas/constants\";\nimport type { DrawCanvasAction } from \"../../draw-canvas/reducers/interfaces\";\nimport { forceLayout } from \"./forceLayout\";\nimport { dagreLayout } from \"./dagreLayout\";\nimport { normalizeAlignOrigin } from \"../../draw-canvas/processors/normalizeAlignOrigin\";\n\nexport interface UseLayoutOptions {\n  layout: LayoutType;\n  layoutOptions?: LayoutOptions;\n  rootRef: React.RefObject<SVGSVGElement>;\n  cells: Cell[];\n  zoomable?: boolean;\n  zoomer: ZoomBehavior<SVGSVGElement, unknown>;\n  scaleRange: RangeTuple;\n  layoutKey: number;\n  allowEdgeToArea?: boolean;\n  autoCenterWhenCellsChange?: boolean;\n  dispatch: (value: DrawCanvasAction) => void;\n}\n\nexport function useLayout({\n  layout,\n  layoutOptions,\n  rootRef,\n  cells,\n  zoomable,\n  zoomer,\n  scaleRange,\n  layoutKey,\n  allowEdgeToArea,\n  autoCenterWhenCellsChange,\n  dispatch,\n}: UseLayoutOptions) {\n  const [layoutInitialized, setLayoutInitialized] = useState(\n    layout !== \"force\" && layout !== \"dagre\"\n  );\n\n  const layoutKeyRef = useRef(layoutKey);\n\n  const getNextLayoutKey = useCallback(() => {\n    return ++layoutKeyRef.current;\n  }, []);\n\n  const [centered, setCentered] = useAutoCenter({\n    rootRef,\n    layoutInitialized,\n    cells,\n    zoomable,\n    zoomer,\n    scaleRange,\n    autoCenterWhenCellsChange,\n  });\n\n  const previousLayoutRef = useRef<Cell[] | null>(null);\n\n  useEffect(() => {\n    // Wait for all nodes to be size-initialized before layout.\n    if (\n      cells.some(\n        (cell) => isNodeCell(cell) && !cell[SYMBOL_FOR_SIZE_INITIALIZED]\n      ) ||\n      // Skip layout if no cells.\n      cells.length === 0\n    ) {\n      return;\n    }\n\n    if (layout !== \"force\" && layout !== \"dagre\") {\n      setLayoutInitialized(true);\n      return;\n    }\n\n    // DO NOT re-layout if layout key mismatched.\n    // DO NOT re-layout if nodes and edges not changed.\n    if (\n      layoutKeyRef.current !== layoutKey ||\n      isSameArray(previousLayoutRef.current, cells.filter(isNodeOrEdgeCell))\n    ) {\n      // Layout key mismatch happens when this effect is performed after\n      // update-node-size dispatched but not yet applied.\n      // If didn't ignore mismatched layout, it will cause the update-cells\n      // action overwrites those update-node-size actions.\n      return;\n    }\n\n    let getNodeView: (id: NodeId) => NodeView;\n    let nodePaddings: FullRectTuple;\n\n    if (layout === \"force\") {\n      ({ getNodeView, nodePaddings } = forceLayout({\n        cells,\n        layoutOptions: layoutOptions as LayoutOptionsForce,\n        allowEdgeToArea,\n      }));\n    } else {\n      ({ getNodeView, nodePaddings } = dagreLayout({\n        cells,\n        layoutOptions: layoutOptions as LayoutOptionsDagre,\n        allowEdgeToArea,\n      }));\n    }\n\n    const alignOrigin = normalizeAlignOrigin(\n      (layoutOptions as LayoutOptionsForce | LayoutOptionsDagre)?.alignOrigin\n    );\n\n    const newCells: Cell[] = cells.map((cell) => {\n      if (\n        (allowEdgeToArea && isNodeOrAreaDecoratorCell(cell)) ||\n        isNodeCell(cell)\n      ) {\n        const nodeView = getNodeView(cell.id);\n        return {\n          ...cell,\n          view: {\n            ...cell.view,\n            x: nodeView.x! - nodeView.width * alignOrigin[0] + nodePaddings[3],\n            y: nodeView.y! - nodeView.height * alignOrigin[1] + nodePaddings[0],\n          },\n          [SYMBOL_FOR_LAYOUT_INITIALIZED]: true,\n        };\n      }\n      return cell;\n    });\n    previousLayoutRef.current = newCells.filter(isNodeOrEdgeCell);\n\n    dispatch({ type: \"update-cells\", payload: newCells });\n    // setCentered(false);\n    setLayoutInitialized(true);\n  }, [cells, dispatch, layout, layoutKey, layoutOptions /* , setCentered */]);\n\n  return { centered, setCentered, getNextLayoutKey };\n}\n\nfunction isSameArray<T = unknown>(a: T[] | null, b: T[]): boolean {\n  return a?.length === b.length && a.every((v, i) => v === b[i]);\n}\n","import React, { useEffect, useState } from \"react\";\nimport { select } from \"d3-selection\";\nimport { ZoomTransform, type ZoomBehavior } from \"d3-zoom\";\nimport type { RangeTuple } from \"../../diagram/interfaces\";\nimport { SYMBOL_FOR_SIZE_INITIALIZED } from \"../../draw-canvas/constants\";\nimport type { Cell } from \"../../draw-canvas/interfaces\";\nimport {\n  isDecoratorCell,\n  isNodeCell,\n} from \"../../draw-canvas/processors/asserts\";\nimport { transformToCenter } from \"../../draw-canvas/processors/transformToCenter\";\n\nexport interface UseAutoCenterOptions {\n  rootRef: React.RefObject<SVGSVGElement>;\n  cells: Cell[];\n  layoutInitialized: boolean;\n  zoomable?: boolean;\n  zoomer: ZoomBehavior<SVGSVGElement, unknown>;\n  scaleRange: RangeTuple;\n  autoCenterWhenCellsChange?: boolean;\n}\n\nexport type UseAutoCenterResult = [\n  centered: boolean,\n  setCentered: React.Dispatch<React.SetStateAction<boolean>>,\n];\n\nexport function useAutoCenter({\n  rootRef,\n  cells,\n  layoutInitialized,\n  zoomable,\n  zoomer,\n  scaleRange,\n  autoCenterWhenCellsChange,\n}: UseAutoCenterOptions): UseAutoCenterResult {\n  const [centered, setCentered] = useState(false);\n\n  useEffect(() => {\n    // Reset auto centering when nodes and decorators are all removed,\n    // or when cells change and autoCenterWhenCellsChange is enabled.\n    if (\n      !cells.some((cell) => isNodeCell(cell) || isDecoratorCell(cell)) ||\n      autoCenterWhenCellsChange\n    ) {\n      setCentered(false);\n    }\n  }, [cells, autoCenterWhenCellsChange]);\n\n  useEffect(() => {\n    const root = rootRef.current;\n    if (\n      !root ||\n      !layoutInitialized ||\n      centered ||\n      !cells.some((cell) => isNodeCell(cell) || isDecoratorCell(cell)) ||\n      cells.some(\n        (cell) => isNodeCell(cell) && !cell[SYMBOL_FOR_SIZE_INITIALIZED]\n      )\n    ) {\n      return;\n    }\n    const { k, x, y } = transformToCenter(cells, {\n      canvasWidth: root.clientWidth,\n      canvasHeight: root.clientHeight,\n      scaleRange: zoomable ? scaleRange : undefined,\n    });\n    // istanbul ignore next\n    if (process.env.NODE_ENV !== \"test\") {\n      // jsdom doesn't support svg baseVal yet.\n      // https://github.com/jsdom/jsdom/issues/2531\n      zoomer.transform(select(root), new ZoomTransform(k, x, y));\n    }\n    setCentered(true);\n  }, [\n    cells,\n    centered,\n    layoutInitialized,\n    rootRef,\n    scaleRange,\n    zoomable,\n    zoomer,\n  ]);\n\n  return [centered, setCentered];\n}\n","import { useMemo } from \"react\";\nimport {\n  __secret_internals,\n  checkIfByTransform,\n  checkIfOfComputed,\n} from \"@next-core/runtime\";\nimport { findIndex, isUndefined, omitBy } from \"lodash\";\nimport type {\n  Cell,\n  ComputedEdgeLineConf,\n  ComputedLineConnecterConf,\n  EdgeCell,\n  EdgeLineConf,\n  LineConnecterConf,\n  LineMarker,\n} from \"../../draw-canvas/interfaces\";\nimport { isEdgeCell } from \"../../draw-canvas/processors/asserts\";\nimport {\n  DEFAULT_LINE_STROKE_COLOR,\n  DEFAULT_LINE_STROKE_WIDTH,\n  DEFAULT_LINE_INTERACT_STROKE_WIDTH,\n  DEFAULT_LINE_INTERACT_SHOW_START_ARROW,\n  DEFAULT_LINE_INTERACT_SHOW_END_ARROW,\n  DEFAULT_LINE_INTERACT_ANIMATE_DURATION,\n} from \"../../draw-canvas/constants\";\nimport { LineMarkerConf } from \"../../diagram/interfaces\";\n\nexport interface UseLineMarkersOptions {\n  cells: Cell[];\n  defaultEdgeLines: EdgeLineConf[] | undefined;\n  markerPrefix: string;\n  lineConnector?: LineConnecterConf | boolean;\n}\n\nexport function useLineMarkers({\n  cells,\n  defaultEdgeLines,\n  markerPrefix,\n  lineConnector,\n}: UseLineMarkersOptions): {\n  lineConfMap: WeakMap<EdgeCell, ComputedEdgeLineConf>;\n  lineConnectorConf: ComputedLineConnecterConf | null;\n  markers: LineMarker[];\n} {\n  return useMemo(() => {\n    // Always put the default stroke marker at the first position,\n    // since the connecting line will use it.\n    const markers: LineMarker[] = [\n      {\n        strokeColor: DEFAULT_LINE_STROKE_COLOR,\n        markerType: \"arrow\",\n      },\n    ];\n\n    let lineConnectorConf: ComputedLineConnecterConf | null = null;\n    if (lineConnector) {\n      lineConnectorConf = {\n        ...getDefaultLineConf(),\n        editingStrokeColor: \"var(--palette-blue-5)\",\n        ...omitBy(lineConnector === true ? {} : lineConnector, isUndefined),\n      } as ComputedLineConnecterConf;\n      const lineMarkers: LineMarkerConf[] = getMarkers(lineConnectorConf);\n      for (const marker of lineMarkers) {\n        const { placement, type: _type } = marker;\n        const type = _type ?? \"arrow\";\n        const markerIndex = addMarker(\n          {\n            strokeColor: lineConnectorConf.strokeColor,\n            markerType: type,\n          },\n          markers\n        );\n        const editingMarkerIndex = addMarker(\n          {\n            strokeColor: lineConnectorConf.editingStrokeColor,\n            markerType: type,\n          },\n          markers\n        );\n        if (placement === \"start\") {\n          lineConnectorConf.$markerStartUrl = `url(#${markerPrefix}${markerIndex})`;\n          lineConnectorConf.$editingStartMarkerUrl = `url(#${markerPrefix}${editingMarkerIndex})`;\n        } else {\n          lineConnectorConf.$markerEndUrl = `url(#${markerPrefix}${markerIndex})`;\n          lineConnectorConf.$editingEndMarkerUrl = `url(#${markerPrefix}${editingMarkerIndex})`;\n        }\n      }\n    }\n\n    const map = new WeakMap<EdgeCell, ComputedEdgeLineConf>();\n    for (const cell of cells) {\n      if (isEdgeCell(cell)) {\n        const computedLineConf =\n          (Array.isArray(defaultEdgeLines)\n            ? __secret_internals.legacyDoTransform(\n                { edge: cell },\n                defaultEdgeLines.find((item) =>\n                  checkIfByTransform(item, { edge: cell })\n                )\n              )\n            : (\n                __secret_internals.legacyDoTransform(\n                  { edge: cell },\n                  defaultEdgeLines\n                ) as EdgeLineConf[]\n              )?.find((item) => checkIfOfComputed(item))) ?? {};\n        const lineConf = {\n          ...getDefaultLineConf(),\n          ...omitBy(computedLineConf, isUndefined),\n          ...omitBy(cell.view, isUndefined),\n        } as ComputedEdgeLineConf;\n        if (lineConf.parallelGap === undefined) {\n          lineConf.parallelGap = lineConf.interactStrokeWidth;\n        }\n\n        const lineMarkers: LineMarkerConf[] = getMarkers(lineConf);\n\n        for (const marker of lineMarkers) {\n          const { placement, type: _type } = marker;\n          const type = _type ?? \"arrow\";\n          const markerIndex = addMarker(\n            {\n              strokeColor: lineConf.strokeColor,\n              markerType: type,\n            },\n            markers\n          );\n          if (placement === \"start\") {\n            lineConf.$markerStartUrl = `url(#${markerPrefix}${markerIndex})`;\n          } else {\n            lineConf.$markerEndUrl = `url(#${markerPrefix}${markerIndex})`;\n          }\n        }\n        map.set(cell, lineConf);\n      }\n    }\n    return { lineConfMap: map, lineConnectorConf, markers };\n  }, [cells, defaultEdgeLines, lineConnector, markerPrefix]);\n}\nexport function getMarkers(lineConf: ComputedEdgeLineConf): LineMarkerConf[] {\n  let lineMarkers: LineMarkerConf[] = [];\n  if (lineConf.markers) {\n    lineMarkers = lineConf.markers;\n  } else {\n    if (lineConf.showStartArrow) {\n      lineMarkers.push({\n        type: \"arrow\",\n        placement: \"start\",\n      });\n    }\n    if (lineConf.showEndArrow) {\n      lineMarkers.push({\n        type: \"arrow\",\n        placement: \"end\",\n      });\n    }\n  }\n  return lineMarkers;\n}\nfunction addMarker(marker: LineMarker, markers: LineMarker[]): number {\n  let markerIndex = findIndex(markers, marker);\n  if (markerIndex === -1) {\n    markerIndex = markers.push(marker) - 1;\n  }\n  return markerIndex;\n}\n\nfunction getDefaultLineConf(): EdgeLineConf {\n  return {\n    type: \"straight\",\n    dashed: false,\n    strokeColor: DEFAULT_LINE_STROKE_COLOR,\n    strokeWidth: DEFAULT_LINE_STROKE_WIDTH,\n    interactStrokeWidth: DEFAULT_LINE_INTERACT_STROKE_WIDTH,\n    showStartArrow: DEFAULT_LINE_INTERACT_SHOW_START_ARROW,\n    showEndArrow: DEFAULT_LINE_INTERACT_SHOW_END_ARROW,\n    animate: {\n      useAnimate: false,\n      duration: DEFAULT_LINE_INTERACT_ANIMATE_DURATION,\n    },\n  };\n}\n","import { useMemo } from \"react\";\nimport type { Cell, LayoutType } from \"../../draw-canvas/interfaces\";\nimport { isNodeCell } from \"../../draw-canvas/processors/asserts\";\nimport {\n  SYMBOL_FOR_LAYOUT_INITIALIZED,\n  SYMBOL_FOR_SIZE_INITIALIZED,\n} from \"../../draw-canvas/constants\";\n\nexport interface UseReadyOptions {\n  cells: Cell[];\n  layout: LayoutType;\n  centered: boolean;\n}\n\nexport function useReady({ cells, layout, centered }: UseReadyOptions) {\n  const ready = useMemo(\n    () =>\n      centered &&\n      cells.every(\n        (cell) =>\n          !isNodeCell(cell) ||\n          (cell[SYMBOL_FOR_SIZE_INITIALIZED] &&\n            ((layout !== \"force\" && layout !== \"dagre\") ||\n              cell[SYMBOL_FOR_LAYOUT_INITIALIZED]))\n      ),\n    [cells, centered, layout]\n  );\n  return ready;\n}\n","import React, { useEffect, useMemo, useState } from \"react\";\nimport { select } from \"d3-selection\";\nimport { zoom, type ZoomBehavior } from \"d3-zoom\";\nimport type { RangeTuple, TransformLiteral } from \"../../diagram/interfaces\";\nimport {\n  DEFAULT_SCALE_RANGE_MIN,\n  DEFAULT_SCALE_RANGE_MAX,\n} from \"../../draw-canvas/constants\";\nimport type { ActiveTarget } from \"../../draw-canvas/interfaces\";\n\nexport interface UseZoomOptions {\n  rootRef: React.RefObject<SVGSVGElement>;\n  zoomable?: boolean;\n  scrollable?: boolean;\n  pannable?: boolean;\n  draggable?: boolean;\n  ctrlDraggable?: boolean;\n  scaleRange?: RangeTuple;\n  onSwitchActiveTarget?(target: ActiveTarget | null): void;\n}\n\nexport interface UseZoomResult {\n  grabbing: boolean;\n  transform: TransformLiteral;\n  scaleRange: RangeTuple;\n  zoomer: ZoomBehavior<SVGSVGElement, unknown>;\n}\n\nexport function useZoom({\n  rootRef,\n  zoomable,\n  scrollable,\n  pannable,\n  draggable,\n  ctrlDraggable,\n  scaleRange: _scaleRange,\n  onSwitchActiveTarget,\n}: UseZoomOptions): UseZoomResult {\n  const [grabbing, setGrabbing] = useState(false);\n  const [transform, setTransform] = useState<TransformLiteral>({\n    k: 1,\n    x: 0,\n    y: 0,\n  });\n\n  const scaleRange = useMemo(\n    () =>\n      _scaleRange ??\n      ([DEFAULT_SCALE_RANGE_MIN, DEFAULT_SCALE_RANGE_MAX] as RangeTuple),\n    [_scaleRange]\n  );\n\n  const zoomer = useMemo(() => zoom<SVGSVGElement, unknown>(), []);\n\n  // istanbul ignore next: d3-zoom currently hard to test\n  useEffect(() => {\n    let moved = false;\n    zoomer\n      .scaleExtent(zoomable ? scaleRange : [1, 1])\n      .on(\"start\", () => {\n        moved = false;\n        setGrabbing(true);\n      })\n      .on(\"zoom\", (e: { transform: TransformLiteral }) => {\n        moved = true;\n        setTransform(e.transform);\n      })\n      .on(\"end\", () => {\n        setGrabbing(false);\n        if (!moved) {\n          onSwitchActiveTarget?.(null);\n        }\n      })\n      .filter(\n        (event) =>\n          (event.type === \"wheel\" ||\n            (ctrlDraggable ? draggable || event.ctrlKey : !event.ctrlKey)) &&\n          !event.button\n      );\n  }, [\n    onSwitchActiveTarget,\n    scaleRange,\n    zoomable,\n    zoomer,\n    ctrlDraggable,\n    draggable,\n  ]);\n\n  useEffect(() => {\n    if (ctrlDraggable) {\n      const onContextMenu = (e: MouseEvent) => {\n        if (e.ctrlKey) {\n          e.preventDefault();\n        }\n      };\n      document.addEventListener(\"contextmenu\", onContextMenu, true);\n      return () => {\n        document.removeEventListener(\"contextmenu\", onContextMenu, true);\n      };\n    }\n  }, [ctrlDraggable]);\n\n  // istanbul ignore next: d3-zoom currently hard to test\n  useEffect(() => {\n    const root = rootRef.current;\n    if (!root) {\n      return;\n    }\n\n    const rootSelection = select(root);\n\n    const unsetZoom = () => {\n      rootSelection\n        .on(\".zoom\", null)\n        .on(\".zoom.custom\", null)\n        .on(\"wheel\", null);\n    };\n\n    if (!(zoomable || scrollable || pannable)) {\n      unsetZoom();\n      return;\n    }\n\n    if (zoomable || scrollable) {\n      // Do not override default d3 zoom handler.\n      // Only handles *panning*\n      rootSelection.on(\n        \"wheel.zoom.custom\",\n        (e: WheelEvent & { wheelDeltaX: number; wheelDeltaY: number }) => {\n          // Mac OS trackpad pinch event is emitted as a wheel.zoom and d3.event.ctrlKey set to true\n          if (!e.ctrlKey) {\n            // Stop immediate propagation for default d3 zoom handler\n            e.stopImmediatePropagation();\n            if (scrollable) {\n              e.preventDefault();\n              zoomer.translateBy(\n                rootSelection,\n                e.wheelDeltaX / 5,\n                e.wheelDeltaY / 5\n              );\n            }\n          }\n          // zoomer.scaleBy(rootSelection, Math.pow(2, defaultWheelDelta(e)))\n        }\n      );\n    }\n\n    rootSelection\n      .call(zoomer)\n      .on(\"wheel\", (e: WheelEvent) => {\n        e.preventDefault();\n      })\n      .on(\"dblclick.zoom\", null);\n\n    if ((!draggable && !ctrlDraggable) || !pannable) {\n      rootSelection.on(\"mousedown.zoom\", null);\n    }\n\n    if (!pannable) {\n      rootSelection\n        .on(\"touchstart.zoom\", null)\n        .on(\"touchmove.zoom\", null)\n        .on(\"touchend.zoom\", null);\n    }\n\n    return unsetZoom;\n  }, [\n    ctrlDraggable,\n    draggable,\n    pannable,\n    rootRef,\n    scrollable,\n    zoomable,\n    zoomer,\n  ]);\n\n  return { grabbing, transform, zoomer, scaleRange };\n}\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.zoom-bar{position:absolute;bottom:20px;right:20px;width:40px;scale:0.8}.zoom-slider,\n.center-button{width:100%;display:flex;align-items:center;border:1px solid var(--antd-background-color-base);border-radius:var(--larger-border-radius);box-shadow:var(--connected-overlay-shadow);background-color:var(--color-fill-bg-container-4)}.zoom-slider{height:140px;padding:8px 0;flex-direction:column}[role=\"button\"]{cursor:pointer}.center-button{justify-content:center;margin-bottom:8px;height:40px}.center-button:hover{border-color:var(--antd-btn-default-hover-border-color)}.center-button path{fill:var(--antd-link-hover-color)}.center-button:hover path{fill:var(--palette-blue-7)}.zoom-button{font-size:16px;line-height:0}.zoom-button svg{width:1em;height:1em;fill:var(--antd-link-hover-color)}.zoom-slider .ant-slider-vertical{padding-inline:5px}.zoom-slider .ant-slider-vertical .ant-slider-rail{width:2px}.zoom-slider .ant-slider-vertical .ant-slider-handle{width:6px;height:6px;inset-inline-start:3px}.zoom-slider .ant-slider .ant-slider-handle:hover::before,\n.zoom-slider .ant-slider .ant-slider-handle:focus::before,\n.zoom-slider .ant-slider .ant-slider-handle::before{width:10px;height:10px;inset-inline-start:-2px}.zoom-slider .ant-slider .ant-slider-handle:hover::after,\n.zoom-slider .ant-slider .ant-slider-handle:focus::after,\n.zoom-slider .ant-slider .ant-slider-handle::after{width:6px;height:6px;inset-block-start:0;inset-inline-start:0}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___.toString();\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../../../node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `*{box-sizing:border-box}:host{display:block;position:relative;overflow:hidden;--animation-dasharray:48;--stroke-dashedoffset:96;--stroke-dottedoffset:24;--dasharray:4;--dotted:1}:host,\n.root{width:100%;height:100%}:host([hidden]){display:none}.root{opacity:0}.root.ready{opacity:1}.root:focus{outline:none}@keyframes solidAnimation{to{stroke-dashoffset:0}}@keyframes dashedAnimation{0%{stroke-dashoffset:var(--stroke-dashedoffset)}to{stroke-dashoffset:0}}@keyframes dottedAnimation{0%{stroke-dashoffset:var(--stroke-dottedoffset)}to{stroke-dashoffset:0}}.solid-animation{stroke-dasharray:var(--solid-length);stroke-dashoffset:var(--solid-length);animation:solidAnimation var(--time) linear infinite}.dashed-animation{animation:dashedAnimation var(--time) linear infinite}.dotted-animation{animation:dottedAnimation var(--time) linear infinite}.decorator-area .area,\n.decorator-container .container{fill:rgba(119,141,195,0.1);stroke:none;stroke-width:0}.node,\n.decorator-text{overflow:visible}.cell.active .decorator-area .area,\n.cell.active .decorator-container .container,\n.cell:not(.read-only) .decorator-container .container:hover,\n.allowEdgeToArea .decorator-area .area:hover,\n.cell.active .line-active-bg{stroke:var(--palette-blue-5);stroke-dasharray:var(--dasharray);stroke-width:1}.container-active .decorator-container .container{stroke:var(--palette-blue-5);stroke-width:1}.cell:not(.read-only){-webkit-user-select:none;user-select:none}.resize-handle{cursor:nwse-resize;opacity:0}.resize-handle rect{fill:transparent;stroke:none}.resize-handle path{fill:none;stroke:var(--palette-gray-5);stroke-width:1.5}.cell.active .decorator-area .resize-handle,\n.decorator-area:hover .resize-handle,\n.decorator-container:hover .resize-handle{opacity:1}.connect-line{pointer-events:none}.connect-line:not(.connecting){display:none}.editing-line{pointer-events:none;stroke-dasharray:var(--dasharray);stroke-width:1}.editing-line:not(.editing){display:none}.line.dashed{stroke-dasharray:var(--dasharray)}.line.dotted{stroke-dasharray:var(--dotted)}.cell.active .decorator-text .text-container{outline:1px dashed var(--palette-blue-5)}.decorator-text .text-container{width:max-content;padding:0.5em}.decorator-text .text:focus{outline:none}.cell.faded{opacity:0.3}.cell.container-active{opacity:1}.cell .node{pointer-events:none}.cell .node > *{position:fixed;pointer-events:auto}.degraded{pointer-events:bounding-box}.degraded circle{fill:rgb(119,141,195)}.degraded text{text-anchor:middle;fill:var(--antd-text-color)}.cell.active .degraded circle,\n.cell.active .degraded text,\n.degraded:hover circle,\n.degraded:hover text{fill:var(--color-brand)}.decorator-container{--defaultSize:24px}.decorator-container .text-container{display:flex;align-items:center;justify-content:center;padding:0.5em;text-align:center;font-size:16px;background-color:rgba(119,141,195,0.6);overflow:hidden}.decorator-container .horizontal{height:max-content;width:100%}:is(.decorator-container .horizontal) .text{min-height:var(--defaultSize)}.decorator-container .vertical{width:max-content;height:100%;writing-mode:vertical-lr;text-orientation:upright;letter-spacing:4px}:is(.decorator-container .vertical) .text{min-width:var(--defaultSize)}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___.toString();\n"],"names":["findNodeOrAreaDecorator","cells","id","find","cell","isNodeOrAreaDecoratorCell","EdgeComponent","_ref","_pathRef$current","_pathRef$current$getT","edge","lineConfMap","active","setActiveEditableLine","useHoverStateContext","pathRef","useRef","sourceNode","useMemo","source","targetNode","target","lineConf","get","parallelGap","_edge$view","isStraightType","view","type","some","_cell$view","isEdgeCell","linePoints","x","getSmartLinePoints","line","fixedLineType","curveLine","curveType","useEffect","prev","lineType","lineCurveType","markerStart","markerEnd","lineMarkers","getMarkers","marker","placement","$markerStartUrl","$markerEndUrl","React","d","fill","stroke","strokeWidth","interactStrokeWidth","ref","className","classNames","dashed","dotted","animate","useAnimate","style","duration","DEFAULT_LINE_INTERACT_ANIMATE_DURATION","current","getTotalLength","call","strokeColor","NodeComponent","node","degraded","degradedNodeLabel","defaultNodeBricks","onResize","memoizedData","value","memoizedValue","setMemoizedValue","useState","isEqual","useDeepMemo","data","specifiedUseBrick","useBrick","observerRef","_defaultNodeBricks$fi","item","checkIfByTransform","label","String","__secret_internals","legacyDoTransform","refCallback","useCallback","element","prevObserver","disconnect","setTimeout","observer","ResizeObserver","offsetWidth","offsetHeight","observe","degradedRefCallBack","g","size","getBBox","width","height","ReactUseBrick","cx","cy","r","y","handleMouseDown","event","action","scale","layout","layoutOptions","activeTarget","onCellsMoving","onCellsMoved","onCellResizing","onCellResized","onSwitchActiveTarget","stopPropagation","targetIsActive","cellToTarget","activeCells","actives","filter","c","forEach","a","push","isContainerDecoratorCell","isNodeCell","containerId","includes","isAutoLayout","movableActiveCells","isDecoratorCell","length","snap","intermediateSnap","grid","object","snapToGrid","snapToObject","DEFAULT_SNAP_GRID_SIZE","distance","DEFAULT_SNAP_OBJECT_DISTANCE","normalizeSnapOptions","from","clientX","clientY","originals","map","position","center","getCenterPosition","firstOriginalPosition","previousPositions","_ref2","snapToObjectTargets","objectCells","moved","handleMove","e","finished","movement","getMovement","newPositions","xAlign","yAlign","xAlignCell","yAlignCell","altKey","_ref3","diffX","Infinity","diffY","snapMovement","snapToObjectDistance","xAlignFrom","yAlignFrom","xAlignTarget","yAlignTarget","xAlignToY","yAlignToX","dX","Math","abs","dY","ySnapped","halfHeight","halfWidth","snapToGridSize","firstNewPosition","round","snapToGridMovement","snapToGridDiffX","snapToGridDiffY","undefined","_ref4","_ref6","payloads","_ref5","index","decorator","guideLines","_ref7","onMouseMove","onMouseUp","document","removeEventListener","addEventListener","DecoratorArea","transform","readOnly","resizeHandleRef","resizeHandle","onMouseDown","k","DecoratorText","onDecoratorTextEditing","onDecoratorTextChange","text","currentLabel","setCurrentLabel","editingLabel","setEditingLabel","editingLabelInitialized","shouldEmitLabelChange","setShouldEmitLabelChange","handleEnableEdit","preventDefault","textContent","_ref$current","parentElement","clientWidth","clientHeight","focus","selectAllText","editing","handleInput","handleBlur","onDoubleClick","contentEditable","onInput","onBlur","range","createRange","selectNodeContents","selection","window","getSelection","removeAllRanges","addRange","DecoratorContainer","direction","textRef","recomputation","setRecomputation","titleForeignRect","setTitleForeignRect","uuidV4","_textRef$current","textParentEle","rect","isNoManualLayout","DecoratorComponent","SpecifiedComponent","console","error","computeContainerRect","minX","minY","maxX","maxY","n","isFinite","padding","CellComponent","dragNodeToContainerActive","unrelatedCells","allowEdgeToArea","onCellContextMenu","onCellClick","onNodeBrickResize","onCellMouseEnter","onCellMouseLeave","lineEditorState","smartConnectLineState","setSmartConnectLineState","onConnect","setLineEditorState","onChangeEdgeView","gRef","unrelated","sameTarget","containerRect","containCells","isEdgeSide","exitPosition","isEntry","entryPosition","handleContextMenu","handleCellClick","handleMouseEnter","handleMouseLeave","faded","onContextMenu","onClick","onMouseEnter","onMouseLeave","ConnectLineComponent","connectLineState","connectLineTo","setConnectLineTo","getConnectTo","offset","reset","capture","connecting","join","getNewLineVertices","control","newVertices","x1","y1","exitPoint","entryPoint","i","vertex","simplifyVertices","EditingLineComponent","options","activeEditableLine","hoverState","movedRef","diff","axis","original","otherPoints","_","snapDistance","point","newDiff","movementX","movementY","newConnectTo","vertices","handleBodyClick","body","_lineEditorState$edge","points","activePointIndex","lineSettings","pick","relativePoints","getEditingLinePoints","$editingStartMarkerUrl","$editingEndMarkerUrl","editingStrokeColor","HoverStateContext","rootRef","unsetHoverStateTimeoutRef","setHoverState","HELPER_IMAGE","HELPER_RADIUS","HELPER_BG_RADIUS","HALF_HELPER_RADIUS","LineConnectorComponent","disabled","unsetTimeout","clearTimeout","unsetActivePointIndex","unsetHoverState","available","targets","hasActiveEdge","DEFAULT_NODE_PADDING_FOR_SMART_LINES","halfPadding","pointerEvents","fillOpacity","ConnectPointComponent","key","getBoundingClientRect","originalPoint","left","top","handleMouseUp","xlinkHref","preserveAspectRatio","POINT_HELPER_IMAGE","ANCHORED_POINT_HELPER_IMAGE","VERTEX_HELPER_IMAGE","POINT_HELPER_BG_SIZE","LineEditorComponent","exitRef","entryRef","controlPointsRef","exit","entry","handleMouseDownFactory","handleStartMouseDown","handleEndMouseDown","controlPoints","_activeEditableLine$e","cursor","next","ns","ew","getControlPoints","controlElements","handlers","el","commonProps","_extends","SmartConnectLineComponent","sourceView","getConnectLinePoints","SYMBOL_FOR_SIZE_INITIALIZED","Symbol","for","SYMBOL_FOR_LAYOUT_INITIALIZED","DEFAULT_NODE_SIZE","DEFAULT_NODE_GAP","DEFAULT_AREA_WIDTH","DEFAULT_AREA_HEIGHT","DEFAULT_SCALE_RANGE_MIN","DEFAULT_SCALE_RANGE_MAX","DEFAULT_LINE_STROKE_COLOR","DEFAULT_LINE_STROKE_WIDTH","DEFAULT_LINE_INTERACT_STROKE_WIDTH","DEFAULT_LINE_INTERACT_SHOW_START_ARROW","DEFAULT_LINE_INTERACT_SHOW_END_ARROW","DEFAULT_DEGRADED_THRESHOLD","DEFAULT_NODE_PADDING_FOR_LINES","isInitialNodeCell","isNodeOrEdgeCell","isTextDecoratorCell","getUnrelatedCells","existedTargets","Set","add","has","nodesMap","Map","activeNodeIds","relatedNodeIds","set","handleKeyboard","keyCode","which","handleLasso","onLassoing","onLassoed","ctrlKey","button","x0","y0","handleNodeContainedChange","onContainerContainerChange","nodeCells","containerIds","p","v","nodePayloads","nodeCell","includeNodeFlag","payload","right","bottom","containerDecoratorCells","containerCell","containerLeft","containerRight","containerTop","containerBottom","containedChanges","_payload$containerCel","initializeCells","initialCells","defaultNodeSize","_cell$view2","b","every","targetA","targetB","transformToCenter","canvasWidth","canvasHeight","scaleRange","empty","max","min","updateCells","previousCells","reason","parent","isManualLayout","newCells","updateCandidates","shouldReCenter","previousSizeInitializedNodes","previousShouldCentered","previousNode","handled","downstreamNodeIds","parentNode","downstreamNodes","Boolean","rightMostNode","nextX","nextY","totalWidth","reduce","acc","maxWidth","maxHeight","positionedNodes","hasDecorators","getNodeView","without","dagreLayout","forceLayout","fixedPosition","updated","insertCellAfter","newCell","after","findLastIndex","slice","rootReducer","reducers","state","existedEdgeIndex","findIndex","matched","newState","move","layoutKey","Object","fromEntries","entries","props","xmlns","viewBox","ZoomBarComponent","shadowRoot","onZoomChange","onReCenter","currentTheme","useCurrentTheme","cache","createCache","zoomBarRef","tooltip","formatter","getPopupContainer","onZoomIn","onZoomOut","ConfigProvider","theme","algorithm","darkAlgorithm","defaultAlgorithm","StyleProvider","container","autoClear","hashPriority","role","CenterSVG","ZoomInSVG","Slider","step","vertical","included","onChange","ZoomOutSVG","nodePadding","dagreGraphOptions","rankdir","ranksep","edgesep","nodesep","nodePaddings","extractPartialRectTuple","graph","dagre","Graph","setGraph","setDefaultEdgeLabel","setNode","setEdge","collide","radiusDiff","strength","iterations","forceNodes","forceLinks","fx","fy","linkSimulation","forceLink","simulation","forceSimulation","force","forceX","forceY","forceManyBody","forceCollide","radius","sqrt","stop","tick","ceil","log","alphaMin","alphaDecay","manuallyTickToTheEnd","nodeViewToNodeRect","DEFAULT_DIRECTIONS","targetView","edgeView","_connectPoints$find","_connectPoints$find2","originalExit","originalEntry","getDirectLinePoints","firstVertex","lastVertex","exitDirection","entryDirection","getAbsolutePosition","possibleFirstNextPoint","getDefaultAbsolutePosition","prefer","fitEndpointAndDirection","possibleLastPreviousPoint","reverse","sourceX","sourceY","targetX","targetY","newLinePoints","unshift","getDefaultPosition","connectPoints","getConnectPointsOfRectangleWithDirection","originalSourceDirections","originalTargetDirections","sourceDirections","targetDirections","pull","sourceDirection","targetDirection","sourcePosition","targetPosition","getPolyLinePoints","simplifiedVertices","prevDirection","isHorizontal","isVertical","isHorizontalNext","isVerticalNext","flip","xAxis","yAxis","xSize","ySize","xPosition","oppositeView","nsDirection","ewDirection","nextVertex","RectangleRelativeConnectPointsWithDirection","RectangleRelativeConnectPoints","getConnectPointsOfRectangle","useActiveTarget","_activeTarget","onActiveTargetChange","newActiveTarget","setActiveTarget","previous","activeTargetChangeInitialized","resetActiveTarget","composedPath","indexOf","KeywordMap","normalizeAlignAxis","newX","matches","match","Number","useLayout","zoomable","zoomer","autoCenterWhenCellsChange","dispatch","layoutInitialized","setLayoutInitialized","layoutKeyRef","getNextLayoutKey","centered","setCentered","root","select","ZoomTransform","useAutoCenter","previousLayoutRef","alignOrigin","origin","normalizeAlignOrigin","nodeView","useLineMarkers","defaultEdgeLines","markerPrefix","lineConnector","markers","markerType","lineConnectorConf","getDefaultLineConf","omitBy","isUndefined","_type","markerIndex","addMarker","editingMarkerIndex","WeakMap","_secret_internals$le","computedLineConf","Array","isArray","checkIfOfComputed","showStartArrow","showEndArrow","useReady","useZoom","scrollable","pannable","draggable","ctrlDraggable","_scaleRange","grabbing","setGrabbing","setTransform","zoom","scaleExtent","on","rootSelection","unsetZoom","stopImmediatePropagation","translateBy","wheelDeltaX","wheelDeltaY","___CSS_LOADER_EXPORT___","module","toString"],"sourceRoot":""}