{"version":3,"file":"chunks/3233.19da547d.js","mappings":"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","sources":["webpack:///./src/diagram/ConnectLineComponent.tsx","webpack:///./src/diagram/LineComponent.tsx","webpack:///./src/diagram/LineLabelComponent.tsx","webpack:///./src/diagram/LineMaskComponent.tsx","webpack:///./src/diagram/NodeComponent.tsx","webpack:///./src/diagram/processors/findNodeBrick.ts","webpack:///./src/diagram/constants.ts","webpack:///./src/diagram/processors/adjustNodesSize.ts","webpack:///./src/diagram/processors/adjustNodesPosition.ts","webpack:///./src/diagram/processors/getRenderedEdges.ts","webpack:///./src/diagram/processors/getForceGraph.ts","webpack:///./src/diagram/hooks/useRenderedDiagram.ts","webpack:///./src/diagram/processors/getDagreGraph.ts","webpack:///./src/diagram/processors/getManualGraph.ts","webpack:///../../node_modules/@next-api-sdk/cmdb-sdk/dist/esm/api/cmdb/instance/postSearchV3.js","webpack:///../../node_modules/@next-api-sdk/cmdb-sdk/dist/esm/api/cmdb/instance/updateInstanceV2.js","webpack:///../../node_modules/@next-api-sdk/cmdb-sdk/dist/esm/api/cmdb/instance/createInstance.js","webpack:///./src/diagram/hooks/useUserView.ts","webpack:///./src/diagram/processors/createAsyncQueue.ts","webpack:///./src/diagram/processors/adjustLineLabels.ts","webpack:///./src/diagram/processors/getLineMaskRects.ts","webpack:///./src/diagram/processors/getRenderedLineLabels.ts","webpack:///./src/diagram/processors/getRenderedLines.ts","webpack:///./src/diagram/processors/handleKeyboard.ts","webpack:///./src/diagram/processors/handleNodesMouseDown.ts","webpack:///./src/diagram/processors/matchEdgeByFilter.ts","webpack:///./src/diagram/processors/normalizeLinesAndMarkers.ts","webpack:///./src/diagram/processors/sameTarget.ts","webpack:///./src/diagram/processors/transformToCenter.ts","webpack:///./src/diagram/styles.shadow.css"],"sourcesContent":["import React from \"react\";\nimport classNames from \"classnames\";\nimport type { ConnectLineState, PositionTuple } from \"./interfaces\";\nimport { MarkerComponent } from \"./MarkerComponent\";\n\nexport interface ConnectLineComponentProps {\n  connectLineState: ConnectLineState | null;\n  connectLineTo: PositionTuple;\n  markerPrefix: string;\n}\n\nexport function ConnectLineComponent({\n  connectLineState,\n  connectLineTo,\n  markerPrefix,\n}: ConnectLineComponentProps): JSX.Element {\n  return (\n    <svg\n      width=\"100%\"\n      height=\"100%\"\n      className={classNames(\"connect-line\", {\n        connecting:\n          !!connectLineState &&\n          // Do not show when the distance of mouse move is less than 5px\n          (connectLineTo[0] - connectLineState.from[0]) ** 2 +\n            (connectLineTo[1] - connectLineState.from[1]) ** 2 >\n            25,\n      })}\n    >\n      <defs>\n        <MarkerComponent\n          type=\"arrow\"\n          id={`${markerPrefix}connect-line`}\n          strokeColor={connectLineState?.options.strokeColor}\n        />\n      </defs>\n      <path\n        d={\n          connectLineState\n            ? `M${connectLineState.from.join(\" \")}L${connectLineTo.join(\" \")}`\n            : \"\"\n        }\n        fill=\"none\"\n        stroke={connectLineState?.options.strokeColor}\n        strokeWidth={connectLineState?.options.strokeWidth}\n        markerEnd={\n          connectLineState?.options.arrow\n            ? `url(#${markerPrefix}connect-line)`\n            : undefined\n        }\n      />\n    </svg>\n  );\n}\n","import React from \"react\";\nimport classNames from \"classnames\";\nimport type { LineTarget, RenderedLine, LineMaskRects } from \"./interfaces\";\n\nexport interface LineComponentProps {\n  line: RenderedLine;\n  linePaths: Map<string, SVGPathElement | null>;\n  lineMaskRects: LineMaskRects;\n  maskPrefix: string;\n  markerPrefix: string;\n  activeLineMarkerPrefix: string;\n  active?: boolean;\n  activeRelated?: boolean;\n  onLineClick?(line: LineTarget): void;\n  onLineDoubleClick?(line: LineTarget): void;\n}\n\nexport function LineComponent({\n  line: { line, edge, d, markers },\n  linePaths,\n  lineMaskRects,\n  maskPrefix,\n  markerPrefix,\n  activeLineMarkerPrefix,\n  active,\n  activeRelated,\n  onLineClick,\n  onLineDoubleClick,\n}: LineComponentProps): JSX.Element {\n  const mask = lineMaskRects.has(line.$id)\n    ? `url(#${maskPrefix}${line.$id})`\n    : undefined;\n\n  const { strokeColor, strokeWidth, interactStrokeWidth } = {\n    ...line,\n    ...(active\n      ? line.overrides?.active\n      : activeRelated\n        ? line.overrides?.activeRelated\n        : null),\n  };\n\n  const expectVariant = active\n    ? \"active\"\n    : activeRelated\n      ? \"active-related\"\n      : \"default\";\n\n  let markerStart: string | undefined;\n  let markerEnd: string | undefined;\n\n  for (const marker of markers) {\n    if (marker.variant === expectVariant) {\n      if (marker.placement === \"start\") {\n        markerStart = `url(#${markerPrefix}${marker.index})`;\n      } else {\n        markerEnd = `url(#${markerPrefix}${marker.index})`;\n      }\n    }\n  }\n\n  return (\n    <g\n      className={classNames(\"line\", {\n        interactable: line.interactable,\n        active,\n        \"active-related\": activeRelated,\n      })}\n      onClick={\n        line.interactable\n          ? () => {\n              onLineClick?.({ id: line.$id, edge });\n            }\n          : undefined\n      }\n      onDoubleClick={\n        line.interactable\n          ? (e) => {\n              e.preventDefault();\n              e.stopPropagation();\n              onLineDoubleClick?.({ id: line.$id, edge });\n            }\n          : undefined\n      }\n      style={{ cursor: line.cursor }}\n    >\n      {line.interactable && (\n        <path\n          // This `path` is made for expanding interaction area of graph lines.\n          d={d}\n          fill=\"none\"\n          stroke=\"transparent\"\n          strokeWidth={interactStrokeWidth}\n        />\n      )}\n      <path\n        ref={(element) => linePaths.set(line.$id, element)}\n        stroke={strokeColor}\n        strokeWidth={strokeWidth}\n        d={d}\n        fill=\"none\"\n        markerStart={markerStart}\n        markerEnd={markerEnd}\n        mask={mask}\n      />\n      <path\n        stroke=\"var(--palette-blue-3)\"\n        strokeWidth={strokeWidth}\n        d={d}\n        fill=\"none\"\n        className=\"active-bg\"\n        markerStart={`url(#${activeLineMarkerPrefix}start)`}\n        markerEnd={`url(#${activeLineMarkerPrefix}end)`}\n        mask={mask}\n      />\n    </g>\n  );\n}\n","import React, { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { ReactUseBrick } from \"@next-core/react-runtime\";\nimport { checkIfByTransform } from \"@next-core/runtime\";\nimport type {\n  DiagramEdge,\n  LineLabelConf,\n  // PositionTuple,\n  RefRepository,\n  LineLabel,\n  TextOptions,\n} from \"./interfaces\";\n\nexport interface LineLabelComponentGroupProps {\n  labels?: LineLabel[];\n  onRendered?: (refRepository: RefRepository | null) => void;\n}\n\nexport function LineLabelComponentGroup({\n  labels,\n  onRendered,\n}: LineLabelComponentGroupProps): JSX.Element {\n  const [rendered, setRendered] = useState(false);\n  const [renderedIds, setRenderedIds] = useState<string[]>([]);\n  const refRepository = useMemo<RefRepository>(() => new Map(), []);\n\n  const handleRenderer = useCallback(\n    (id: string, element: HTMLElement | null) => {\n      if (element) {\n        refRepository.set(id, element);\n      }\n      setRenderedIds((previous) =>\n        previous.includes(id) ? previous : previous.concat(id)\n      );\n    },\n    [refRepository]\n  );\n\n  const handleUnmount = useCallback(\n    (id: string) => {\n      setRenderedIds((previous) => {\n        const index = previous.indexOf(id);\n        return index === -1\n          ? previous\n          : previous.slice(0, index).concat(previous.slice(index + 1));\n      });\n      refRepository.delete(id);\n    },\n    [refRepository]\n  );\n\n  useEffect(() => {\n    // All nodes have been rendered.\n    setRendered(!labels?.some((label) => !renderedIds.includes(label.id)));\n  }, [labels, renderedIds]);\n\n  useEffect(\n    () => {\n      onRendered?.(rendered ? refRepository : null);\n    },\n    // Dot not re-run effect when `onRendered` changed.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [/* onRendered, */ refRepository, rendered]\n  );\n\n  return (\n    <React.Fragment>\n      {labels?.map(({ text, label, /* position, */ id, edge }) =>\n        label ? (\n          <div\n            key={id}\n            className=\"line-label\"\n            // style={{\n            //   left: position[0],\n            //   top: position[1],\n            // }}\n          >\n            <LineLabelComponent\n              id={id}\n              edge={edge}\n              label={label}\n              onRendered={handleRenderer}\n              onUnmount={handleUnmount}\n            />\n          </div>\n        ) : (\n          <LineTextComponent\n            key={id}\n            id={id}\n            text={text!}\n            // position={position}\n            onRendered={handleRenderer}\n          />\n        )\n      )}\n    </React.Fragment>\n  );\n}\n\nexport interface LineTextComponentProps {\n  id: string;\n  text: TextOptions;\n  // position: PositionTuple;\n  onRendered?: (id: string, element: HTMLElement | null) => void;\n  // onUnmount?: (id: string) => void;\n}\n\nexport function LineTextComponent({\n  id,\n  text,\n  // position,\n  onRendered /* , onUnmount */,\n}: LineTextComponentProps): JSX.Element {\n  const refCallback = useCallback(\n    (element: HTMLDivElement) => {\n      onRendered?.(id, element);\n    },\n    [id, onRendered]\n  );\n\n  return (\n    <div\n      className=\"line-label\"\n      ref={refCallback}\n      // style={{\n      //   left: position[0],\n      //   top: position[1],\n      //   ...text!.style,\n      // }}\n      style={text.style}\n    >\n      {text!.content}\n    </div>\n  );\n}\n\n// export const LineLabelComponentGroup = React.memo(LegacyLineLabelComponentGroup);\n\nexport interface LineLabelComponentProps {\n  id: string;\n  edge: DiagramEdge;\n  label: LineLabelConf;\n  onRendered?: (id: string, element: HTMLElement | null) => void;\n  onUnmount?: (id: string) => void;\n}\n\nexport function LineLabelComponent({\n  id,\n  edge,\n  label,\n  onRendered,\n  onUnmount,\n}: LineLabelComponentProps): JSX.Element | null {\n  const useBrick = useMemo(\n    () => (checkIfByTransform(label, { edge }) ? label.useBrick : null),\n    [edge, label]\n  );\n\n  const memoizedData = useMemo(() => ({ edge }), [edge]);\n\n  useEffect(() => {\n    if (!useBrick) {\n      // Keep the same time delay for reporting rendered.\n      setTimeout(() => {\n        onRendered?.(id, null);\n      });\n    }\n  }, [id, onRendered, useBrick]);\n\n  useEffect(\n    () => {\n      return () => {\n        onUnmount?.(id);\n      };\n    },\n    // Only unmount once\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const refCallback = useCallback(\n    (element: HTMLElement | null) => {\n      if (element) {\n        // Todo: correctly wait for `useBrick` in v3 to be rendered (after layout)\n        // Wait a macro task to let `useBrick` to be rendered.\n        setTimeout(() => {\n          onRendered?.(id, element.parentElement);\n        });\n      }\n    },\n    [id, onRendered]\n  );\n\n  const ignoredCallback = useCallback(() => {\n    setTimeout(() => {\n      onRendered?.(id, null);\n    });\n  }, [id, onRendered]);\n\n  if (!useBrick) {\n    return null;\n  }\n\n  return (\n    <ReactUseBrick\n      refCallback={refCallback}\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore For v3 only\n      ignoredCallback={ignoredCallback}\n      useBrick={useBrick}\n      data={memoizedData}\n    />\n  );\n}\n","import React from \"react\";\nimport type { RenderedLineLabel, SimpleRect } from \"./interfaces\";\n\nexport interface LineMaskComponentProps {\n  maskPrefix: string;\n  lineId: string;\n  rects: SimpleRect[];\n  renderedLineLabels: RenderedLineLabel[];\n}\n\nexport function LineMaskComponent({\n  lineId,\n  rects,\n  maskPrefix,\n  renderedLineLabels,\n}: LineMaskComponentProps): JSX.Element | null {\n  const lineText = renderedLineLabels.find(\n    (item) => item.lineId === lineId && item.placement === \"center\"\n  );\n  // istanbul ignore next\n  if (!lineText) {\n    return null;\n  }\n  const { lineRect } = lineText;\n  const bgRect = getRectWithPadding(lineRect, 1000);\n  return (\n    <mask\n      id={`${maskPrefix}${lineId}`}\n      x={bgRect.left}\n      y={bgRect.top}\n      width={bgRect.width}\n      height={bgRect.height}\n    >\n      <rect\n        x={bgRect.left}\n        y={bgRect.top}\n        width={bgRect.width}\n        height={bgRect.height}\n        // Everything under a white pixel will be visible\n        fill=\"white\"\n      />\n      {rects.map((rect, index) => (\n        <rect\n          key={index}\n          x={rect.left}\n          y={rect.top}\n          width={rect.width}\n          height={rect.height}\n          // Everything under a black pixel will be invisible\n          fill=\"black\"\n        />\n      ))}\n    </mask>\n  );\n}\n\nfunction getRectWithPadding(rect: SimpleRect, padding: number): SimpleRect {\n  return {\n    left: rect.left - padding,\n    top: rect.top - padding,\n    width: rect.width + padding * 2,\n    height: rect.height + padding * 2,\n  };\n}\n","import React, { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { ReactUseBrick } from \"@next-core/react-runtime\";\nimport type {\n  DiagramNode,\n  DiagramNodeId,\n  NodeBrickConf,\n  RefRepository,\n} from \"./interfaces\";\nimport { findNodeBrick } from \"./processors/findNodeBrick\";\n\nexport interface NodeComponentGroupProps {\n  nodes?: DiagramNode[];\n  nodeBricks?: NodeBrickConf[];\n  onRendered?: (refRepository: RefRepository | null) => void;\n}\n\nexport function NodeComponentGroup({\n  nodes,\n  nodeBricks,\n  onRendered,\n}: NodeComponentGroupProps): JSX.Element {\n  const [rendered, setRendered] = useState(false);\n  const [renderedIds, setRenderedIds] = useState<DiagramNodeId[]>([]);\n  const refRepository = useMemo<RefRepository>(() => new Map(), []);\n\n  const handleRenderer = useCallback(\n    (id: DiagramNodeId, element: HTMLElement | null) => {\n      if (element) {\n        refRepository.set(id, element);\n      }\n      setRenderedIds((previous) =>\n        previous.includes(id) ? previous : previous.concat(id)\n      );\n    },\n    [refRepository]\n  );\n\n  const handleUnmount = useCallback(\n    (id: DiagramNodeId) => {\n      setRenderedIds((previous) => {\n        const index = previous.indexOf(id);\n        return index === -1\n          ? previous\n          : previous.slice(0, index).concat(previous.slice(index + 1));\n      });\n      refRepository.delete(id);\n    },\n    [refRepository]\n  );\n\n  useEffect(() => {\n    // All nodes have been rendered.\n    setRendered(!nodes?.some((node) => !renderedIds.includes(node.id)));\n  }, [nodes, renderedIds]);\n\n  useEffect(\n    () => {\n      onRendered?.(rendered ? refRepository : null);\n    },\n    // Dot not re-run effect when `onRendered` changed.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [/* onRendered, */ refRepository, rendered]\n  );\n\n  return (\n    <React.Fragment>\n      {nodes?.map((node) => (\n        <div key={node.id} className=\"node\">\n          <NodeComponent\n            nodeBricks={nodeBricks}\n            node={node}\n            onRendered={handleRenderer}\n            onUnmount={handleUnmount}\n          />\n        </div>\n      ))}\n    </React.Fragment>\n  );\n}\n\nexport interface NodeComponentProps {\n  node: DiagramNode;\n  nodeBricks?: NodeBrickConf[];\n  onRendered?: (id: DiagramNodeId, element: HTMLElement | null) => void;\n  onUnmount?: (id: DiagramNodeId) => void;\n}\n\nexport function NodeComponent({\n  node,\n  nodeBricks,\n  onRendered,\n  onUnmount,\n}: NodeComponentProps): JSX.Element | null {\n  const useBrick = useMemo(\n    () => findNodeBrick(node, nodeBricks)?.useBrick,\n    [node, nodeBricks]\n  );\n  const memoizedData = useMemo(() => ({ node }), [node]);\n\n  useEffect(() => {\n    if (!useBrick) {\n      // Keep the same time delay for reporting rendered.\n      setTimeout(() => {\n        onRendered?.(node.id, null);\n      });\n    }\n  }, [node.id, onRendered, useBrick]);\n\n  useEffect(\n    () => {\n      return () => {\n        onUnmount?.(node.id);\n      };\n    },\n    // Only unmount once\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const refCallback = useCallback(\n    (element: HTMLElement | null) => {\n      if (element) {\n        // Todo: correctly wait for `useBrick` in v3 to be rendered (after layout)\n        // Wait a macro task to let `useBrick` to be rendered.\n        setTimeout(() => {\n          onRendered?.(node.id, element);\n        });\n      }\n    },\n    [node.id, onRendered]\n  );\n\n  const ignoredCallback = useCallback(() => {\n    setTimeout(() => {\n      onRendered?.(node.id, null);\n    });\n  }, [node.id, onRendered]);\n\n  if (!useBrick) {\n    return null;\n  }\n\n  return (\n    <ReactUseBrick\n      refCallback={refCallback}\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore For v3 only\n      ignoredCallback={ignoredCallback}\n      useBrick={useBrick}\n      data={memoizedData}\n    />\n  );\n}\n","import { checkIfByTransform } from \"@next-core/runtime\";\nimport { NodeBrickConf, DiagramNode } from \"../interfaces\";\n\nexport function findNodeBrick(\n  node: DiagramNode,\n  nodeBricks: NodeBrickConf[] | undefined\n): NodeBrickConf | undefined {\n  return nodeBricks?.find((item) => {\n    if (item.nodeType) {\n      return ([] as unknown[]).concat(item.nodeType).includes(node.type);\n    }\n    return checkIfByTransform(item, { node });\n  });\n}\n","export const DEFAULT_LINE_STROKE_COLOR = \"var(--palette-gray-5)\";\nexport const DEFAULT_LINE_STROKE_WIDTH = 1;\nexport const DEFAULT_LINE_CURVE_TYPE = \"curveBasis\";\nexport const DEFAULT_LINE_INTERACT_STROKE_WIDTH = 20;\nexport const DEFAULT_SCALE_RANGE_MIN = 0.5;\nexport const DEFAULT_SCALE_RANGE_MAX = 2;\n","import type { FullRectTuple, RefRepository, RenderedNode } from \"../interfaces\";\n\nexport function adjustNodesSize(\n  nodes: RenderedNode[],\n  nodesRefRepository: RefRepository,\n  nodePaddings: FullRectTuple\n) {\n  for (const node of nodes) {\n    const element = nodesRefRepository.get(node.id);\n    node.width =\n      Math.max(element?.offsetWidth ?? 0, 10) +\n      nodePaddings[1] +\n      nodePaddings[3];\n    node.height =\n      Math.max(element?.offsetHeight ?? 0, 10) +\n      nodePaddings[0] +\n      nodePaddings[2];\n  }\n}\n","import type { FullRectTuple, RefRepository, RenderedNode } from \"../interfaces\";\n\nexport function adjustNodesPosition(\n  nodes: RenderedNode[],\n  nodesRefRepository: RefRepository,\n  nodePaddings: FullRectTuple\n) {\n  for (const node of nodes) {\n    const x = node.x - node.width / 2 + nodePaddings[3];\n    const y = node.y - node.height / 2 + nodePaddings[0];\n\n    const nodeContainer = nodesRefRepository.get(node.id)?.parentElement;\n    if (nodeContainer) {\n      nodeContainer.style.left = `${x}px`;\n      nodeContainer.style.top = `${y}px`;\n      nodeContainer.style.visibility = \"visible\";\n    }\n  }\n}\n","// istanbul ignore file: experimental\nimport type {\n  DiagramEdge,\n  LabelSize,\n  RefRepository,\n  RenderedEdge,\n} from \"../interfaces\";\n\nexport function getRenderedEdges(\n  edges: DiagramEdge[] | undefined,\n  {\n    normalizedLinesMap,\n    lineLabelsRefRepository,\n  }: {\n    normalizedLinesMap: WeakMap<DiagramEdge, string>;\n    lineLabelsRefRepository: RefRepository;\n  }\n) {\n  return (\n    edges?.map<RenderedEdge>((edge) => {\n      const lineId = normalizedLinesMap.get(edge);\n      const labelSize: LabelSize = {};\n      if (lineId) {\n        for (const placement of [/* \"center\", */ \"start\", \"end\"] as const) {\n          const element = lineLabelsRefRepository.get(`${lineId}-${placement}`);\n          if (element) {\n            labelSize[placement] = [element.offsetWidth, element.offsetHeight];\n          }\n        }\n      }\n\n      return {\n        data: edge,\n        labelSize,\n      };\n    }) ?? []\n  );\n}\n","// istanbul ignore file: experimental\nimport {\n  forceSimulation,\n  forceLink,\n  forceCollide,\n  forceManyBody,\n  forceX,\n  forceY,\n  type Simulation,\n  type SimulationNodeDatum,\n  type SimulationLinkDatum,\n} from \"d3-force\";\nimport { pick } from \"lodash\";\nimport type {\n  DiagramEdge,\n  DiagramNode,\n  ForceCollideOptions,\n  LayoutOptionsForce,\n  RenderedNode,\n  UnifiedGraph,\n  UserViewNodesMap,\n} from \"../interfaces\";\nimport { adjustNodesSize } from \"./adjustNodesSize\";\nimport { adjustNodesPosition } from \"./adjustNodesPosition\";\nimport { extractPartialRectTuple } from \"./extractPartialRectTuple\";\nimport { getRenderedEdges } from \"./getRenderedEdges\";\n\ninterface NormalNode extends SimulationNodeDatum {\n  dummy?: false;\n  id: string;\n  data: DiagramNode;\n  width: number;\n  height: number;\n}\n\ninterface DummyNode extends SimulationNodeDatum {\n  dummy: true;\n  id: string;\n}\n\ntype ForceNode = NormalNode | DummyNode;\n\ntype ForceLink = SimulationLinkDatum<ForceNode> & {\n  dummy?: boolean;\n};\n\nexport function getForceGraph(\n  previousGraph: UnifiedGraph | null,\n  nodes: DiagramNode[] | undefined,\n  edges: DiagramEdge[] | undefined,\n  userViewNodesMap: UserViewNodesMap | null,\n  forceLayoutOptions: LayoutOptionsForce | undefined\n): UnifiedGraph {\n  const { nodePadding, dummyNodesOnEdges, collide } = {\n    nodePadding: 0,\n    dummyNodesOnEdges: 0,\n    ...pick(forceLayoutOptions, [\"nodePadding\", \"dummyNodesOnEdges\"]),\n    collide:\n      forceLayoutOptions?.collide !== false\n        ? ({\n            dummyRadius: 1,\n            radiusDiff: 5,\n            strength: 1,\n            iterations: 1,\n            ...(forceLayoutOptions?.collide === true\n              ? null\n              : (forceLayoutOptions?.collide as ForceCollideOptions)),\n          } as Required<ForceCollideOptions>)\n        : (false as const),\n  };\n  const nodePaddings = extractPartialRectTuple(nodePadding);\n\n  const renderedNodes: RenderedNode[] = [];\n  for (const node of nodes ?? []) {\n    const previousNode = previousGraph?.getNode(node.id);\n    if (previousNode?.data === node) {\n      renderedNodes.push(previousNode);\n    } else {\n      const renderedNode = {\n        id: node.id,\n        data: node,\n      } as RenderedNode & { fx?: number; fy?: number };\n      const userViewNode = userViewNodesMap?.get(node.id);\n      if (userViewNode) {\n        renderedNode.fx = userViewNode.x;\n        renderedNode.fy = userViewNode.y;\n      }\n      renderedNodes.push(renderedNode);\n    }\n  }\n\n  function getNode(id: string) {\n    return renderedNodes.find((node) => node.data.id === id);\n  }\n\n  return {\n    layout: \"force\",\n    getNode,\n    applyLayout({\n      nodesRefRepository,\n      lineLabelsRefRepository,\n      normalizedLinesMap,\n    }) {\n      if (renderedNodes.length === 0) {\n        return null;\n      }\n\n      adjustNodesSize(renderedNodes, nodesRefRepository, nodePaddings);\n\n      const forceNodes = renderedNodes.slice();\n      const forceLinks: ForceLink[] = [];\n\n      for (const edge of edges ?? []) {\n        forceLinks.push({ ...edge });\n        if (dummyNodesOnEdges > 0) {\n          forceNodes.push(\n            ...(getDummyNodes(\n              edge,\n              dummyNodesOnEdges\n            ) as Partial<RenderedNode>[] as RenderedNode[])\n          );\n          forceLinks.push(...getDummyEdges(edge, dummyNodesOnEdges));\n        }\n      }\n\n      const linkSimulation = forceLink<ForceNode, ForceLink>(forceLinks).id(\n        (d) => d.id\n      );\n\n      if (dummyNodesOnEdges > 0) {\n        linkSimulation\n          .distance((l) => (l.dummy ? 30 / (dummyNodesOnEdges + 1) : 30))\n          .strength((l) => (l.dummy ? 0.5 : 1));\n      }\n\n      const simulation = forceSimulation<ForceNode>(forceNodes)\n        .force(\"link\", linkSimulation)\n        .force(\"x\", forceX())\n        .force(\"y\", forceY())\n        .force(\"charge\", forceManyBody());\n\n      if (collide) {\n        simulation.force(\n          \"collide\",\n          forceCollide<ForceNode>()\n            .radius((d) =>\n              d.dummy\n                ? collide.dummyRadius\n                : Math.sqrt(d.width ** 2 + d.height ** 2) / 2 +\n                  collide.radiusDiff\n            )\n            .strength(collide.strength)\n            .iterations(collide.iterations)\n        );\n      }\n\n      simulation.stop();\n      manuallyTickToTheEnd(simulation);\n\n      adjustNodesPosition(renderedNodes, nodesRefRepository, nodePaddings);\n\n      const renderedEdges = getRenderedEdges(edges, {\n        normalizedLinesMap,\n        lineLabelsRefRepository,\n      });\n\n      return { nodes: renderedNodes, edges: renderedEdges };\n    },\n  };\n}\n\nfunction manuallyTickToTheEnd(\n  simulation: Simulation<ForceNode, ForceLink>\n): void {\n  // Manually tick to the end.\n  simulation.tick(\n    Math.ceil(\n      Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())\n    )\n  );\n}\n\nfunction getDummyNodes(edge: DiagramEdge, count: number): DummyNode[] {\n  return new Array(count).fill(null).map<DummyNode>((v, i) => ({\n    dummy: true,\n    id: `$dummy-${edge.source}-${edge.target}-${i}`,\n  }));\n}\n\nfunction getDummyEdges(edge: DiagramEdge, count: number): ForceLink[] {\n  return new Array(count + 1).fill(null).map<ForceLink>((v, i) => ({\n    dummy: true,\n    source:\n      i === 0 ? edge.source : `$dummy-${edge.source}-${edge.target}-${i - 1}`,\n    target:\n      i === count ? edge.target : `$dummy-${edge.source}-${edge.target}-${i}`,\n  }));\n}\n","import { useEffect, useState } from \"react\";\nimport type {\n  DiagramEdge,\n  DiagramNode,\n  LayoutOptions,\n  LayoutOptionsDagre,\n  LayoutOptionsForce,\n  ManualLayoutStatus,\n  NodeMovement,\n  RefRepository,\n  RenderedDiagram,\n  UnifiedGraph,\n  UserViewNodesMap,\n} from \"../interfaces\";\nimport { getDagreGraph } from \"../processors/getDagreGraph\";\nimport { getForceGraph } from \"../processors/getForceGraph\";\nimport { getManualGraph } from \"../processors/getManualGraph\";\n\nexport function useRenderedDiagram({\n  layout: originalLayout,\n  nodes,\n  edges,\n  manualLayoutStatus,\n  userViewReady,\n  userViewNodesMap,\n  nodeMovement,\n  nodesRefRepository,\n  lineLabelsRefRepository,\n  normalizedLinesMap,\n  nodesRenderId,\n  lineLabelsRenderId,\n  layoutOptions,\n}: {\n  layout: \"dagre\" | \"force\" | undefined;\n  nodes: DiagramNode[] | undefined;\n  edges: DiagramEdge[] | undefined;\n  manualLayoutStatus: ManualLayoutStatus;\n  userViewReady: boolean;\n  userViewNodesMap: UserViewNodesMap | null;\n  nodeMovement: NodeMovement | null;\n  nodesRefRepository: RefRepository | null;\n  lineLabelsRefRepository: RefRepository | null;\n  normalizedLinesMap: WeakMap<DiagramEdge, string>;\n  nodesRenderId: number;\n  lineLabelsRenderId: number;\n  layoutOptions?: LayoutOptions;\n}) {\n  const layout = manualLayoutStatus === \"initial\" ? originalLayout : \"manual\";\n  const [graph, setGraph] = useState<UnifiedGraph | null>(null);\n\n  const [renderedDiagram, setRenderedDiagram] = useState<RenderedDiagram>({\n    nodes: [],\n    edges: [],\n  });\n\n  useEffect(() => {\n    if (!userViewReady) {\n      return;\n    }\n    setGraph((previousGraph) =>\n      layout === \"dagre\"\n        ? getDagreGraph(\n            previousGraph,\n            nodes,\n            edges,\n            layoutOptions as LayoutOptionsDagre\n          )\n        : layout === \"force\"\n          ? getForceGraph(\n              previousGraph,\n              nodes,\n              edges,\n              userViewNodesMap,\n              layoutOptions as LayoutOptionsForce\n            )\n          : layout === \"manual\"\n            ? getManualGraph(previousGraph, nodes, edges, layoutOptions)\n            : null\n    );\n  }, [edges, nodes, layout, layoutOptions, userViewReady, userViewNodesMap]);\n\n  useEffect(() => {\n    if (\n      !nodesRefRepository ||\n      !lineLabelsRefRepository ||\n      layout !== graph?.layout\n    ) {\n      return;\n    }\n    const renderedDiagram = graph?.applyLayout({\n      manualLayoutStatus,\n      nodesRefRepository,\n      lineLabelsRefRepository,\n      normalizedLinesMap,\n      nodeMovement,\n    });\n    if (renderedDiagram) {\n      setRenderedDiagram(renderedDiagram);\n    }\n  }, [\n    layout,\n    manualLayoutStatus,\n    graph,\n    nodeMovement,\n    nodesRefRepository,\n    lineLabelsRefRepository,\n    nodesRenderId,\n    lineLabelsRenderId,\n    normalizedLinesMap,\n  ]);\n\n  return renderedDiagram;\n}\n","import dagre from \"@dagrejs/dagre\";\nimport { pick } from \"lodash\";\nimport type {\n  DiagramEdge,\n  DiagramNode,\n  LayoutOptionsDagre,\n  RenderedEdge,\n  RenderedNode,\n  UnifiedGraph,\n} from \"../interfaces\";\nimport { adjustNodesSize } from \"./adjustNodesSize\";\nimport { adjustNodesPosition } from \"./adjustNodesPosition\";\nimport { extractPartialRectTuple } from \"./extractPartialRectTuple\";\n\nexport function getDagreGraph(\n  previousGraph: UnifiedGraph | null,\n  nodes: DiagramNode[] | undefined,\n  edges: DiagramEdge[] | undefined,\n  dagreLayoutOptions: LayoutOptionsDagre | undefined\n): UnifiedGraph {\n  const { nodePadding, ...dagreGraphOptions } = {\n    nodePadding: 0,\n    rankdir: \"TB\",\n    ranksep: 50,\n    edgesep: 10,\n    nodesep: 50,\n    // align: undefined,\n    ...pick(dagreLayoutOptions, [\n      \"nodePadding\",\n      \"rankdir\",\n      \"ranksep\",\n      \"edgesep\",\n      \"nodesep\",\n      \"align\",\n    ]),\n  };\n  const nodePaddings = extractPartialRectTuple(nodePadding);\n\n  // Create a new directed graph\n  const graph = new dagre.graphlib.Graph<RenderedNode>();\n\n  // Set an object for the graph label\n  graph.setGraph(dagreGraphOptions);\n\n  // Default to assigning a new object as a label for each new edge.\n  graph.setDefaultEdgeLabel(function () {\n    return {};\n  });\n\n  for (const node of nodes ?? []) {\n    const previousNode = previousGraph?.getNode(node.id);\n    graph.setNode(\n      node.id,\n      previousNode?.data === node\n        ? previousNode\n        : {\n            id: node.id,\n            data: node,\n          }\n    );\n  }\n\n  for (const edge of edges ?? []) {\n    graph.setEdge(edge.source, edge.target, { data: edge });\n  }\n\n  return {\n    layout: \"dagre\",\n    getNode(id) {\n      return graph.node(id);\n    },\n    applyLayout({\n      nodesRefRepository,\n      lineLabelsRefRepository,\n      normalizedLinesMap,\n    }) {\n      const renderedNodes: RenderedNode[] = [];\n      for (const id of graph.nodes()) {\n        const node = graph.node(id);\n        if (node) {\n          renderedNodes.push(node);\n        } else {\n          // eslint-disable-next-line no-console\n          console.error(\"Diagram node not found: %s\", id);\n        }\n      }\n\n      if (renderedNodes.length === 0) {\n        return null;\n      }\n\n      adjustNodesSize(renderedNodes, nodesRefRepository, nodePaddings);\n\n      const renderedEdges = graph\n        .edges()\n        .map((e) => graph.edge(e) as RenderedEdge);\n      for (const edge of renderedEdges) {\n        const lineId = normalizedLinesMap.get(edge.data);\n        if (lineId) {\n          for (const placement of [\"center\", \"start\", \"end\"] as const) {\n            const element = lineLabelsRefRepository.get(\n              `${lineId}-${placement}`\n            );\n            if (element) {\n              const { offsetWidth, offsetHeight } = element;\n              if (placement === \"center\") {\n                edge.labelpos = \"c\";\n                edge.width = offsetWidth;\n                edge.height = offsetHeight;\n              }\n              edge.labelSize ??= {};\n              edge.labelSize[placement] = [offsetWidth, offsetHeight];\n            }\n          }\n        }\n      }\n      dagre.layout(graph);\n\n      adjustNodesPosition(renderedNodes, nodesRefRepository, nodePaddings);\n\n      return {\n        nodes: renderedNodes,\n        edges: renderedEdges,\n      };\n    },\n  };\n}\n","// istanbul ignore file: experimental\nimport { pick } from \"lodash\";\nimport type {\n  DiagramEdge,\n  DiagramNode,\n  BaseLayoutOptions,\n  RenderedNode,\n  UnifiedGraph,\n} from \"../interfaces\";\nimport { extractPartialRectTuple } from \"./extractPartialRectTuple\";\nimport { adjustNodesSize } from \"./adjustNodesSize\";\nimport { adjustNodesPosition } from \"./adjustNodesPosition\";\nimport { getRenderedEdges } from \"./getRenderedEdges\";\n\nexport function getManualGraph(\n  previousGraph: UnifiedGraph | null,\n  nodes: DiagramNode[] | undefined,\n  edges: DiagramEdge[] | undefined,\n  layoutOptions: BaseLayoutOptions | undefined\n): UnifiedGraph {\n  const { nodePadding } = {\n    nodePadding: 0,\n    ...pick(layoutOptions, [\"nodePadding\"]),\n  };\n  const nodePaddings = extractPartialRectTuple(nodePadding);\n\n  const renderedNodes: RenderedNode[] = [];\n  for (const node of nodes ?? []) {\n    const previousNode = previousGraph?.getNode(node.id);\n    if (previousNode?.data === node) {\n      renderedNodes.push(previousNode);\n      previousNode.x0 = previousNode.x;\n      previousNode.y0 = previousNode.y;\n    } else {\n      renderedNodes.push({\n        id: node.id,\n        data: node,\n      } as RenderedNode);\n    }\n  }\n\n  function getNode(id: string) {\n    return renderedNodes.find((node) => node.data.id === id);\n  }\n\n  let movedNode: RenderedNode | undefined;\n\n  return {\n    layout: \"manual\",\n    getNode,\n    applyLayout({\n      manualLayoutStatus,\n      nodesRefRepository,\n      lineLabelsRefRepository,\n      normalizedLinesMap,\n      nodeMovement,\n    }) {\n      if (renderedNodes.length === 0) {\n        return null;\n      }\n\n      adjustNodesSize(renderedNodes, nodesRefRepository, nodePaddings);\n\n      if (nodeMovement) {\n        movedNode = renderedNodes.find((node) => node.id === nodeMovement.id);\n        if (movedNode) {\n          movedNode.x = (movedNode.x0 ?? 0) + nodeMovement.move[0];\n          movedNode.y = (movedNode.y0 ?? 0) + nodeMovement.move[1];\n        }\n      }\n\n      if (manualLayoutStatus === \"finished\" && movedNode) {\n        // Set x0/y0 after finished manual layout\n        movedNode.x0 = movedNode.x;\n        movedNode.y0 = movedNode.y;\n      }\n\n      adjustNodesPosition(renderedNodes, nodesRefRepository, nodePaddings);\n\n      const renderedEdges = getRenderedEdges(edges, {\n        normalizedLinesMap,\n        lineLabelsRefRepository,\n      });\n\n      return { nodes: renderedNodes, edges: renderedEdges };\n    },\n  };\n}\n","import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { http } from \"@next-core/http\";\n/**\n * @description V3 ()\n * @endpoint POST /v3/object/:objectId/instance/_search\n */\nexport var InstanceApi_postSearchV3 = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (objectId, data, options) {\n    return (/**! @contract easyops.api.cmdb.instance.PostSearchV3@1.1.0 */(yield http.post(\"api/gateway/cmdb.instance.PostSearchV3/v3/object/\".concat(objectId, \"/instance/_search\"), data, options)).data\n    );\n  });\n  return function InstanceApi_postSearchV3(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n//# sourceMappingURL=postSearchV3.js.map","import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { http } from \"@next-core/http\";\n\n/**  */\n\n/**\n * @description V2 ()\n * @endpoint PUT /v2/object/:objectId/instance/:instanceId\n */\nexport var InstanceApi_updateInstanceV2 = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (objectId, instanceId, data, options) {\n    return (/**! @contract easyops.api.cmdb.instance.UpdateInstanceV2@1.0.0 */(yield http.put(\"api/gateway/cmdb.instance.UpdateInstanceV2/v2/object/\".concat(objectId, \"/instance/\").concat(instanceId), data, options)).data\n    );\n  });\n  return function InstanceApi_updateInstanceV2(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n//# sourceMappingURL=updateInstanceV2.js.map","import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { http } from \"@next-core/http\";\n\n/**  */\n\n/**\n * @description  (body,,)\n * @endpoint POST /v2/object/:objectId/instance\n */\nexport var InstanceApi_createInstance = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (objectId, data, options) {\n    return (/**! @contract easyops.api.cmdb.instance.CreateInstance@1.1.0 */(yield http.post(\"api/gateway/cmdb.instance.CreateInstance/v2/object/\".concat(objectId, \"/instance\"), data, options)).data\n    );\n  });\n  return function InstanceApi_createInstance(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n//# sourceMappingURL=createInstance.js.map","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { handleHttpError } from \"@next-core/runtime\";\nimport {\n  InstanceApi_postSearchV3,\n  InstanceApi_updateInstanceV2,\n  InstanceApi_createInstance,\n} from \"@next-api-sdk/cmdb-sdk\";\nimport { createAsyncQueue } from \"../processors/createAsyncQueue\";\nimport {\n  NodeUserView,\n  UserView,\n  UserViewNodesMap,\n  UserViewQuery,\n} from \"../interfaces\";\n\nconst USER_VIEW_MODEL_ID = \"GRAPH_USER_VIEW@EASYOPS\";\n\nexport interface UserViewHook {\n  userViewReady: boolean;\n  userViewNodesMap: UserViewNodesMap | null;\n  saveUserView: (nodes: NodeUserView[]) => void;\n}\n\nexport function useUserView(query: UserViewQuery | undefined): UserViewHook {\n  const [userViewReady, setUserViewReady] = useState(!query);\n  const userViewIdRef = useRef<string>();\n  const [userViewNodesMap, setUserViewNodesMap] =\n    useState<UserViewNodesMap | null>(null);\n  const queue = useMemo(() => createAsyncQueue(), []);\n\n  useEffect(() => {\n    async function getUserView(): Promise<void> {\n      if (!query) {\n        setUserViewReady(true);\n        return;\n      }\n      const { namespace, key } = query;\n      if (!(namespace && key)) {\n        // eslint-disable-next-line no-console\n        console.error(\"Namespace and key are required to save graph user view\");\n        setUserViewReady(true);\n        return;\n      }\n      try {\n        const list = (\n          await InstanceApi_postSearchV3(USER_VIEW_MODEL_ID, {\n            fields: [\"nodes\"],\n            query: {\n              namespace: {\n                $eq: namespace,\n              },\n              key: {\n                $eq: key,\n              },\n            },\n            page: 1,\n            page_size: 30,\n          })\n        ).list as UserView[];\n        if (list.length > 0) {\n          const userView = list[0];\n          const userViewNodesMap = new Map(\n            userView.nodes?.map((node) => [node.id, node])\n          );\n          userViewIdRef.current = userView.instanceId;\n          setUserViewNodesMap(userViewNodesMap);\n        } else {\n          setUserViewNodesMap(null);\n        }\n      } catch (error) {\n        handleHttpError(error as Error);\n      } finally {\n        setUserViewReady(true);\n      }\n    }\n    getUserView();\n  }, [query]);\n\n  const saveUserView = useCallback(\n    (nodes: NodeUserView[]) => {\n      const { namespace, key } = query ?? {};\n      if (!(namespace && key)) {\n        return;\n      }\n      queue(async () => {\n        const userViewData = {\n          namespace,\n          key,\n          nodes,\n        };\n        try {\n          if (userViewIdRef.current) {\n            await InstanceApi_updateInstanceV2(\n              USER_VIEW_MODEL_ID,\n              userViewIdRef.current,\n              userViewData,\n              {\n                interceptorParams: {\n                  ignoreLoadingBar: true,\n                },\n              }\n            );\n          } else {\n            const userView = await InstanceApi_createInstance(\n              USER_VIEW_MODEL_ID,\n              userViewData,\n              {\n                interceptorParams: {\n                  ignoreLoadingBar: true,\n                },\n              }\n            );\n            userViewIdRef.current = userView.instanceId;\n          }\n        } catch (error) {\n          handleHttpError(error);\n        }\n      });\n    },\n    [query, queue]\n  );\n\n  return {\n    userViewReady,\n    userViewNodesMap,\n    saveUserView,\n  };\n}\n","type Task = (...args: unknown[]) => unknown;\ntype Queue = (task: Task) => Promise<void>;\n\nexport function createAsyncQueue(): Queue {\n  let working = false;\n  const waitingTasks: Task[] = [];\n  return async function queue(task: Task) {\n    waitingTasks.push(task);\n    if (!working) {\n      working = true;\n      let nextTask: Task | undefined;\n      while ((nextTask = waitingTasks.shift())) {\n        try {\n          await nextTask();\n        } catch (error) {\n          // eslint-disable-next-line no-console\n          console.error(error);\n        }\n      }\n      working = false;\n    }\n  };\n}\n","import type { RefRepository, RenderedLineLabel } from \"../interfaces\";\n\nexport function adjustLineLabels(\n  renderedLineLabels: RenderedLineLabel[],\n  lineLabelsRefRepository: RefRepository\n) {\n  for (const {\n    id,\n    position,\n    placement,\n    angle,\n    size: _size,\n  } of renderedLineLabels) {\n    const label = lineLabelsRefRepository.get(id);\n    if (label) {\n      label.style.left = `${position[0]}px`;\n      label.style.top = `${position[1]}px`;\n      label.style.visibility = \"visible\";\n      // label.classList.add(placement);\n      if (placement !== \"center\" && angle !== undefined) {\n        const [width, height] = _size ?? [0, 0];\n        // Get the numbered direction of the line\n        //\n        // \\    |    /\n        //  \\ 5 | 6 /\n        //  4 \\ | / 7\n        // -----x-----\n        //  3 / | \\ 0\n        //  / 2 | 1 \\\n        // /    |    \\\n        const tempDirection = Math.floor(\n          ((angle < 0 ? Math.PI * 2 + angle : angle) / Math.PI) * 4\n        );\n        // Swap direction for end labels.\n        const direction =\n          placement === \"start\" ? tempDirection : (tempDirection + 4) % 8;\n        const tangent = Math.tan(angle);\n        const offsetAngle =\n          angle + ((placement === \"start\" ? 1 : -1) * Math.PI) / 2;\n        const offset = 2;\n        const offsetSin = Math.sin(offsetAngle) * offset;\n        const offsetCos = Math.cos(offsetAngle) * offset;\n        let transform: string;\n        switch (direction) {\n          case 0:\n            transform = `translate(0,${width * tangent + offsetSin}px)`;\n            break;\n          case 1:\n            transform = `translate(${height / tangent - offsetCos}px,0)`;\n            break;\n          case 2:\n            transform = `translate(calc(${\n              height / tangent + offsetCos\n            }px - 100%),0)`;\n            break;\n          case 3:\n            transform = `translate(-100%,${-width * tangent - offsetSin}px)`;\n            break;\n          case 4:\n            transform = `translate(-100%,calc(${\n              -width * tangent + offsetSin\n            }px - 100%))`;\n            break;\n          case 5:\n            transform = `translate(calc(${\n              -height / tangent - offsetCos\n            }px - 100%),-100%)`;\n            break;\n          case 6:\n            transform = `translate(${-height / tangent + offsetCos}px,-100%)`;\n            break;\n          default:\n            transform = `translate(0,calc(${\n              width * tangent - offsetSin\n            }px - 100%))`;\n        }\n        label.style.transform = transform;\n      }\n    }\n  }\n}\n","import type {\n  LineMaskRects,\n  RefRepository,\n  RenderedLineLabel,\n} from \"../interfaces\";\n\nexport function getLineMaskRects(\n  renderedLineLabels: RenderedLineLabel[],\n  lineLabelsRefRepository: RefRepository\n) {\n  const map: LineMaskRects = new Map();\n\n  for (const { id, lineId, placement } of renderedLineLabels) {\n    if (!lineLabelsRefRepository || placement !== \"center\") {\n      continue;\n    }\n    const element = lineLabelsRefRepository.get(id);\n    if (!element) {\n      continue;\n    }\n    const { offsetWidth, offsetHeight } = element;\n    // Do not mask out when the label takes no space.\n    // istanbul ignore next\n    if (\n      process.env.NODE_ENV !== \"test\" &&\n      (offsetWidth === 0 || offsetHeight === 0)\n    ) {\n      continue;\n    }\n    const padding = 3;\n    // Currently no other rects\n    map.set(lineId, [\n      {\n        left: element.offsetLeft - offsetWidth / 2 - padding,\n        top: element.offsetTop - offsetHeight / 2 - padding,\n        width: offsetWidth + padding * 2,\n        height: offsetHeight + padding * 2,\n      },\n    ]);\n  }\n\n  return map;\n}\n","import type {\n  LineLabelConf,\n  RenderedLine,\n  RenderedLineLabel,\n  TextOptions,\n} from \"../interfaces\";\n\nexport function getRenderedLineLabels(\n  previous: RenderedLineLabel[],\n  renderedLines: RenderedLine[],\n  linePaths: Map<string, SVGPathElement | null>\n) {\n  if (previous.length === 0 && renderedLines.length === 0) {\n    return previous;\n  }\n  return renderedLines.flatMap(\n    ({ line: { text, label, $id }, edge, labelSize, angle }) => {\n      const path = linePaths.get($id);\n      if ((!text && !label) || !path || !path.getAttribute(\"d\")) {\n        return [] as RenderedLineLabel[];\n      }\n\n      let key: \"label\" | \"text\";\n      let list: LineLabelConf[] | TextOptions[];\n      if (label) {\n        key = \"label\";\n        list = ([] as LineLabelConf[]).concat(label);\n      } else {\n        key = \"text\";\n        list = ([] as TextOptions[]).concat(text!);\n      }\n\n      // istanbul ignore next\n      const {\n        x: left,\n        y: top,\n        width,\n        height,\n      } = process.env.NODE_ENV === \"test\"\n        ? { x: 10, y: 20, width: 300, height: 400 }\n        : path.getBBox();\n\n      // istanbul ignore next\n      const pathLength =\n        process.env.NODE_ENV === \"test\" ? 50 : path.getTotalLength();\n\n      return list.map<RenderedLineLabel>((item) => {\n        const placement = item.placement ?? \"center\";\n        const offset = 0;\n        // istanbul ignore next\n        const point =\n          process.env.NODE_ENV === \"test\"\n            ? { x: 50, y: 50 }\n            : path.getPointAtLength(\n                placement === \"start\"\n                  ? Math.min(offset, pathLength / 2)\n                  : placement === \"end\"\n                    ? Math.max(pathLength - offset, pathLength / 2)\n                    : pathLength / 2\n              );\n\n        return {\n          [key as \"label\"]: item as LineLabelConf,\n          edge,\n          position: [point.x, point.y],\n          lineRect: { left, top, width, height },\n          id: `${$id}-${placement}`,\n          lineId: $id,\n          placement,\n          angle,\n          size: labelSize?.[placement],\n        };\n      });\n    }\n  );\n}\n","// istanbul ignore file: experimental\nimport type {\n  DiagramEdge,\n  Direction,\n  NormalizedLine,\n  RenderedEdge,\n  RenderedLine,\n  RenderedNode,\n} from \"../interfaces\";\nimport { curveLine } from \"../lines/curveLine\";\nimport { getDirectLinePoints } from \"../lines/getDirectLinePoints\";\nimport { getPolyLinePoints } from \"../lines/getPolyLinePoints\";\nimport { doTwoNodesOverlap } from \"./doTwoNodesOverlap\";\n\nexport function getRenderedLines(\n  renderedEdges: RenderedEdge[],\n  renderedNodes: RenderedNode[],\n  normalizedLines: NormalizedLine[]\n): RenderedLine[] {\n  const renderedEdgeMap = new WeakMap<DiagramEdge, RenderedEdge>();\n  const renderedNodeMap = new Map<string, RenderedNode>();\n  const relatedNodes = new Map<string, Set<RenderedNode>>();\n\n  for (const renderedNode of renderedNodes) {\n    renderedNodeMap.set(renderedNode.id, renderedNode);\n  }\n\n  for (const renderedEdge of renderedEdges) {\n    const { data: edge } = renderedEdge;\n    renderedEdgeMap.set(edge, renderedEdge);\n  }\n\n  let prepared = false;\n  const prepareRelatedNodes = () => {\n    if (prepared) {\n      return;\n    }\n    prepared = true;\n\n    const addRelatedNodes = (from: string, to: string) => {\n      let relates = relatedNodes.get(from);\n      if (!relates) {\n        relatedNodes.set(from, (relates = new Set()));\n      }\n      const toNode = renderedNodeMap.get(to);\n      if (toNode) {\n        relates.add(toNode);\n      }\n    };\n\n    for (const {\n      data: { source, target },\n    } of renderedEdges) {\n      if (source !== target) {\n        addRelatedNodes(source, target);\n        addRelatedNodes(target, source);\n      }\n    }\n  };\n\n  return normalizedLines\n    .map<RenderedLine | undefined>(({ line, edge, markers, ...rest }) => {\n      const renderedEdge = renderedEdgeMap.get(edge);\n      if (!renderedEdge) {\n        return;\n      }\n      const startMarkerOffset =\n        markers.find(\n          (marker) =>\n            marker.variant === \"default\" && marker.placement === \"start\"\n        )?.offset ?? 0;\n      const endMarkerOffset =\n        markers.find(\n          (marker) => marker.variant === \"default\" && marker.placement === \"end\"\n        )?.offset ?? 0;\n      let angle: number | undefined;\n\n      let { points } = renderedEdge;\n      // Only dagre graph will have pre-calculated line points\n      if (!points) {\n        const source = renderedNodeMap.get(edge.source);\n        const target = renderedNodeMap.get(edge.target);\n\n        if (source && target && source !== target) {\n          if (line.type === \"polyline\") {\n            if (\n              !doTwoNodesOverlap(\n                source,\n                target,\n                startMarkerOffset,\n                endMarkerOffset\n              )\n            ) {\n              prepareRelatedNodes();\n              const sourceDirection = getDirection(\n                source,\n                target,\n                startMarkerOffset\n              );\n              const targetDirection = getDirection(\n                target,\n                source,\n                endMarkerOffset\n              );\n              const sourceRelates = getOrderedRelates(\n                relatedNodes.get(edge.source) ?? [],\n                source,\n                sourceDirection,\n                startMarkerOffset\n              );\n              const targetRelates = getOrderedRelates(\n                relatedNodes.get(edge.target) ?? [],\n                target,\n                targetDirection,\n                endMarkerOffset\n              );\n\n              const sourcePosition =\n                (sourceRelates.indexOf(target) + 1) /\n                (sourceRelates.length + 1);\n              const targetPosition =\n                (targetRelates.indexOf(source) + 1) /\n                (targetRelates.length + 1);\n\n              points = getPolyLinePoints(\n                source,\n                target,\n                sourceDirection,\n                targetDirection,\n                sourcePosition,\n                targetPosition\n              );\n            }\n          } else {\n            points = getDirectLinePoints(source, target);\n          }\n\n          if (points) {\n            const start = points[0];\n            const end = points[points.length - 1];\n            angle = Math.atan2(end.y - start.y, end.x - start.x);\n          }\n        }\n      }\n\n      const d = curveLine(\n        points,\n        line.curveType,\n        startMarkerOffset,\n        endMarkerOffset\n      );\n      return {\n        ...rest,\n        markers,\n        line,\n        edge,\n        d,\n        angle,\n        labelSize: renderedEdge.labelSize,\n      };\n    })\n    .filter(Boolean) as RenderedLine[];\n}\n\nfunction getDirection(\n  source: RenderedNode,\n  target: RenderedNode,\n  padding: number\n): Direction {\n  // Add a padding to the source node to avoid the markers being warped.\n  const sourceAngle = Math.atan2(\n    source.height + padding * 2,\n    source.width + padding * 2\n  );\n  const { x: sx, y: sy } = source;\n  const { x: tx, y: ty } = target;\n  const angle = Math.atan2(ty - sy, tx - sx);\n  const fixedAngle = angle < 0 ? Math.PI * 2 + angle : angle;\n  const direction = Math.floor((fixedAngle / Math.PI) * 2);\n  switch (direction) {\n    case 0:\n      return fixedAngle < sourceAngle ? \"right\" : \"bottom\";\n    case 1:\n      return fixedAngle < Math.PI - sourceAngle ? \"bottom\" : \"left\";\n    case 2:\n      return fixedAngle < Math.PI + sourceAngle ? \"left\" : \"top\";\n    default:\n      return fixedAngle < Math.PI * 2 - sourceAngle ? \"top\" : \"right\";\n  }\n}\n\nfunction getOrderedRelates(\n  relates: Iterable<RenderedNode>,\n  from: RenderedNode,\n  direction: Direction,\n  padding: number\n): RenderedNode[] {\n  return [...relates]\n    .filter((node) => getDirection(from, node, padding) === direction)\n    .sort((a, b) => {\n      const { x: ax, y: ay } = a;\n      const { x: bx, y: by } = b;\n      return direction === \"top\" || direction === \"bottom\" ? ax - bx : ay - by;\n    });\n}\n","import { minBy } from \"lodash\";\nimport type {\n  ActiveTarget,\n  DiagramEdge,\n  DiagramNode,\n  RenderedNode,\n} from \"../interfaces\";\n\nexport type KeyboardAction =\n  | KeyboardActionSwitchActiveNode\n  | KeyboardActionDeleteNode\n  | KeyboardActionDeleteEdge;\n\nexport interface KeyboardActionSwitchActiveNode {\n  action: \"switch-active-node\";\n  node?: DiagramNode;\n}\n\nexport interface KeyboardActionDeleteNode {\n  action: \"delete-node\";\n  node: DiagramNode;\n}\n\nexport interface KeyboardActionDeleteEdge {\n  action: \"delete-edge\";\n  edge: DiagramEdge;\n}\n\nexport function handleKeyboard(\n  event: KeyboardEvent,\n  {\n    renderedNodes,\n    activeTarget,\n  }: {\n    renderedNodes: RenderedNode[];\n    activeTarget: ActiveTarget | null | undefined;\n  }\n): KeyboardAction | undefined {\n  const activeNode =\n    activeTarget?.type === \"node\"\n      ? renderedNodes.find((node) => node.id === activeTarget.nodeId)\n      : undefined;\n  const activeEdge =\n    activeTarget?.type === \"edge\" ? activeTarget.edge : undefined;\n\n  if (!activeNode && !activeEdge) {\n    return;\n  }\n\n  const key =\n    event.key ||\n    /* istanbul ignore next: compatibility */ event.keyCode ||\n    /* istanbul ignore next: compatibility */ event.which;\n  let action: KeyboardAction[\"action\"] | undefined;\n  let node: RenderedNode | undefined;\n  let edge: DiagramEdge | undefined;\n\n  switch (key) {\n    case \"Backspace\":\n    case 8:\n    case \"Delete\":\n    case 46: {\n      if (activeNode) {\n        action = \"delete-node\";\n        node = activeNode;\n      } else {\n        action = \"delete-edge\";\n        edge = activeEdge;\n      }\n      break;\n    }\n    default:\n      if (!activeNode) {\n        return;\n      }\n      switch (key) {\n        case \"ArrowLeft\":\n        case 37: {\n          node = moveOnAxis(\"x\", renderedNodes, activeNode, -1);\n          action = \"switch-active-node\";\n          break;\n        }\n        case \"ArrowUp\":\n        case 38: {\n          node = moveOnAxis(\"y\", renderedNodes, activeNode, -1);\n          action = \"switch-active-node\";\n          break;\n        }\n        case \"ArrowRight\":\n        case 39: {\n          node = moveOnAxis(\"x\", renderedNodes, activeNode, 1);\n          action = \"switch-active-node\";\n          break;\n        }\n        case \"ArrowDown\":\n        case 40: {\n          node = moveOnAxis(\"y\", renderedNodes, activeNode, 1);\n          action = \"switch-active-node\";\n          break;\n        }\n      }\n  }\n  if (action) {\n    event.preventDefault();\n    event.stopPropagation();\n    return { action, node: node?.data, edge } as KeyboardAction;\n  }\n}\n\nfunction moveOnAxis(\n  axis: \"x\" | \"y\",\n  renderedNodes: RenderedNode[],\n  activeNode: RenderedNode,\n  direction: 1 | -1\n) {\n  const oppositeAxis = axis === \"x\" ? \"y\" : \"x\";\n  let diff: number;\n  const candidates = renderedNodes.filter(\n    (node) =>\n      node !== activeNode &&\n      ((diff = (node[axis] - activeNode[axis]) * direction), diff > 0) &&\n      diff > Math.abs(activeNode[oppositeAxis] - node[oppositeAxis])\n  );\n  return minBy(\n    candidates,\n    (node) =>\n      (activeNode[oppositeAxis] - node[oppositeAxis]) ** 2 +\n      (activeNode[axis] - node[axis]) ** 2\n  );\n}\n","import { checkIfByTransform, __secret_internals } from \"@next-core/runtime\";\nimport type React from \"react\";\nimport {\n  DEFAULT_LINE_STROKE_COLOR,\n  DEFAULT_LINE_STROKE_WIDTH,\n} from \"../constants\";\nimport type {\n  ConnectLineState,\n  DiagramNode,\n  ConnectLineDetail,\n  ConnectNodesOptions,\n  PositionTuple,\n  RefRepository,\n  ActiveTarget,\n  DragNodesOptions,\n  NodesFilterOptions,\n  NodeMovement,\n  ManualLayoutStatus,\n} from \"../interfaces\";\n\nexport function handleNodesMouseDown(\n  event: MouseEvent,\n  {\n    nodes,\n    nodesRefRepository,\n    connectNodes,\n    dragNodes,\n    scale,\n    setConnectLineState,\n    setConnectLineTo,\n    setManualLayoutStatus,\n    setNodeMovement,\n    onSwitchActiveTarget,\n    onNodesConnect,\n  }: {\n    nodes: DiagramNode[] | undefined;\n    connectNodes: ConnectNodesOptions | undefined;\n    dragNodes: DragNodesOptions | undefined;\n    nodesRefRepository: RefRepository | null;\n    scale: number;\n    setConnectLineState: (\n      value: React.SetStateAction<ConnectLineState | null>\n    ) => void;\n    setConnectLineTo: (value: React.SetStateAction<PositionTuple>) => void;\n    setManualLayoutStatus: (\n      value: React.SetStateAction<ManualLayoutStatus>\n    ) => void;\n    setNodeMovement: (value: React.SetStateAction<NodeMovement | null>) => void;\n    onSwitchActiveTarget?(target: ActiveTarget | null): void;\n    onNodesConnect?(detail: ConnectLineDetail): void;\n  }\n) {\n  function findNode(match: (element: HTMLElement) => boolean) {\n    if (nodesRefRepository) {\n      for (const [id, element] of nodesRefRepository) {\n        if (match(element)) {\n          return nodes?.find((node) => node.id === id);\n        }\n      }\n    }\n  }\n\n  if (!connectNodes && !dragNodes) {\n    return;\n  }\n\n  const source = findNode((element) =>\n    element.contains(event.target as Node | null)\n  );\n\n  if (!source) {\n    return;\n  }\n\n  if (!nodeMatched(connectNodes || dragNodes!, source)) {\n    return;\n  }\n\n  event.stopPropagation();\n  const from: PositionTuple = [event.clientX, event.clientY];\n\n  if (connectNodes) {\n    setConnectLineState({\n      from,\n      options: {\n        strokeColor: DEFAULT_LINE_STROKE_COLOR,\n        strokeWidth: DEFAULT_LINE_STROKE_WIDTH,\n        ...(__secret_internals.legacyDoTransform(\n          { source },\n          connectNodes\n        ) as ConnectNodesOptions),\n      },\n    });\n    setConnectLineTo(from);\n\n    onSwitchActiveTarget?.({ type: \"node\", nodeId: source.id });\n\n    const onMouseMove = (e: MouseEvent) => {\n      setConnectLineTo([e.clientX, e.clientY]);\n    };\n    const onMouseUp = (e: MouseEvent) => {\n      document.removeEventListener(\"mousemove\", onMouseMove);\n      document.removeEventListener(\"mouseup\", onMouseUp);\n      setConnectLineState(null);\n      const eventTargets = e.composedPath();\n      const target = findNode((element) => eventTargets.includes(element));\n      if (target && source !== target) {\n        onNodesConnect?.({ source, target });\n      }\n    };\n    document.addEventListener(\"mousemove\", onMouseMove);\n    document.addEventListener(\"mouseup\", onMouseUp);\n    return;\n  }\n\n  // Drag node\n  onSwitchActiveTarget?.({ type: \"node\", nodeId: source.id });\n\n  let moved = false;\n  const onMouseMove = (e: MouseEvent) => {\n    // Respect the scale\n    const movement: PositionTuple = [\n      (e.clientX - from[0]) / scale,\n      (e.clientY - from[1]) / scale,\n    ];\n    if (!moved) {\n      moved = movement[0] ** 2 + movement[1] ** 2 >= 9;\n      if (moved) {\n        setManualLayoutStatus(\"started\");\n      }\n    }\n    if (moved) {\n      setNodeMovement({ id: source.id, move: movement });\n    }\n  };\n  const onMouseUp = () => {\n    moved = false;\n    document.removeEventListener(\"mousemove\", onMouseMove);\n    document.removeEventListener(\"mouseup\", onMouseUp);\n    setNodeMovement(null);\n    setManualLayoutStatus(\"finished\");\n  };\n  document.addEventListener(\"mousemove\", onMouseMove);\n  document.addEventListener(\"mouseup\", onMouseUp);\n}\n\nfunction nodeMatched(\n  options: NodesFilterOptions,\n  source: DiagramNode\n): boolean {\n  return options.sourceType\n    ? ([] as unknown[]).concat(options.sourceType).includes(source.type)\n    : checkIfByTransform(options, { source });\n}\n","import { checkIfByTransform } from \"@next-core/runtime\";\nimport type { DiagramEdge, LineConf } from \"../interfaces\";\n\nexport function matchEdgeByFilter(\n  edge: DiagramEdge,\n  filter: LineConf\n): boolean {\n  if (!filter) {\n    return false;\n  }\n  if (filter.edgeType) {\n    return ([] as string[]).concat(filter.edgeType).includes(edge.type!);\n  }\n  return checkIfByTransform(filter, { edge });\n}\n","import { findIndex, uniqueId } from \"lodash\";\nimport { __secret_internals } from \"@next-core/runtime\";\nimport type {\n  DiagramEdge,\n  LineConf,\n  LineMarker,\n  LineMarkerConf,\n  LineMarkerType,\n  NormalizedLine,\n  NormalizedLineMarker,\n} from \"../interfaces\";\nimport { matchEdgeByFilter } from \"./matchEdgeByFilter\";\nimport {\n  DEFAULT_LINE_CURVE_TYPE,\n  DEFAULT_LINE_INTERACT_STROKE_WIDTH,\n  DEFAULT_LINE_STROKE_COLOR,\n  DEFAULT_LINE_STROKE_WIDTH,\n} from \"../constants\";\n\nexport function normalizeLinesAndMarkers(\n  edges: DiagramEdge[] | undefined,\n  lines: LineConf[] | undefined\n) {\n  const normalizedLines: NormalizedLine[] = [];\n  const normalizedLinesMap = new WeakMap<DiagramEdge, string>();\n  const markers: LineMarker[] = [];\n  for (const edge of edges ?? []) {\n    const { label, ...restLineConf } =\n      lines?.find((line) => matchEdgeByFilter(edge, line)) ?? {};\n\n    const computedLineConf = __secret_internals.legacyDoTransform(\n      { edge },\n      restLineConf\n    ) as LineConf | undefined;\n    if (computedLineConf?.draw === false) {\n      continue;\n    }\n    const id = uniqueId(\"line-\");\n    const line: NormalizedLine[\"line\"] = {\n      strokeColor: DEFAULT_LINE_STROKE_COLOR,\n      strokeWidth: DEFAULT_LINE_STROKE_WIDTH,\n      curveType:\n        computedLineConf?.type === \"polyline\"\n          ? \"curveLinear\"\n          : DEFAULT_LINE_CURVE_TYPE,\n      interactStrokeWidth: DEFAULT_LINE_INTERACT_STROKE_WIDTH,\n      type: \"auto\",\n      ...computedLineConf,\n      label,\n      $id: id,\n    };\n    normalizedLinesMap.set(edge, id);\n\n    const normalizedMarkers: NormalizedLineMarker[] = [];\n\n    const lineMarkers: LineMarkerConf[] =\n      line.markers ?? (line.arrow ? [{ placement: \"end\", type: \"arrow\" }] : []);\n    for (const marker of lineMarkers) {\n      const { placement: _placement, type: _type } = marker;\n      const placement = _placement ?? \"end\";\n\n      let type: LineMarkerType;\n      let offsetUnit: number;\n\n      switch (_type) {\n        case \"0..1\":\n        case \"0..N\":\n          offsetUnit = 21;\n          type = _type;\n          break;\n        default:\n          offsetUnit = 1;\n          type = \"arrow\";\n      }\n      const offset = offsetUnit * line.strokeWidth;\n\n      const index = addMarker({ type, strokeColor: line.strokeColor }, markers);\n      normalizedMarkers.push({\n        index,\n        placement,\n        type,\n        variant: \"default\",\n        offset,\n      });\n\n      const activeStrokeColor =\n        line.overrides?.active?.strokeColor ?? line.strokeColor;\n      const activeMarkerIndex = addMarker(\n        { type, strokeColor: activeStrokeColor },\n        markers\n      );\n      normalizedMarkers.push({\n        index: activeMarkerIndex,\n        placement,\n        type,\n        variant: \"active\",\n        offset,\n      });\n      const activeRelatedStrokeColor =\n        line.overrides?.activeRelated?.strokeColor ?? line.strokeColor;\n      const activeRelatedMarkerIndex = addMarker(\n        { type, strokeColor: activeRelatedStrokeColor },\n        markers\n      );\n      normalizedMarkers.push({\n        index: activeRelatedMarkerIndex,\n        placement,\n        type,\n        variant: \"active-related\",\n        offset,\n      });\n    }\n\n    normalizedLines.push({\n      line,\n      markers: normalizedMarkers,\n      edge,\n    });\n  }\n  return {\n    normalizedLines,\n    normalizedLinesMap,\n    markers,\n  };\n}\n\nfunction addMarker(marker: LineMarker, markers: LineMarker[]): number {\n  let markerIndex = findIndex(markers, marker);\n  if (markerIndex === -1) {\n    markerIndex = markers.push(marker) - 1;\n  }\n  return markerIndex;\n}\n","import type {\n  ActiveTarget,\n  ActiveTargetOfEdge,\n  ActiveTargetOfNode,\n} from \"../interfaces\";\n\nexport function sameTarget(\n  a: ActiveTarget | null | undefined,\n  b: ActiveTarget | null | undefined\n): boolean {\n  return a\n    ? !!b &&\n        a.type === b.type &&\n        (a.type === \"node\"\n          ? a.nodeId === (b as ActiveTargetOfNode).nodeId\n          : a.edge.source === (b as ActiveTargetOfEdge).edge.source &&\n            a.edge.target === (b as ActiveTargetOfEdge).edge.target)\n    : !b;\n}\n","import type { RenderedNode, TransformLiteral } from \"../interfaces\";\n\nexport interface TransformToCenterOptions {\n  canvasWidth: number;\n  canvasHeight: number;\n  scaleRange?: [min: number, max: number];\n}\n\nexport function transformToCenter(\n  renderedNodes: RenderedNode[],\n  { canvasWidth, canvasHeight, scaleRange }: TransformToCenterOptions\n): TransformLiteral {\n  let left = Infinity;\n  let top = Infinity;\n  let right = -Infinity;\n  let bottom = -Infinity;\n  for (const node of renderedNodes) {\n    const hw = node.width / 2;\n    const hh = node.height / 2;\n    const l = node.x - hw;\n    const r = node.x + hw;\n    const t = node.y - hh;\n    const b = node.y + hh;\n    if (l < left) {\n      left = l;\n    }\n    if (r > right) {\n      right = r;\n    }\n    if (t < top) {\n      top = t;\n    }\n    if (b > bottom) {\n      bottom = b;\n    }\n  }\n\n  const width = right - left;\n  const height = bottom - top;\n\n  const scale =\n    scaleRange && (width > canvasWidth || height > canvasHeight)\n      ? Math.max(\n          Math.min(canvasWidth / width, canvasHeight / height, scaleRange[1]),\n          scaleRange[0]\n        )\n      : 1;\n\n  const x = (canvasWidth - width * scale) / 2 - left * scale;\n  const y = (canvasHeight - height * scale) / 2 - top * scale;\n\n  return { x, y, k: scale };\n}\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `:host{display:block;width:100%;height:100%;overflow:hidden}:host([hidden]){display:none}*{box-sizing:border-box}.diagram{width:100%;height:100%;position:relative;opacity:0}.diagram:focus{outline:none}.lines,\n.line-labels,\n.nodes{position:absolute;top:0;left:0}.line-labels{opacity:0}.ready{opacity:1}.diagram.ready.pannable{cursor:grab}.diagram.pannable.grabbing{cursor:grabbing}.nodes,\n.lines{transform-origin:0 0}.node,\n.line-label{position:absolute;visibility:hidden}.line-label{transform:translate(-50%,-50%);white-space:pre-line;width:max-content;text-align:center;line-height:1}.lines{pointer-events:none}.line.interactable{pointer-events:auto;cursor:default}.connect-line{position:fixed;top:0;left:0;right:0;bottom:0;pointer-events:none}.connect-line:not(.connecting){display:none}.line:not(.active) .active-bg{display:none}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___.toString();\n"],"names":["ConnectLineComponent","_ref","connectLineState","connectLineTo","markerPrefix","React","width","height","className","classNames","connecting","from","MarkerComponent","type","id","strokeColor","options","d","join","fill","stroke","strokeWidth","markerEnd","arrow","undefined","LineComponent","_line$overrides","_line$overrides2","line","edge","markers","linePaths","lineMaskRects","maskPrefix","activeLineMarkerPrefix","active","activeRelated","onLineClick","onLineDoubleClick","mask","has","$id","interactStrokeWidth","overrides","expectVariant","markerStart","marker","variant","placement","index","interactable","onClick","onDoubleClick","e","preventDefault","stopPropagation","style","cursor","ref","element","set","LineLabelComponentGroup","labels","onRendered","rendered","setRendered","useState","renderedIds","setRenderedIds","refRepository","useMemo","Map","handleRenderer","useCallback","previous","includes","concat","handleUnmount","indexOf","slice","delete","useEffect","some","label","map","_ref2","text","key","LineLabelComponent","onUnmount","LineTextComponent","_ref3","refCallback","content","_ref4","useBrick","checkIfByTransform","memoizedData","setTimeout","parentElement","ignoredCallback","ReactUseBrick","data","LineMaskComponent","lineId","rects","renderedLineLabels","lineText","find","item","lineRect","bgRect","padding","left","rect","top","x","y","NodeComponentGroup","nodes","nodeBricks","node","NodeComponent","_findNodeBrick","nodeType","findNodeBrick","DEFAULT_LINE_STROKE_COLOR","DEFAULT_LINE_STROKE_WIDTH","DEFAULT_LINE_CURVE_TYPE","DEFAULT_LINE_INTERACT_STROKE_WIDTH","DEFAULT_SCALE_RANGE_MIN","DEFAULT_SCALE_RANGE_MAX","adjustNodesSize","nodesRefRepository","nodePaddings","get","Math","max","offsetWidth","offsetHeight","adjustNodesPosition","_nodesRefRepository$g","nodeContainer","visibility","getRenderedEdges","edges","normalizedLinesMap","lineLabelsRefRepository","labelSize","getDummyNodes","count","Array","v","i","dummy","source","target","getDummyEdges","useRenderedDiagram","layout","originalLayout","manualLayoutStatus","userViewReady","userViewNodesMap","nodeMovement","nodesRenderId","lineLabelsRenderId","layoutOptions","graph","setGraph","renderedDiagram","setRenderedDiagram","previousGraph","dagreLayoutOptions","nodePadding","dagreGraphOptions","rankdir","ranksep","edgesep","nodesep","pick","extractPartialRectTuple","dagre","Graph","setDefaultEdgeLabel","previousNode","getNode","setNode","setEdge","applyLayout","renderedNodes","push","console","error","length","renderedEdges","labelpos","getDagreGraph","forceLayoutOptions","dummyNodesOnEdges","collide","dummyRadius","radiusDiff","strength","iterations","renderedNode","userViewNode","fx","fy","forceNodes","forceLinks","linkSimulation","forceLink","distance","l","simulation","forceSimulation","force","forceX","forceY","forceManyBody","forceCollide","radius","sqrt","stop","tick","ceil","log","alphaMin","alphaDecay","manuallyTickToTheEnd","getForceGraph","x0","y0","movedNode","move","getManualGraph","InstanceApi_postSearchV3","objectId","http","post","_x","_x2","_x3","apply","this","arguments","InstanceApi_updateInstanceV2","instanceId","put","_x4","InstanceApi_createInstance","USER_VIEW_MODEL_ID","useUserView","query","setUserViewReady","userViewIdRef","useRef","setUserViewNodesMap","queue","working","waitingTasks","async","task","nextTask","shift","createAsyncQueue","namespace","list","fields","$eq","page","page_size","_userView$nodes","userView","current","handleHttpError","getUserView","saveUserView","userViewData","interceptorParams","ignoreLoadingBar","adjustLineLabels","position","angle","size","_size","tempDirection","floor","PI","direction","tangent","tan","offsetAngle","offset","offsetSin","sin","offsetCos","cos","transform","getLineMaskRects","offsetLeft","offsetTop","getRenderedLineLabels","renderedLines","flatMap","path","getAttribute","getBBox","pathLength","getTotalLength","point","getPointAtLength","min","getRenderedLines","normalizedLines","renderedEdgeMap","WeakMap","renderedNodeMap","relatedNodes","renderedEdge","prepared","_markers$find","_markers$find2","rest","startMarkerOffset","endMarkerOffset","points","doTwoNodesOverlap","prepareRelatedNodes","addRelatedNodes","to","relates","Set","toNode","add","sourceDirection","getDirection","targetDirection","sourceRelates","getOrderedRelates","targetRelates","sourcePosition","targetPosition","getPolyLinePoints","getDirectLinePoints","start","end","atan2","curveLine","curveType","filter","Boolean","sourceAngle","sx","sy","tx","ty","fixedAngle","sort","a","b","ax","ay","bx","by","handleKeyboard","event","activeTarget","activeNode","nodeId","activeEdge","keyCode","which","action","moveOnAxis","_node","axis","oppositeAxis","diff","candidates","abs","minBy","handleNodesMouseDown","connectNodes","dragNodes","scale","setConnectLineState","setConnectLineTo","setManualLayoutStatus","setNodeMovement","onSwitchActiveTarget","onNodesConnect","findNode","match","contains","sourceType","nodeMatched","clientX","clientY","__secret_internals","legacyDoTransform","onMouseMove","onMouseUp","document","removeEventListener","eventTargets","composedPath","addEventListener","moved","movement","matchEdgeByFilter","edgeType","normalizeLinesAndMarkers","lines","restLineConf","computedLineConf","draw","uniqueId","normalizedMarkers","lineMarkers","_placement","_type","offsetUnit","addMarker","activeMarkerIndex","activeRelatedMarkerIndex","markerIndex","findIndex","sameTarget","transformToCenter","canvasWidth","canvasHeight","scaleRange","Infinity","right","bottom","hw","hh","r","t","k","___CSS_LOADER_EXPORT___","module","toString"],"sourceRoot":""}