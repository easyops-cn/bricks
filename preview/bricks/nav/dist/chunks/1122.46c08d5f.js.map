{"version":3,"file":"chunks/1122.46c08d5f.js","mappings":"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","sources":["webpack:///../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack:///../../node_modules/@babel/runtime/helpers/esm/typeof.js","webpack:///../../node_modules/@next-core/cook/dist/esm/ExecutionContext.js","webpack:///../../node_modules/@next-core/cook/dist/esm/traverse.js","webpack:///../../node_modules/@next-core/cook/dist/esm/context-free.js","webpack:///../../node_modules/@next-core/cook/dist/esm/sanitize.js","webpack:///../../node_modules/@next-core/cook/dist/esm/cook.js","webpack:///../../node_modules/@next-core/cook/dist/esm/AnalysisContext.js","webpack:///../../node_modules/@next-core/cook/dist/esm/precook.js","webpack:///../../node_modules/@next-core/cook/dist/esm/hasOwnProperty.js","webpack:///../../node_modules/@next-core/cook/dist/esm/precookFunction.js","webpack:///../../node_modules/@next-core/cook/dist/esm/parse.js","webpack:///../../node_modules/@next-core/cook/dist/esm/preevaluate.js"],"sourcesContent":["import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}","import _typeof from \"./typeof.js\";\nexport default function toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}","export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nexport let Mode = /*#__PURE__*/function (Mode) {\n  Mode[Mode[\"LEXICAL\"] = 0] = \"LEXICAL\";\n  Mode[Mode[\"STRICT\"] = 1] = \"STRICT\";\n  return Mode;\n}({});\nexport const SourceNode = Symbol.for(\"SourceNode\");\nexport const FormalParameters = Symbol.for(\"FormalParameters\");\nexport const ECMAScriptCode = Symbol.for(\"ECMAScriptCode\");\nexport const Environment = Symbol.for(\"Environment\");\nexport const IsConstructor = Symbol.for(\"IsConstructor\");\nexport const ThisMode = Symbol.for(\"ThisMode\");\nexport const DebuggerCall = Symbol.for(\"$DebuggerCall$\");\nexport const DebuggerScope = Symbol.for(\"$DebuggerScope$\");\nexport const DebuggerNode = Symbol.for(\"$DebuggerNode$\");\nexport const DebuggerReturn = Symbol.for(\"$DebuggerReturn$\");\n\n// https://tc39.es/ecma262/#sec-execution-contexts\nexport class ExecutionContext {\n  constructor() {\n    _defineProperty(this, \"VariableEnvironment\", void 0);\n    _defineProperty(this, \"LexicalEnvironment\", void 0);\n    _defineProperty(this, \"Function\", void 0);\n  }\n}\nexport let BindingStatus = /*#__PURE__*/function (BindingStatus) {\n  BindingStatus[BindingStatus[\"UNINITIALIZED\"] = 0] = \"UNINITIALIZED\";\n  BindingStatus[BindingStatus[\"LEXICAL\"] = 1] = \"LEXICAL\";\n  BindingStatus[BindingStatus[\"INITIALIZED\"] = 2] = \"INITIALIZED\";\n  return BindingStatus;\n}({});\n\n// https://tc39.es/ecma262/#sec-environment-records\nexport class EnvironmentRecord {\n  constructor(outer) {\n    _defineProperty(this, \"OuterEnv\", void 0);\n    _defineProperty(this, \"bindingMap\", new Map());\n    _defineProperty(this, \"ThisValue\", undefined);\n    _defineProperty(this, \"ThisBindingStatus\", void 0);\n    this.OuterEnv = outer;\n  }\n  HasBinding(name) {\n    return this.bindingMap.has(name);\n  }\n  CreateMutableBinding(name, deletable) {\n    // Assert: binding does not exist.\n    this.bindingMap.set(name, {\n      mutable: true,\n      deletable\n    });\n    return NormalCompletion(undefined);\n  }\n\n  /**\n   * Create an immutable binding.\n   *\n   * @param name - The binding name.\n   * @param strict - For named function expressions, strict is false, otherwise it's true.\n   * @returns CompletionRecord.\n   */\n  CreateImmutableBinding(name, strict) {\n    // Assert: binding does not exist.\n    this.bindingMap.set(name, {\n      strict\n    });\n    return NormalCompletion(undefined);\n  }\n  InitializeBinding(name, value) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists and uninitialized.\n    Object.assign(binding, {\n      initialized: true,\n      value\n    });\n    return NormalCompletion(undefined);\n  }\n\n  /**\n   * Update a mutable binding value, including function declarations.\n   *\n   * @param name - The binding name.\n   * @param value - The binding value.\n   * @param strict - For functions, strict is always false, otherwise it depends on strict-mode.\n   * @returns\n   */\n  SetMutableBinding(name, value, _strict) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists.\n    if (!binding.initialized) {\n      throw new ReferenceError(`${name} is not initialized`);\n    } else if (binding.mutable) {\n      binding.value = value;\n    } else {\n      throw new TypeError(`Assignment to constant variable`);\n    }\n    return NormalCompletion(undefined);\n  }\n  GetBindingValue(name, _strict) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists.\n    if (!binding.initialized) {\n      throw new ReferenceError(`${name} is not initialized`);\n    }\n    return binding.value;\n  }\n  HasThisBinding() {\n    return false;\n  }\n}\nexport class DeclarativeEnvironment extends EnvironmentRecord {}\nexport class FunctionEnvironment extends EnvironmentRecord {\n  constructor(F) {\n    super(F[Environment]);\n    if (F[ThisMode] === Mode.LEXICAL) {\n      this.ThisBindingStatus = BindingStatus.LEXICAL;\n    } else {\n      this.ThisBindingStatus = BindingStatus.UNINITIALIZED;\n    }\n  }\n  HasThisBinding() {\n    return this.ThisBindingStatus !== BindingStatus.LEXICAL;\n  }\n  BindThisValue(value) {\n    // Assert: envRec.[[ThisBindingStatus]] is not LEXICAL.\n    if (this.ThisBindingStatus === BindingStatus.INITIALIZED) {\n      throw new Error(\"This binding has been initialized\");\n    }\n    this.ThisValue = value;\n    this.ThisBindingStatus = BindingStatus.INITIALIZED;\n  }\n  GetThisBinding() {\n    // Assert: envRec.[[ThisBindingStatus]] is not LEXICAL.\n    if (this.ThisBindingStatus === BindingStatus.UNINITIALIZED) {\n      throw new Error(\"This binding is not initialized\");\n    }\n    return this.ThisValue;\n  }\n}\n// https://tc39.es/ecma262/#sec-reference-record-specification-type\nexport class ReferenceRecord {\n  constructor(base, referenceName, strict) {\n    _defineProperty(this, \"Base\", void 0);\n    _defineProperty(this, \"ReferenceName\", void 0);\n    /** Whether the reference is in strict mode. */\n    _defineProperty(this, \"Strict\", void 0);\n    this.Base = base;\n    this.ReferenceName = referenceName;\n    this.Strict = strict;\n  }\n}\n\n// https://tc39.es/ecma262/#sec-completion-record-specification-type\nexport class CompletionRecord {\n  constructor(type, value) {\n    _defineProperty(this, \"Type\", void 0);\n    _defineProperty(this, \"Value\", void 0);\n    this.Type = type;\n    this.Value = value;\n  }\n}\n// https://tc39.es/ecma262/#sec-normalcompletion\nexport function NormalCompletion(value) {\n  return new CompletionRecord(\"normal\", value);\n}\nexport const Empty = Symbol(\"empty completion\");\n//# sourceMappingURL=ExecutionContext.js.map","export function collectBoundNames(root) {\n  const names = new Set();\n  const collect = node => {\n    if (Array.isArray(node)) {\n      for (const n of node) {\n        collect(n);\n      }\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"Identifier\":\n          names.add(node.name);\n          return;\n        case \"VariableDeclaration\":\n          return collect(node.declarations);\n        case \"VariableDeclarator\":\n          return collect(node.id);\n        case \"ArrayPattern\":\n          return collect(node.elements);\n        case \"AssignmentPattern\":\n          return collect(node.left);\n        case \"ObjectPattern\":\n          return collect(node.properties);\n        case \"Property\":\n          return collect(node.value);\n        case \"RestElement\":\n          return collect(node.argument);\n        case \"FunctionDeclaration\":\n          return collect(node.id);\n      }\n    }\n  };\n  collect(root);\n  return Array.from(names);\n}\nexport function containsExpression(root) {\n  const collect = node => {\n    if (Array.isArray(node)) {\n      return node.some(collect);\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"ArrayPattern\":\n          return collect(node.elements);\n        case \"AssignmentPattern\":\n          return true;\n        case \"ObjectPattern\":\n          return collect(node.properties);\n        case \"Property\":\n          return node.computed || collect(node.value);\n        case \"RestElement\":\n          return collect(node.argument);\n      }\n    }\n  };\n  return collect(root);\n}\nexport function collectScopedDeclarations(root, options) {\n  const declarations = [];\n  const nextOptions = {\n    var: options.var\n  };\n  const collect = (node, options) => {\n    if (Array.isArray(node)) {\n      for (const n of node) {\n        collect(n, options);\n      }\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"FunctionDeclaration\":\n          // At the top level of a function, or script, function declarations are\n          // treated like var declarations rather than like lexical declarations.\n          // See https://tc39.es/ecma262/#sec-static-semantics-toplevellexicallydeclarednames\n          if (Number(!options.var) ^ Number(options.topLevel)) {\n            declarations.push(node);\n          }\n          return;\n        case \"VariableDeclaration\":\n          if (Number(!options.var) ^ Number(node.kind === \"var\")) {\n            declarations.push(node);\n          }\n          return;\n        case \"SwitchCase\":\n          collect(node.consequent, nextOptions);\n          return;\n        case \"CatchClause\":\n          collect(node.body, nextOptions);\n          return;\n      }\n      if (options.var) {\n        switch (node.type) {\n          case \"BlockStatement\":\n            collect(node.body, nextOptions);\n            return;\n          case \"IfStatement\":\n            collect(node.consequent, nextOptions);\n            collect(node.alternate, nextOptions);\n            return;\n          case \"DoWhileStatement\":\n          case \"WhileStatement\":\n            collect(node.body, nextOptions);\n            return;\n          case \"ForStatement\":\n            collect(node.init, nextOptions);\n            collect(node.body, nextOptions);\n            return;\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            collect(node.left, nextOptions);\n            collect(node.body, nextOptions);\n            return;\n          case \"SwitchStatement\":\n            collect(node.cases, nextOptions);\n            return;\n          case \"TryStatement\":\n            collect(node.block, nextOptions);\n            collect(node.handler, nextOptions);\n            collect(node.finalizer, nextOptions);\n            return;\n        }\n      }\n    }\n  };\n  collect(root, options);\n  return declarations;\n}\n//# sourceMappingURL=traverse.js.map","import { CompletionRecord, Empty, EnvironmentRecord, NormalCompletion, ReferenceRecord } from \"./ExecutionContext.js\";\nimport { collectBoundNames } from \"./traverse.js\";\n\n// https://tc39.es/ecma262/#sec-ispropertyreference\nexport function IsPropertyReference(V) {\n  return V.Base !== \"unresolvable\" && !(V.Base instanceof EnvironmentRecord);\n}\n\n// https://tc39.es/ecma262/#sec-initializereferencedbinding\nexport function InitializeReferencedBinding(V, W) {\n  const base = V.Base;\n  return base.InitializeBinding(V.ReferenceName, W);\n}\n\n// https://tc39.es/ecma262/#sec-copydataproperties\nexport function CopyDataProperties(target, source, excludedItems) {\n  if (source === undefined || source === null) {\n    return target;\n  }\n  const keys = Object.getOwnPropertyNames(source).concat(Object.getOwnPropertySymbols(source));\n  for (const nextKey of keys) {\n    if (!excludedItems.has(nextKey)) {\n      const desc = Object.getOwnPropertyDescriptor(source, nextKey);\n      if (desc !== null && desc !== void 0 && desc.enumerable) {\n        target[nextKey] = source[nextKey];\n      }\n    }\n  }\n  return target;\n}\n\n// https://tc39.es/ecma262/#sec-runtime-semantics-fordeclarationbindinginstantiation\nexport function ForDeclarationBindingInstantiation(forDeclaration, env) {\n  const isConst = forDeclaration.kind === \"const\";\n  for (const name of collectBoundNames(forDeclaration)) {\n    if (isConst) {\n      env.CreateImmutableBinding(name, true);\n    } else {\n      env.CreateMutableBinding(name, false);\n    }\n  }\n}\n\n// https://tc39.es/ecma262/#sec-loopcontinues\nexport function LoopContinues(completion) {\n  return completion.Type === \"normal\" || completion.Type == \"continue\";\n}\n\n// https://tc39.es/ecma262/#sec-updateempty\nexport function UpdateEmpty(completion, value) {\n  if (completion.Value !== Empty) {\n    return completion;\n  }\n  return new CompletionRecord(completion.Type, value);\n}\n\n// https://tc39.es/ecma262/#sec-getvalue\nexport function GetValue(V) {\n  if (V instanceof CompletionRecord) {\n    // Assert: V.Type is normal.\n    V = V.Value;\n  }\n  if (!(V instanceof ReferenceRecord)) {\n    return V;\n  }\n  if (V.Base === \"unresolvable\") {\n    throw new ReferenceError(`${V.ReferenceName} is not defined`);\n  }\n  if (V.Base instanceof EnvironmentRecord) {\n    const base = V.Base;\n    return base.GetBindingValue(V.ReferenceName, V.Strict);\n  }\n  return V.Base[V.ReferenceName];\n}\n\n// https://tc39.es/ecma262/#sec-topropertykey\nexport function ToPropertyKey(arg) {\n  if (typeof arg === \"symbol\") {\n    return arg;\n  }\n  return String(arg);\n}\n\n// https://tc39.es/ecma262/#sec-getv\nexport function GetV(V, P) {\n  return V[P];\n}\n\n// https://tc39.es/ecma262/#sec-putvalue\nexport function PutValue(V, W) {\n  // Assert: V is a ReferenceRecord.\n  if (V.Base === \"unresolvable\") {\n    throw new ReferenceError(`${V.ReferenceName} is not defined`);\n  }\n  if (V.Base instanceof EnvironmentRecord) {\n    return V.Base.SetMutableBinding(V.ReferenceName, W, V.Strict);\n  }\n  V.Base[V.ReferenceName] = W;\n  return NormalCompletion(undefined);\n}\n\n// https://tc39.es/ecma262/#sec-createlistiteratorRecord\nexport function CreateListIteratorRecord(args) {\n  if (!isIterable(args)) {\n    throw new TypeError(`${typeof args} is not iterable`);\n  }\n  return args[Symbol.iterator]();\n}\n\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nexport function RequireObjectCoercible(arg) {\n  if (arg === null || arg === undefined) {\n    throw new TypeError(\"Cannot destructure properties of undefined or null\");\n  }\n}\n\n// https://tc39.es/ecma262/#sec-getidentifierreference\nexport function GetIdentifierReference(env, name, strict) {\n  if (!env) {\n    return new ReferenceRecord(\"unresolvable\", name, strict);\n  }\n  if (env.HasBinding(name)) {\n    return new ReferenceRecord(env, name, strict);\n  }\n  return GetIdentifierReference(env.OuterEnv, name, strict);\n}\n\n// https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator\nexport function ApplyStringOrNumericBinaryOperator(leftValue, operator, rightValue) {\n  switch (operator) {\n    case \"+\":\n      return leftValue + rightValue;\n    case \"-\":\n      return leftValue - rightValue;\n    case \"/\":\n      return leftValue / rightValue;\n    case \"%\":\n      return leftValue % rightValue;\n    case \"*\":\n      return leftValue * rightValue;\n    case \"**\":\n      return leftValue ** rightValue;\n    case \"==\":\n      return leftValue == rightValue;\n    case \"===\":\n      return leftValue === rightValue;\n    case \"!=\":\n      return leftValue != rightValue;\n    case \"!==\":\n      return leftValue !== rightValue;\n    case \">\":\n      return leftValue > rightValue;\n    case \"<\":\n      return leftValue < rightValue;\n    case \">=\":\n      return leftValue >= rightValue;\n    case \"<=\":\n      return leftValue <= rightValue;\n    case \"in\":\n      return leftValue in rightValue;\n  }\n  throw new SyntaxError(`Unsupported binary operator \\`${operator}\\``);\n}\n\n// https://tc39.es/ecma262/#sec-assignment-operators\nexport function ApplyStringOrNumericAssignment(leftValue, operator, rightValue) {\n  switch (operator) {\n    case \"+=\":\n    case \"-=\":\n    case \"*=\":\n    case \"/=\":\n    case \"%=\":\n    case \"**=\":\n      return ApplyStringOrNumericBinaryOperator(leftValue, operator.substr(0, operator.length - 1), rightValue);\n  }\n  throw new SyntaxError(`Unsupported assignment operator \\`${operator}\\``);\n}\n\n// https://tc39.es/ecma262/#sec-unary-operators\nexport function ApplyUnaryOperator(target, operator) {\n  switch (operator) {\n    case \"!\":\n      return !target;\n    case \"+\":\n      return +target;\n    case \"-\":\n      return -target;\n    case \"void\":\n      return undefined;\n  }\n  throw new SyntaxError(`Unsupported unary operator \\`${operator}\\``);\n}\nexport function isIterable(cooked) {\n  if (Array.isArray(cooked)) {\n    return true;\n  }\n  if (cooked === null || cooked === undefined) {\n    return false;\n  }\n  return typeof cooked[Symbol.iterator] === \"function\";\n}\n//# sourceMappingURL=context-free.js.map","// Ref https://github.com/tc39/proposal-global\n// In addition, the es6-shim had to switch from Function('return this')()\n// due to CSP concerns, such that the current check to handle browsers,\n// node, web workers, and frames is:\n// istanbul ignore next\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getGlobal() {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}\n\n/**\n * There are chances to construct a `Function` from a string, etc.\n * ```\n * ((a,b)=>a[b])(()=>1, 'constructor')('console.log(`yo`)')()\n * ```\n */\nconst reservedObjects = new WeakSet([\n// `Function(\"...\")` is considered *extremely vulnerable*.\nFunction,\n// `Object.assign()` is considered vulnerable.\nObject,\n// `prototype` is considered vulnerable.\nFunction.prototype, Object.prototype,\n// Global `window` is considered vulnerable, too.\ngetGlobal()]);\nexport function sanitize(cooked) {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  if (reservedObjects.has(cooked)) {\n    throw new TypeError(\"Cannot access reserved objects such as `Function`.\");\n  }\n}\nconst allowedConstructors = new WeakSet([Array, Map, Set, URL, URLSearchParams, WeakMap, WeakSet, RegExp]);\nexport function isAllowedConstructor(constructor) {\n  // `Date` maybe mocked when running tests for storyboard functions.\n  return allowedConstructors.has(constructor) || constructor === Date;\n}\n//# sourceMappingURL=sanitize.js.map","import { ApplyStringOrNumericAssignment, CreateListIteratorRecord, ApplyStringOrNumericBinaryOperator, GetV, GetValue, InitializeReferencedBinding, IsPropertyReference, LoopContinues, PutValue, RequireObjectCoercible, ToPropertyKey, UpdateEmpty, ApplyUnaryOperator, GetIdentifierReference, ForDeclarationBindingInstantiation, CopyDataProperties } from \"./context-free.js\";\nimport { CompletionRecord, DebuggerCall, DebuggerNode, DebuggerReturn, DebuggerScope, DeclarativeEnvironment, ECMAScriptCode, Empty, Environment, ExecutionContext, FormalParameters, FunctionEnvironment, IsConstructor, NormalCompletion, ReferenceRecord, SourceNode, Mode, ThisMode } from \"./ExecutionContext.js\";\nimport { sanitize, isAllowedConstructor } from \"./sanitize.js\";\nimport { collectBoundNames, collectScopedDeclarations, containsExpression } from \"./traverse.js\";\nconst globalExecutionContextStack = [];\nexport function __dev_only_clearGlobalExecutionContextStack() {\n  globalExecutionContextStack.length = 0;\n}\nexport function __dev_only_getGlobalExecutionContextStack() {\n  return globalExecutionContextStack;\n}\n\n/** For next-core internal usage only. */\nexport function cook(rootAst, codeSource) {\n  var _hooks$beforeEvaluate4;\n  let {\n    rules,\n    debug,\n    externalSourceForDebug,\n    globalVariables = {},\n    // Allow debugger to override Array constructor.\n    ArrayConstructor = Array,\n    hooks = {}\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const expressionOnly = rootAst.type !== \"FunctionDeclaration\";\n  function doSanitize(cooked) {\n    if (!externalSourceForDebug) {\n      sanitize(cooked);\n    }\n  }\n  const rootEnv = new DeclarativeEnvironment(null);\n  const rootContext = new ExecutionContext();\n  rootContext.VariableEnvironment = rootEnv;\n  rootContext.LexicalEnvironment = rootEnv;\n  const executionContextStack = [rootContext];\n  for (const [key, value] of Object.entries(globalVariables)) {\n    rootEnv.CreateImmutableBinding(key, true);\n    rootEnv.InitializeBinding(key, value);\n  }\n  const TemplateMap = new WeakMap();\n\n  // https://tc39.es/ecma262/#sec-gettemplateobject\n  function GetTemplateObject(templateLiteral) {\n    const memo = TemplateMap.get(templateLiteral);\n    if (memo) {\n      return memo;\n    }\n    const rawObj = templateLiteral.quasis.map(quasi => quasi.value.raw);\n    const template = templateLiteral.quasis.map(quasi => quasi.value.cooked);\n    Object.freeze(rawObj);\n    Object.defineProperty(template, \"raw\", {\n      value: rawObj,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n    Object.freeze(template);\n    TemplateMap.set(templateLiteral, template);\n    return template;\n  }\n  let currentNode;\n  function* Evaluate(node, optionalChainRef, forceYield) {\n    var _hooks$beforeEvaluate, _hooks$beforeBranch2;\n    (_hooks$beforeEvaluate = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate === void 0 || _hooks$beforeEvaluate.call(hooks, node);\n    currentNode = node;\n    if (debug && (forceYield || node.type.endsWith(\"Statement\") && !(node.type === \"ExpressionStatement\" && (node.expression.type === \"CallExpression\" || node.expression.type === \"TaggedTemplateExpression\")) && node.type !== \"TryStatement\" && node.type !== \"BlockStatement\" && node.type !== \"DoWhileStatement\" && node.type !== \"WhileStatement\" && node.type !== \"ForStatement\" && node.type !== \"ForInStatement\" && node.type !== \"ForOfStatement\")) {\n      yield;\n    }\n    // Expressions:\n    switch (node.type) {\n      case \"ArrayExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-array-initializer\n          const array = new ArrayConstructor();\n          for (const element of node.elements) {\n            if (!element) {\n              array.length += 1;\n            } else if (element.type === \"SpreadElement\") {\n              const spreadValues = GetValue(yield* Evaluate(element.argument));\n              array.push(...spreadValues);\n            } else {\n              array.push(GetValue(yield* Evaluate(element)));\n            }\n          }\n          return NormalCompletion(array);\n        }\n      case \"ArrowFunctionExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-arrow-function-definitions\n          ThrowIfFunctionIsInvalid(node);\n          const closure = InstantiateArrowFunctionExpression(node);\n          return NormalCompletion(closure);\n        }\n      case \"BinaryExpression\":\n        {\n          const leftRef = yield* Evaluate(node.left);\n          const leftValue = GetValue(leftRef);\n          const rightRef = yield* Evaluate(node.right);\n          const rightValue = GetValue(rightRef);\n          if (expressionOnly && node.operator === \"|>\") {\n            // Minimal pipeline operator is supported only in expression-only mode.\n            // See https://tc39.es/proposal-pipeline-operator\n            // and https://github.com/tc39/proposal-pipeline-operator\n            if (typeof rightValue !== \"function\") {\n              const funcName = codeSource.substring(node.right.start, node.right.end);\n              throw new TypeError(`${funcName} is not a function`);\n            }\n            let thisValue;\n            if (rightRef instanceof ReferenceRecord) {\n              if (IsPropertyReference(rightRef)) {\n                thisValue = rightRef.Base;\n              }\n            }\n            return NormalCompletion(rightValue.call(thisValue, leftValue));\n          }\n          // https://tc39.es/ecma262/#sec-additive-operators\n          const result = ApplyStringOrNumericBinaryOperator(leftValue, node.operator, rightValue);\n          return NormalCompletion(result);\n        }\n      case \"CallExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-function-calls\n          const ref = (yield* Evaluate(node.callee, optionalChainRef)).Value;\n          const func = GetValue(ref);\n          if ((func === undefined || func === null) && (node.optional || optionalChainRef !== null && optionalChainRef !== void 0 && optionalChainRef.skipped)) {\n            optionalChainRef.skipped = true;\n            return NormalCompletion(undefined);\n          }\n          doSanitize(func);\n          if (debug) yield;\n          return yield* EvaluateCall(func, ref, node.arguments, node.callee);\n        }\n      case \"ChainExpression\":\n        // https://tc39.es/ecma262/#sec-optional-chains\n        return yield* Evaluate(node.expression, {});\n      case \"ConditionalExpression\":\n        // https://tc39.es/ecma262/#sec-conditional-operator\n        return NormalCompletion(GetValue(yield* Evaluate(GetValue(yield* Evaluate(node.test)) ? node.consequent : node.alternate)));\n      case \"Identifier\":\n        // https://tc39.es/ecma262/#sec-identifiers\n        return NormalCompletion(ResolveBinding(node.name));\n      case \"Literal\":\n        {\n          // https://tc39.es/ecma262/#sec-primary-expression-literals\n          if (node.regex) {\n            if (node.value === null) {\n              // Invalid regular expression fails silently in @babel/parser.\n              throw new SyntaxError(`Invalid regular expression: ${node.raw}`);\n            }\n            if (node.regex.flags.includes(\"u\")) {\n              // Currently unicode flag is not fully supported across major browsers.\n              throw new SyntaxError(`Unsupported unicode flag in regular expression: ${node.raw}`);\n            }\n            // Always create a new RegExp, because the AST will be reused.\n            return NormalCompletion(new RegExp(node.regex.pattern, node.regex.flags));\n          }\n          return NormalCompletion(node.value);\n        }\n      case \"LogicalExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-binary-logical-operators\n          const leftValue = GetValue(yield* Evaluate(node.left));\n          switch (node.operator) {\n            case \"&&\":\n              return NormalCompletion(leftValue && GetValue(yield* Evaluate(node.right)));\n            case \"||\":\n              return NormalCompletion(leftValue || GetValue(yield* Evaluate(node.right)));\n            case \"??\":\n              return NormalCompletion(leftValue ?? GetValue(yield* Evaluate(node.right)));\n            // istanbul ignore next\n            default:\n              throw new SyntaxError(\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore never reach here.\n              `Unsupported logical operator '${node.operator}'`);\n          }\n        }\n      case \"MemberExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-property-accessors\n          const baseReference = (yield* Evaluate(node.object, optionalChainRef)).Value;\n          const baseValue = GetValue(baseReference);\n          if ((baseValue === undefined || baseValue === null) && (node.optional || optionalChainRef !== null && optionalChainRef !== void 0 && optionalChainRef.skipped)) {\n            optionalChainRef.skipped = true;\n            return NormalCompletion(undefined);\n          }\n          doSanitize(baseValue);\n          const result = node.computed ? yield* EvaluatePropertyAccessWithExpressionKey(baseValue, node.property, true) : EvaluatePropertyAccessWithIdentifierKey(baseValue, node.property, true);\n          doSanitize(result);\n          return NormalCompletion(result);\n        }\n      case \"NewExpression\":\n        // https://tc39.es/ecma262/#sec-new-operator\n        return yield* EvaluateNew(node.callee, node.arguments);\n      case \"ObjectExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-object-initializer\n          const object = {};\n          for (const prop of node.properties) {\n            if (prop.type === \"SpreadElement\") {\n              const fromValue = GetValue(yield* Evaluate(prop.argument));\n              CopyDataProperties(object, fromValue, new Set());\n            } else {\n              if (prop.kind !== \"init\") {\n                throw new SyntaxError(\"Unsupported object getter/setter\");\n              }\n              const propName = !prop.computed && prop.key.type === \"Identifier\" ? prop.key.name : yield* EvaluateComputedPropertyName(prop.key);\n              if (propName === \"__proto__\") {\n                throw new TypeError(\"Setting '__proto__' property is not allowed\");\n              }\n              const propValue = GetValue(yield* Evaluate(prop.value));\n              if (prop.method && typeof propValue === \"function\") {\n                SetFunctionName(propValue, propName);\n              }\n              object[propName] = propValue;\n            }\n          }\n          return NormalCompletion(object);\n        }\n      case \"SequenceExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-comma-operator\n          let result;\n          for (const expr of node.expressions) {\n            result = NormalCompletion(GetValue(yield* Evaluate(expr)));\n          }\n          return result;\n        }\n      case \"TemplateLiteral\":\n        {\n          // https://tc39.es/ecma262/#sec-template-literals\n          const chunks = [node.quasis[0].value.cooked];\n          let index = 0;\n          for (const expr of node.expressions) {\n            const val = GetValue(yield* Evaluate(expr));\n            chunks.push(String(val));\n            chunks.push(node.quasis[index += 1].value.cooked);\n          }\n          return NormalCompletion(chunks.join(\"\"));\n        }\n      case \"TaggedTemplateExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-tagged-templates\n          const tagRef = (yield* Evaluate(node.tag)).Value;\n          const tagFunc = GetValue(tagRef);\n          doSanitize(tagFunc);\n          if (debug) yield;\n          return yield* EvaluateCall(tagFunc, tagRef, node.quasi, node.tag);\n        }\n      case \"UnaryExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-unary-operators\n          const ref = (yield* Evaluate(node.argument)).Value;\n          if (!expressionOnly && node.operator === \"delete\") {\n            // Delete operator is supported only in function mode.\n            if (!(ref instanceof ReferenceRecord)) {\n              return NormalCompletion(true);\n            }\n            // istanbul ignore else\n            if (IsPropertyReference(ref)) {\n              const deleteStatus = delete ref.Base[ref.ReferenceName];\n              return NormalCompletion(deleteStatus);\n            }\n            // Should never reach here in strict mode.\n          }\n          if (node.operator === \"typeof\") {\n            if (ref instanceof ReferenceRecord && ref.Base === \"unresolvable\") {\n              return NormalCompletion(\"undefined\");\n            }\n            return NormalCompletion(typeof GetValue(ref));\n          }\n          return NormalCompletion(ApplyUnaryOperator(GetValue(ref), node.operator));\n        }\n    }\n    if (!expressionOnly) {\n      // Statements and assignments:\n      switch (node.type) {\n        case \"AssignmentExpression\":\n          {\n            // https://tc39.es/ecma262/#sec-assignment-operators\n            if (node.operator === \"=\") {\n              if (!(node.left.type === \"ArrayPattern\" || node.left.type === \"ObjectPattern\")) {\n                const lref = (yield* Evaluate(node.left)).Value;\n                let rval;\n                if (IsAnonymousFunctionDefinition(node.right) && node.left.type === \"Identifier\") {\n                  rval = NamedEvaluation(node.right, node.left.name);\n                } else {\n                  const rref = yield* Evaluate(node.right);\n                  rval = GetValue(rref);\n                }\n                PutValue(lref, rval);\n                return NormalCompletion(rval);\n              }\n              const rref = yield* Evaluate(node.right);\n              const rval = GetValue(rref);\n              yield* DestructuringAssignmentEvaluation(node.left, rval);\n              return NormalCompletion(rval);\n            }\n            // Operators other than `=`.\n            const lref = (yield* Evaluate(node.left)).Value;\n            const lval = GetValue(lref);\n            const rref = yield* Evaluate(node.right);\n            const rval = GetValue(rref);\n            const r = ApplyStringOrNumericAssignment(lval, node.operator, rval);\n            PutValue(lref, r);\n            return NormalCompletion(r);\n          }\n        case \"BlockStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-block\n            if (!node.body.length) {\n              return NormalCompletion(Empty);\n            }\n            const oldEnv = getRunningContext().LexicalEnvironment;\n            const blockEnv = new DeclarativeEnvironment(oldEnv);\n            BlockDeclarationInstantiation(node.body, blockEnv);\n            getRunningContext().LexicalEnvironment = blockEnv;\n            const blockValue = yield* EvaluateStatementList(node.body);\n            getRunningContext().LexicalEnvironment = oldEnv;\n            return blockValue;\n          }\n        case \"BreakStatement\":\n          // https://tc39.es/ecma262/#sec-break-statement\n          return new CompletionRecord(\"break\", Empty);\n        case \"ContinueStatement\":\n          // https://tc39.es/ecma262/#sec-continue-statement\n          return new CompletionRecord(\"continue\", Empty);\n        case \"EmptyStatement\":\n          // https://tc39.es/ecma262/#sec-empty-statement\n          return NormalCompletion(Empty);\n        case \"DoWhileStatement\":\n          // https://tc39.es/ecma262/#sec-do-while-statement\n          return EvaluateBreakableStatement(yield* DoWhileLoopEvaluation(node));\n        case \"ExpressionStatement\":\n        case \"TSAsExpression\":\n          // https://tc39.es/ecma262/#sec-expression-statement\n          return yield* Evaluate(node.expression);\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n          // https://tc39.es/ecma262/#sec-for-in-and-for-of-statements\n          return EvaluateBreakableStatement(yield* ForInOfLoopEvaluation(node));\n        case \"ForStatement\":\n          // https://tc39.es/ecma262/#sec-for-statement\n          return EvaluateBreakableStatement(yield* ForLoopEvaluation(node));\n        case \"FunctionDeclaration\":\n          // https://tc39.es/ecma262/#sec-function-definitions\n          return NormalCompletion(Empty);\n        case \"FunctionExpression\":\n          // https://tc39.es/ecma262/#sec-function-defining-expressions\n          ThrowIfFunctionIsInvalid(node);\n          return NormalCompletion(InstantiateOrdinaryFunctionExpression(node));\n        case \"IfStatement\":\n          // https://tc39.es/ecma262/#sec-if-statement\n          if (GetValue(yield* Evaluate(node.test))) {\n            var _hooks$beforeBranch;\n            (_hooks$beforeBranch = hooks.beforeBranch) === null || _hooks$beforeBranch === void 0 || _hooks$beforeBranch.call(hooks, node, \"if\");\n            return UpdateEmpty(yield* Evaluate(node.consequent), undefined);\n          }\n          (_hooks$beforeBranch2 = hooks.beforeBranch) === null || _hooks$beforeBranch2 === void 0 || _hooks$beforeBranch2.call(hooks, node, \"else\");\n          if (node.alternate) {\n            return UpdateEmpty(yield* Evaluate(node.alternate), undefined);\n          }\n          return NormalCompletion(undefined);\n        case \"ReturnStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-return-statement\n            let v;\n            if (node.argument) {\n              const exprRef = yield* Evaluate(node.argument);\n              v = GetValue(exprRef);\n            }\n            return new CompletionRecord(\"return\", v);\n          }\n        case \"ThisExpression\":\n          {\n            if (!externalSourceForDebug) {\n              break;\n            }\n            const envRec = GetThisEnvironment();\n            return NormalCompletion(envRec.GetThisBinding());\n          }\n        case \"ThrowStatement\":\n          // https://tc39.es/ecma262/#sec-throw-statement\n          throw GetValue(yield* Evaluate(node.argument));\n        case \"UpdateExpression\":\n          {\n            // https://tc39.es/ecma262/#sec-update-expressions\n            const lhs = (yield* Evaluate(node.argument)).Value;\n            const oldValue = Number(GetValue(lhs));\n            const newValue = node.operator === \"++\" ? oldValue + 1 : oldValue - 1;\n            PutValue(lhs, newValue);\n            return NormalCompletion(node.prefix ? newValue : oldValue);\n          }\n        case \"SwitchCase\":\n          return yield* EvaluateStatementList(node.consequent);\n        case \"SwitchStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-switch-statement\n            const exprRef = yield* Evaluate(node.discriminant);\n            const switchValue = GetValue(exprRef);\n            const oldEnv = getRunningContext().LexicalEnvironment;\n            const blockEnv = new DeclarativeEnvironment(oldEnv);\n            BlockDeclarationInstantiation(node.cases, blockEnv);\n            getRunningContext().LexicalEnvironment = blockEnv;\n            const R = yield* CaseBlockEvaluation(node.cases, switchValue);\n            getRunningContext().LexicalEnvironment = oldEnv;\n            return EvaluateBreakableStatement(R);\n          }\n        case \"TryStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-try-statement\n            let R;\n            try {\n              R = yield* Evaluate(node.block);\n            } catch (error) {\n              if (node.handler) {\n                var _hooks$beforeEvaluate2;\n                currentNode = node.handler;\n                (_hooks$beforeEvaluate2 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate2 === void 0 || _hooks$beforeEvaluate2.call(hooks, node.handler);\n                R = yield* CatchClauseEvaluation(node.handler, error);\n              } else {\n                throw error;\n              }\n            } finally {\n              if (node.finalizer) {\n                const F = yield* Evaluate(node.finalizer);\n                if (F.Type !== \"normal\") {\n                  R = F;\n                }\n              }\n            }\n            return R;\n          }\n        case \"VariableDeclaration\":\n          {\n            // https://tc39.es/ecma262/#sec-declarations-and-the-variable-statement\n            let result;\n            for (const declarator of node.declarations) {\n              currentNode = declarator;\n              if (!declarator.init) {\n                // Assert: a declarator without init is always an identifier.\n                if (node.kind === \"var\") {\n                  result = NormalCompletion(Empty);\n                } else {\n                  const lhs = ResolveBinding(declarator.id.name);\n                  result = InitializeReferencedBinding(lhs, undefined);\n                }\n              } else if (declarator.id.type === \"Identifier\") {\n                currentNode = declarator.init;\n                if (debug && currentNode.type !== \"CallExpression\" && currentNode.type !== \"TaggedTemplateExpression\") yield;\n                const bindingId = declarator.id.name;\n                const lhs = ResolveBinding(bindingId);\n                let value;\n                if (IsAnonymousFunctionDefinition(declarator.init)) {\n                  value = NamedEvaluation(declarator.init, bindingId);\n                } else {\n                  const rhs = yield* Evaluate(declarator.init);\n                  value = GetValue(rhs);\n                }\n                result = node.kind === \"var\" ? PutValue(lhs, value) : InitializeReferencedBinding(lhs, value);\n              } else {\n                currentNode = declarator.init;\n                if (debug && currentNode.type !== \"CallExpression\" && currentNode.type !== \"TaggedTemplateExpression\") yield;\n                const rhs = yield* Evaluate(declarator.init);\n                const rval = GetValue(rhs);\n                result = yield* BindingInitialization(declarator.id, rval, node.kind === \"var\" ? undefined : getRunningContext().LexicalEnvironment);\n              }\n            }\n            return result;\n          }\n        case \"WhileStatement\":\n          // https://tc39.es/ecma262/#sec-while-statement\n          return EvaluateBreakableStatement(yield* WhileLoopEvaluation(node));\n      }\n    }\n    // eslint-disable-next-line no-console\n    throw new SyntaxError(`Unsupported node type \\`${node.type}\\``);\n  }\n\n  // https://tc39.es/ecma262/#sec-execution-contexts\n  function getRunningContext() {\n    return executionContextStack[executionContextStack.length - 1];\n  }\n\n  // https://tc39.es/ecma262/#sec-resolvebinding\n  function ResolveBinding(name, env) {\n    if (!env) {\n      env = getRunningContext().LexicalEnvironment;\n    }\n    return GetIdentifierReference(env, name, true);\n  }\n\n  // Try statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-catchclauseevaluation\n  function* CatchClauseEvaluation(node, thrownValue) {\n    if (!node.param) {\n      return yield* Evaluate(node.body);\n    }\n    const oldEnv = getRunningContext().LexicalEnvironment;\n    const catchEnv = new DeclarativeEnvironment(oldEnv);\n    for (const argName of collectBoundNames(node.param)) {\n      catchEnv.CreateMutableBinding(argName, false);\n    }\n    getRunningContext().LexicalEnvironment = catchEnv;\n    yield* BindingInitialization(node.param, thrownValue, catchEnv);\n    const B = yield* Evaluate(node.body);\n    getRunningContext().LexicalEnvironment = oldEnv;\n    return B;\n  }\n\n  // Iteration statements and switch statements.\n  // https://tc39.es/ecma262/#prod-BreakableStatement\n  function EvaluateBreakableStatement(stmtResult) {\n    return stmtResult.Type === \"break\" ? stmtResult.Value === Empty ? NormalCompletion(undefined) : NormalCompletion(stmtResult.Value) : stmtResult;\n  }\n\n  // Switch statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation\n  function* CaseBlockEvaluation(cases, input) {\n    let V;\n    const defaultCaseIndex = cases.findIndex(switchCase => !switchCase.test);\n    const hasDefaultCase = defaultCaseIndex >= 0;\n    const A = hasDefaultCase ? cases.slice(0, defaultCaseIndex) : cases;\n    let found = false;\n    for (const C of A) {\n      if (!found) {\n        found = yield* CaseClauseIsSelected(C, input);\n      }\n      if (found) {\n        const R = yield* Evaluate(C);\n        if (R.Value !== Empty) {\n          V = R.Value;\n        }\n        if (R.Type !== \"normal\") {\n          return UpdateEmpty(R, V);\n        }\n      }\n    }\n    if (!hasDefaultCase) {\n      return NormalCompletion(V);\n    }\n    let foundInB = false;\n    const B = cases.slice(defaultCaseIndex + 1);\n    if (!found) {\n      for (const C of B) {\n        if (!foundInB) {\n          foundInB = yield* CaseClauseIsSelected(C, input);\n        }\n        if (foundInB) {\n          const R = yield* Evaluate(C);\n          if (R.Value !== Empty) {\n            V = R.Value;\n          }\n          if (R.Type !== \"normal\") {\n            return UpdateEmpty(R, V);\n          }\n        }\n      }\n    }\n    if (foundInB) {\n      return NormalCompletion(V);\n    }\n    const R = yield* Evaluate(cases[defaultCaseIndex]);\n    if (R.Value !== Empty) {\n      V = R.Value;\n    }\n    if (R.Type !== \"normal\") {\n      return UpdateEmpty(R, V);\n    }\n\n    // NOTE: The following is another complete iteration of the second CaseClauses.\n    for (const C of B) {\n      const R = yield* Evaluate(C);\n      if (R.Value !== Empty) {\n        V = R.Value;\n      }\n      if (R.Type !== \"normal\") {\n        return UpdateEmpty(R, V);\n      }\n    }\n    return NormalCompletion(V);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected\n  function* CaseClauseIsSelected(C, input) {\n    const clauseSelector = GetValue(yield* Evaluate(C.test));\n    return input === clauseSelector;\n  }\n\n  // While statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-whileloopevaluation\n  function* WhileLoopEvaluation(node) {\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const exprValue = GetValue(yield* Evaluate(node.test, undefined, true));\n      if (!exprValue) {\n        return NormalCompletion(V);\n      }\n      const stmtResult = yield* Evaluate(node.body);\n      if (!LoopContinues(stmtResult)) {\n        return UpdateEmpty(stmtResult, V);\n      }\n      if (stmtResult.Value !== Empty) {\n        V = stmtResult.Value;\n      }\n    }\n  }\n\n  // Do-while Statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-dowhileloopevaluation\n  function* DoWhileLoopEvaluation(node) {\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const stmtResult = yield* Evaluate(node.body);\n      if (!LoopContinues(stmtResult)) {\n        return UpdateEmpty(stmtResult, V);\n      }\n      if (stmtResult.Value !== Empty) {\n        V = stmtResult.Value;\n      }\n      const exprValue = GetValue(yield* Evaluate(node.test, undefined, true));\n      if (!exprValue) {\n        return NormalCompletion(V);\n      }\n    }\n  }\n\n  // For in/of statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forinofloopevaluation\n  function* ForInOfLoopEvaluation(node) {\n    const lhs = node.left;\n    const isVariableDeclaration = lhs.type === \"VariableDeclaration\";\n    const lhsKind = isVariableDeclaration ? lhs.kind === \"var\" ? \"varBinding\" : \"lexicalBinding\" : \"assignment\";\n    const uninitializedBoundNames = lhsKind === \"lexicalBinding\" ? collectBoundNames(lhs) : [];\n    const iterationKind = node.type === \"ForInStatement\" ? \"enumerate\" : \"iterate\";\n    const keyResult = yield* ForInOfHeadEvaluation(uninitializedBoundNames, node.right, iterationKind);\n    if (keyResult.Type !== \"normal\") {\n      // When enumerate, if the target is nil, a break completion will be returned.\n      return keyResult;\n    }\n    return yield* ForInOfBodyEvaluation(lhs, node.body, keyResult.Value, iterationKind, lhsKind);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forinofheadevaluation\n  function* ForInOfHeadEvaluation(uninitializedBoundNames, expr, iterationKind) {\n    const runningContext = getRunningContext();\n    const oldEnv = runningContext.LexicalEnvironment;\n    if (uninitializedBoundNames.length > 0) {\n      const newEnv = new DeclarativeEnvironment(oldEnv);\n      for (const name of uninitializedBoundNames) {\n        newEnv.CreateMutableBinding(name, false);\n      }\n      runningContext.LexicalEnvironment = newEnv;\n    }\n    const exprRef = yield* Evaluate(expr, undefined, true);\n    runningContext.LexicalEnvironment = oldEnv;\n    const exprValue = GetValue(exprRef);\n    if (iterationKind === \"enumerate\") {\n      if (exprValue === null || exprValue === undefined) {\n        return new CompletionRecord(\"break\", Empty);\n      }\n      const iterator = EnumerateObjectProperties(exprValue);\n      return NormalCompletion(iterator);\n    }\n    const iterator = CreateListIteratorRecord(exprValue);\n    return NormalCompletion(iterator);\n  }\n  function* ForInOfBodyEvaluation(node, stmt, iteratorRecord, iterationKind, lhsKind) {\n    const lhs = lhsKind === \"assignment\" ? node : node.declarations[0].id;\n    const oldEnv = getRunningContext().LexicalEnvironment;\n    let V;\n    // When `destructuring` is false,\n    // For `node` whose `kind` is assignment:\n    //   `lhs` is an `Identifier` or a `MemberExpression`,\n    // Otherwise:\n    //   `lhs` is an `Identifier`.\n    const destructuring = lhs.type === \"ObjectPattern\" || lhs.type === \"ArrayPattern\";\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      currentNode = lhs;\n      const {\n        done,\n        value: nextValue\n      } = iteratorRecord.next();\n      if (done) {\n        if (debug) yield;\n        return NormalCompletion(V);\n      }\n      let lhsRef;\n      let iterationEnv;\n      if (lhsKind === \"lexicalBinding\") {\n        iterationEnv = new DeclarativeEnvironment(oldEnv);\n        ForDeclarationBindingInstantiation(node, iterationEnv);\n        getRunningContext().LexicalEnvironment = iterationEnv;\n        if (debug) yield;\n        if (!destructuring) {\n          const [lhsName] = collectBoundNames(lhs);\n          lhsRef = ResolveBinding(lhsName);\n        }\n      } else {\n        if (debug) yield;\n        if (!destructuring) {\n          lhsRef = (yield* Evaluate(lhs)).Value;\n        }\n      }\n      destructuring ? lhsKind === \"assignment\" ? yield* DestructuringAssignmentEvaluation(lhs, nextValue) : lhsKind === \"varBinding\" ? yield* BindingInitialization(lhs, nextValue, undefined) : yield* BindingInitialization(lhs, nextValue, iterationEnv) : lhsKind === \"lexicalBinding\" ? InitializeReferencedBinding(lhsRef, nextValue) : PutValue(lhsRef, nextValue);\n      const result = yield* Evaluate(stmt);\n      getRunningContext().LexicalEnvironment = oldEnv;\n      if (!LoopContinues(result)) {\n        const status = UpdateEmpty(result, V);\n        if (!(iterationKind === \"enumerate\" || iteratorRecord.return === undefined)) {\n          // Perform *IteratorClose*\n          // https://tc39.es/ecma262/#sec-iteratorclose\n          const innerResult = iteratorRecord.return();\n          if (!innerResult || ![\"object\", \"function\"].includes(typeof innerResult)) {\n            throw new TypeError(`Iterator result is not an object`);\n          }\n        }\n        return status;\n      }\n      if (result.Value !== Empty) {\n        V = result.Value;\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-enumerate-object-properties\n  function* EnumerateObjectProperties(value) {\n    for (const key in value) {\n      yield key;\n    }\n  }\n\n  // For statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forloopevaluation\n  function* ForLoopEvaluation(node) {\n    var _node$init;\n    if (((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === \"VariableDeclaration\") {\n      // `for (var  ;  ;  ) `\n      if (node.init.kind === \"var\") {\n        yield* Evaluate(node.init);\n        return yield* ForBodyEvaluation(node.test, node.update, node.body, []);\n      }\n      // `for (let/const  ;  ;  ) `\n      const oldEnv = getRunningContext().LexicalEnvironment;\n      const loopEnv = new DeclarativeEnvironment(oldEnv);\n      const isConst = node.init.kind === \"const\";\n      const boundNames = collectBoundNames(node.init);\n      for (const dn of boundNames) {\n        if (isConst) {\n          loopEnv.CreateImmutableBinding(dn, true);\n        } else {\n          loopEnv.CreateMutableBinding(dn, false);\n        }\n      }\n      getRunningContext().LexicalEnvironment = loopEnv;\n      yield* Evaluate(node.init);\n      const perIterationLets = isConst ? [] : Array.from(boundNames);\n      const bodyResult = yield* ForBodyEvaluation(node.test, node.update, node.body, perIterationLets);\n      getRunningContext().LexicalEnvironment = oldEnv;\n      return bodyResult;\n    }\n    // `for (  ;  ;  ) `\n    if (node.init) {\n      const exprRef = yield* Evaluate(node.init);\n      GetValue(exprRef);\n    }\n    return yield* ForBodyEvaluation(node.test, node.update, node.body, []);\n  }\n\n  // https://tc39.es/ecma262/#sec-forbodyevaluation\n  function* ForBodyEvaluation(test, increment, stmt, perIterationBindings) {\n    CreatePerIterationEnvironment(perIterationBindings);\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (test) {\n        const testRef = yield* Evaluate(test, undefined, true);\n        const testValue = GetValue(testRef);\n        if (!testValue) {\n          return NormalCompletion(V);\n        }\n      }\n      const result = yield* Evaluate(stmt);\n      if (!LoopContinues(result)) {\n        return UpdateEmpty(result, V);\n      }\n      if (result.Value) {\n        V = result.Value;\n      }\n      CreatePerIterationEnvironment(perIterationBindings);\n      if (increment) {\n        const incRef = yield* Evaluate(increment, undefined, true);\n        GetValue(incRef);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-createperiterationenvironment\n  function CreatePerIterationEnvironment(perIterationBindings) {\n    if (perIterationBindings.length === 0) {\n      return;\n    }\n    const lastIterationEnv = getRunningContext().LexicalEnvironment;\n    const outer = lastIterationEnv.OuterEnv;\n    const thisIterationEnv = new DeclarativeEnvironment(outer);\n    for (const bn of perIterationBindings) {\n      thisIterationEnv.CreateMutableBinding(bn, false);\n      const lastValue = lastIterationEnv.GetBindingValue(bn, false);\n      thisIterationEnv.InitializeBinding(bn, lastValue);\n    }\n    getRunningContext().LexicalEnvironment = thisIterationEnv;\n  }\n\n  // Destructuring assignments.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-destructuringassignmentevaluation\n  function* DestructuringAssignmentEvaluation(pattern, value) {\n    if (pattern.type === \"ObjectPattern\") {\n      RequireObjectCoercible(value);\n      if (pattern.properties.length > 0) {\n        yield* PropertyDestructuringAssignmentEvaluation(pattern.properties, value);\n      }\n      return NormalCompletion(Empty);\n    }\n    const iteratorRecord = CreateListIteratorRecord(value);\n    return yield* IteratorDestructuringAssignmentEvaluation(pattern.elements, iteratorRecord);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-propertydestructuringassignmentevaluation\n  function* PropertyDestructuringAssignmentEvaluation(properties, value) {\n    const excludedNames = new Set();\n    for (const prop of properties) {\n      if (prop.type === \"Property\") {\n        const propName = !prop.computed && prop.key.type === \"Identifier\" ? prop.key.name : yield* EvaluateComputedPropertyName(prop.key);\n        const valueTarget = prop.value.type === \"AssignmentPattern\" ? prop.value.left : prop.value;\n        if (valueTarget.type === \"Identifier\") {\n          const lref = ResolveBinding(valueTarget.name);\n          let v = GetV(value, propName);\n          if (prop.value.type === \"AssignmentPattern\" && v === undefined) {\n            if (IsAnonymousFunctionDefinition(prop.value.right)) {\n              v = NamedEvaluation(prop.value.right, valueTarget.name);\n            } else {\n              const defaultValue = yield* Evaluate(prop.value.right);\n              v = GetValue(defaultValue);\n            }\n          }\n          PutValue(lref, v);\n          excludedNames.add(propName);\n        } else {\n          yield* KeyedDestructuringAssignmentEvaluation(prop.value, value, propName);\n          excludedNames.add(propName);\n        }\n      } else {\n        yield* RestDestructuringAssignmentEvaluation(prop, value, excludedNames);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-keyeddestructuringassignmentevaluation\n  function* KeyedDestructuringAssignmentEvaluation(node, value, propertyName) {\n    const assignmentTarget = node.type === \"AssignmentPattern\" ? node.left : node;\n    const isObjectOrArray = assignmentTarget.type === \"ArrayPattern\" || assignmentTarget.type === \"ObjectPattern\";\n    let lref;\n    if (!isObjectOrArray) {\n      lref = (yield* Evaluate(assignmentTarget)).Value;\n    }\n    const v = GetV(value, propertyName);\n    let rhsValue;\n    if (node.type === \"AssignmentPattern\" && v === undefined) {\n      // `assignmentTarget.type` is never \"Identifier\" here.\n      const defaultValue = yield* Evaluate(node.right);\n      rhsValue = GetValue(defaultValue);\n    } else {\n      rhsValue = v;\n    }\n    if (isObjectOrArray) {\n      return yield* DestructuringAssignmentEvaluation(assignmentTarget, rhsValue);\n    }\n    return PutValue(lref, rhsValue);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-restdestructuringassignmentevaluation\n  function* RestDestructuringAssignmentEvaluation(restProperty, value, excludedNames) {\n    const lref = (yield* Evaluate(restProperty.argument)).Value;\n    const restObj = CopyDataProperties({}, value, excludedNames);\n    return PutValue(lref, restObj);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-iteratordestructuringassignmentevaluation\n  function* IteratorDestructuringAssignmentEvaluation(elements, iteratorRecord) {\n    let status = NormalCompletion(Empty);\n    for (const element of elements) {\n      if (!element) {\n        iteratorRecord.next();\n        status = NormalCompletion(Empty);\n        continue;\n      }\n      const assignmentTarget = element.type === \"RestElement\" ? element.argument : element.type === \"AssignmentPattern\" ? element.left : element;\n      const isObjectOrArray = assignmentTarget.type === \"ArrayPattern\" || assignmentTarget.type === \"ObjectPattern\";\n      let lref;\n      if (!isObjectOrArray) {\n        lref = (yield* Evaluate(assignmentTarget)).Value;\n      }\n      let v;\n      if (element.type !== \"RestElement\") {\n        const {\n          done,\n          value: nextValue\n        } = iteratorRecord.next();\n        const value = done ? undefined : nextValue;\n        if (element.type === \"AssignmentPattern\" && value === undefined) {\n          if (IsAnonymousFunctionDefinition(element.right) && assignmentTarget.type === \"Identifier\") {\n            v = NamedEvaluation(element.right, assignmentTarget.name);\n          } else {\n            const defaultValue = yield* Evaluate(element.right);\n            v = GetValue(defaultValue);\n          }\n        } else {\n          v = value;\n        }\n      } else {\n        // RestElement\n        v = new ArrayConstructor();\n        let n = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const {\n            done,\n            value: nextValue\n          } = iteratorRecord.next();\n          if (done) {\n            break;\n          }\n          v[n] = nextValue;\n          n++;\n        }\n      }\n      if (isObjectOrArray) {\n        status = yield* DestructuringAssignmentEvaluation(assignmentTarget, v);\n      } else {\n        status = PutValue(lref, v);\n      }\n    }\n    return status;\n  }\n\n  // Object expressions.\n  // https://tc39.es/ecma262/#sec-evaluate-property-access-with-expression-key\n  function* EvaluatePropertyAccessWithExpressionKey(baseValue, expression, strict) {\n    const propertyNameReference = yield* Evaluate(expression);\n    const propertyNameValue = GetValue(propertyNameReference);\n    const propertyKey = ToPropertyKey(propertyNameValue);\n    return new ReferenceRecord(baseValue, propertyKey, strict);\n  }\n\n  // https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key\n  function EvaluatePropertyAccessWithIdentifierKey(baseValue, identifier, strict) {\n    currentNode = identifier;\n    const propertyNameString = identifier.name;\n    return new ReferenceRecord(baseValue, propertyNameString, strict);\n  }\n\n  // Block statements.\n  // https://tc39.es/ecma262/#sec-blockdeclarationinstantiation\n  function BlockDeclarationInstantiation(code, env) {\n    const declarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: false\n    });\n    for (const d of declarations) {\n      const IsConstantDeclaration = d.type === \"VariableDeclaration\" && d.kind === \"const\";\n      for (const dn of collectBoundNames(d)) {\n        if (IsConstantDeclaration) {\n          env.CreateImmutableBinding(dn, true);\n        } else {\n          env.CreateMutableBinding(dn, false);\n        }\n      }\n      if (d.type === \"FunctionDeclaration\") {\n        const [fn] = collectBoundNames(d);\n        const fo = InstantiateFunctionObject(d, env);\n        env.InitializeBinding(fn, fo);\n      }\n    }\n  }\n\n  // Function declarations and expressions.\n  // https://tc39.es/ecma262/#sec-evaluatecall\n  function* EvaluateCall(func, ref, args, callee) {\n    let thisValue;\n    if (ref instanceof ReferenceRecord) {\n      if (IsPropertyReference(ref)) {\n        thisValue = ref.Base;\n      }\n    }\n    const argList = yield* ArgumentListEvaluation(args);\n    if (typeof func !== \"function\") {\n      const funcName = codeSource.substring(callee.start, callee.end);\n      throw new TypeError(`${funcName} is not a function`);\n    }\n    if (debug || externalSourceForDebug) {\n      const debuggerCall = func[DebuggerCall];\n      if (debuggerCall) {\n        const result = yield* debuggerCall.apply(thisValue, argList);\n        doSanitize(result);\n        return NormalCompletion(result);\n      }\n    }\n    const result = func.apply(thisValue, argList);\n    doSanitize(result);\n    return NormalCompletion(result);\n  }\n\n  // https://tc39.es/ecma262/#sec-evaluatenew\n  function* EvaluateNew(constructExpr, args) {\n    const ref = yield* Evaluate(constructExpr);\n    const constructor = GetValue(ref);\n    const argList = yield* ArgumentListEvaluation(args);\n    if (typeof constructor !== \"function\" || constructor[IsConstructor] === false) {\n      const constructorName = codeSource.substring(constructExpr.start, constructExpr.end);\n      throw new TypeError(`${constructorName} is not a constructor`);\n    }\n    if (!externalSourceForDebug && !isAllowedConstructor(constructor) && constructor !== ArrayConstructor) {\n      const constructorName = codeSource.substring(constructExpr.start, constructExpr.end);\n      throw new TypeError(`${constructorName} is not an allowed constructor`);\n    }\n    return NormalCompletion(new constructor(...argList));\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-argumentlistevaluation\n  function* ArgumentListEvaluation(args) {\n    const array = [];\n    if (Array.isArray(args)) {\n      for (const arg of args) {\n        if (arg.type === \"SpreadElement\") {\n          const spreadValues = GetValue(yield* Evaluate(arg.argument));\n          array.push(...spreadValues);\n        } else {\n          array.push(GetValue(yield* Evaluate(arg)));\n        }\n      }\n    } else {\n      array.push(GetTemplateObject(args));\n      for (const expr of args.expressions) {\n        array.push(GetValue(yield* Evaluate(expr)));\n      }\n    }\n    return array;\n  }\n\n  // https://tc39.es/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n  function* CallFunction(closure, thisArgument, args) {\n    var _hooks$beforeCall;\n    (_hooks$beforeCall = hooks.beforeCall) === null || _hooks$beforeCall === void 0 || _hooks$beforeCall.call(hooks, closure[SourceNode]);\n    const calleeContext = PrepareForOrdinaryCall(closure);\n    OrdinaryCallBindThis(closure, calleeContext, thisArgument);\n    const result = yield* OrdinaryCallEvaluateBody(closure, args);\n    if (debug) {\n      currentNode = {\n        ...closure[SourceNode],\n        [DebuggerReturn]: true\n      };\n      yield {\n        type: \"return\",\n        value: result.Type === \"return\" ? result.Value : undefined\n      };\n    }\n    executionContextStack.pop();\n    globalExecutionContextStack.pop();\n    if (result.Type === \"return\") {\n      return result.Value;\n    }\n    return undefined;\n  }\n\n  // https://tc39.es/ecma262/#sec-prepareforordinarycall\n  function PrepareForOrdinaryCall(F) {\n    const calleeContext = new ExecutionContext();\n    calleeContext.Function = F;\n    const localEnv = new FunctionEnvironment(F);\n    calleeContext.VariableEnvironment = localEnv;\n    calleeContext.LexicalEnvironment = localEnv;\n    executionContextStack.push(calleeContext);\n    globalExecutionContextStack.push(calleeContext);\n    return calleeContext;\n  }\n  function OrdinaryCallBindThis(F, calleeContext, thisArgument) {\n    if (F[ThisMode] === Mode.LEXICAL) {\n      return;\n    }\n    const localEnv = calleeContext.LexicalEnvironment;\n    localEnv === null || localEnv === void 0 || localEnv.BindThisValue(thisArgument);\n  }\n\n  // https://tc39.es/ecma262/#sec-ordinarycallevaluatebody\n  function* OrdinaryCallEvaluateBody(F, args) {\n    return yield* EvaluateFunctionBody(F[ECMAScriptCode], F, args);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-evaluatefunctionbody\n  function* EvaluateFunctionBody(body, F, args) {\n    yield* FunctionDeclarationInstantiation(F, args);\n    if (Array.isArray(body)) {\n      return yield* EvaluateStatementList(body);\n    }\n    return new CompletionRecord(\"return\", GetValue(yield* Evaluate(body)));\n  }\n\n  // https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation\n  function* EvaluateStatementList(statements) {\n    let result = NormalCompletion(Empty);\n    for (const stmt of statements) {\n      const s = yield* Evaluate(stmt);\n      if (s.Type !== \"normal\") {\n        return s;\n      }\n      result = UpdateEmpty(result, s.Value);\n    }\n    return result;\n  }\n  function GetThisEnvironment() {\n    let env = getRunningContext().LexicalEnvironment;\n    while (env) {\n      if (env.HasThisBinding()) {\n        return env;\n      }\n      env = env.OuterEnv;\n    }\n    throw new Error(\"Accessing global this is forbidden\");\n  }\n\n  // https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition\n  function IsAnonymousFunctionDefinition(node) {\n    // No ParenthesizedExpression in ESTree.\n    return node.type === \"FunctionExpression\" && !node.id || node.type === \"ArrowFunctionExpression\";\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-namedevaluation\n  function NamedEvaluation(node, name) {\n    var _hooks$beforeEvaluate3;\n    (_hooks$beforeEvaluate3 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate3 === void 0 || _hooks$beforeEvaluate3.call(hooks, node);\n    // No ParenthesizedExpression in ESTree.\n    switch (node.type) {\n      case \"FunctionExpression\":\n        return InstantiateOrdinaryFunctionExpression(node, name);\n      case \"ArrowFunctionExpression\":\n        return InstantiateArrowFunctionExpression(node, name);\n      // istanbul ignore next: should never happen\n      default:\n        throw new Error(`Unexpected node type for NamedEvaluation: ${node.type}`);\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-functiondeclarationinstantiation\n  function* FunctionDeclarationInstantiation(func, args) {\n    const calleeContext = getRunningContext();\n    const code = func[ECMAScriptCode];\n    const formals = func[FormalParameters];\n    const parameterNames = collectBoundNames(formals);\n    const hasParameterExpressions = containsExpression(formals);\n    const varDeclarations = collectScopedDeclarations(code, {\n      var: true,\n      topLevel: true\n    });\n    const varNames = collectBoundNames(varDeclarations);\n\n    // `functionNames`  `varNames`\n    // `functionsToInitialize`  `functionNames`\n    const functionNames = [];\n    const functionsToInitialize = [];\n    for (let i = varDeclarations.length - 1; i >= 0; i--) {\n      const d = varDeclarations[i];\n      if (d.type === \"FunctionDeclaration\") {\n        ThrowIfFunctionIsInvalid(d);\n        const [fn] = collectBoundNames(d);\n        if (!functionNames.includes(fn)) {\n          functionNames.unshift(fn);\n          functionsToInitialize.unshift(d);\n        }\n      } else if (rules !== null && rules !== void 0 && rules.noVar) {\n        throw new SyntaxError(\"Var declaration is not recommended, use `let` or `const` instead\");\n      }\n    }\n\n    // let argumentsObjectNeeded = true;\n    // if (func[ThisMode] === Mode.LEXICAL) {\n    //   // NOTE: Arrow functions never have an arguments object.\n    //   argumentsObjectNeeded = false;\n    // } else if (parameterNames.includes(\"arguments\")) {\n    //   argumentsObjectNeeded = false;\n    // } else if (!hasParameterExpressions && (\n    //   varNames.includes(\"arguments\") ||\n    //   collectBoundNames(collectScopedDeclarations(code, { var: false })).includes(\"arguments\")\n    // )) {\n    //   argumentsObjectNeeded = false;\n    // }\n    // NOTE: In strict mode, no parameter/function/var/lexical names can be \"arguments\".\n    const argumentsObjectNeeded = !!externalSourceForDebug && func[ThisMode] !== Mode.LEXICAL;\n    const env = calleeContext.LexicalEnvironment;\n    for (const paramName of parameterNames) {\n      // In strict mode, it's guaranteed no duplicate params exist.\n      env.CreateMutableBinding(paramName, false);\n    }\n    let parameterBindings = parameterNames;\n    if (argumentsObjectNeeded) {\n      const ao = CreateUnmappedArgumentsObject(args);\n      env.CreateImmutableBinding(\"arguments\", false);\n      env.InitializeBinding(\"arguments\", ao);\n      parameterBindings = parameterNames.concat(\"arguments\");\n    }\n    const iteratorRecord = CreateListIteratorRecord(args);\n    yield* IteratorBindingInitialization(formals, iteratorRecord, env);\n    let varEnv;\n    if (!hasParameterExpressions) {\n      // NOTE: Only a single Environment Record is needed for the parameters\n      // and top-level vars.\n      // `varNames` are unique.\n      const instantiatedVarNames = [...parameterBindings];\n      for (const n of varNames) {\n        if (!instantiatedVarNames.includes(n)) {\n          instantiatedVarNames.push(n);\n          env.CreateMutableBinding(n, false);\n          env.InitializeBinding(n, undefined);\n        }\n      }\n      varEnv = env;\n    } else {\n      // NOTE: A separate Environment Record is needed to ensure that closures\n      // created by expressions in the formal parameter list do not have\n      // visibility of declarations in the function body.\n      varEnv = new DeclarativeEnvironment(env);\n      calleeContext.VariableEnvironment = varEnv;\n      // `varNames` are unique.\n      const instantiatedVarNames = [];\n      for (const n of varNames) {\n        if (!instantiatedVarNames.includes(n)) {\n          instantiatedVarNames.push(n);\n          varEnv.CreateMutableBinding(n, false);\n          let initialValue;\n          if (parameterBindings.includes(n) && !functionNames.includes(n)) {\n            initialValue = env.GetBindingValue(n, false);\n          }\n          varEnv.InitializeBinding(n, initialValue);\n          // NOTE: A var with the same name as a formal parameter initially has\n          // the same value as the corresponding initialized parameter.\n        }\n      }\n    }\n    const lexEnv = varEnv;\n    calleeContext.LexicalEnvironment = lexEnv;\n    const lexDeclarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: true\n    });\n    for (const d of lexDeclarations) {\n      for (const dn of collectBoundNames(d)) {\n        // Only lexical VariableDeclaration here in top-level.\n        if (d.kind === \"const\") {\n          lexEnv.CreateImmutableBinding(dn, true);\n        } else {\n          lexEnv.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n    for (const f of functionsToInitialize) {\n      const [fn] = collectBoundNames(f);\n      const fo = InstantiateFunctionObject(f, lexEnv);\n      varEnv.SetMutableBinding(fn, fo, false);\n    }\n  }\n  function CreateUnmappedArgumentsObject(args) {\n    const argList = [...args];\n    const argumentObject = {};\n    Object.defineProperty(argumentObject, \"length\", {\n      value: argList.length,\n      writable: true,\n      configurable: true\n    });\n    for (let index = 0; index < argList.length; index++) {\n      argumentObject[String(index)] = argList[index];\n    }\n    Object.defineProperty(argumentObject, Symbol.iterator, {\n      value: Array.prototype.values,\n      writable: true,\n      configurable: true\n    });\n    const ThrowTypeError = () => {\n      throw new TypeError(\"'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them\");\n    };\n    Object.defineProperty(argumentObject, \"callee\", {\n      get: ThrowTypeError,\n      set: ThrowTypeError\n    });\n    return argumentObject;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiatefunctionobject\n  function InstantiateFunctionObject(func, scope) {\n    const F = OrdinaryFunctionCreate(func, scope, true, false);\n    if (func.id) {\n      SetFunctionName(F, func.id.name);\n    }\n    return F;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiateordinaryfunctionexpression\n  function InstantiateOrdinaryFunctionExpression(functionExpression, name) {\n    const scope = getRunningContext().LexicalEnvironment;\n    if (functionExpression.id) {\n      const name = functionExpression.id.name;\n      const funcEnv = new DeclarativeEnvironment(scope);\n      funcEnv.CreateImmutableBinding(name, false);\n      const closure = OrdinaryFunctionCreate(functionExpression, funcEnv, true, false);\n      SetFunctionName(closure, name);\n      funcEnv.InitializeBinding(name, closure);\n      return closure;\n    } else {\n      const closure = OrdinaryFunctionCreate(functionExpression, scope, true, false);\n      SetFunctionName(closure, name ?? \"\");\n      return closure;\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiatearrowfunctionexpression\n  function InstantiateArrowFunctionExpression(arrowFunction, name) {\n    const scope = getRunningContext().LexicalEnvironment;\n    const closure = OrdinaryFunctionCreate(arrowFunction, scope, false, true);\n    SetFunctionName(closure, name ?? \"\");\n    return closure;\n  }\n  function SetFunctionName(F, name) {\n    Object.defineProperty(F, \"name\", {\n      value: name,\n      configurable: true\n    });\n  }\n\n  // https://tc39.es/ecma262/#sec-ordinaryfunctioncreate\n  function OrdinaryFunctionCreate(sourceNode, scope, isConstructor, lexicalThis) {\n    const F = function () {\n      // eslint-disable-next-line prefer-rest-params\n      return unwind(CallFunction(F, this, arguments));\n    };\n    Object.defineProperties(F, {\n      [SourceNode]: {\n        value: sourceNode\n      },\n      [FormalParameters]: {\n        value: sourceNode.params\n      },\n      [ECMAScriptCode]: {\n        value: sourceNode.body.type === \"BlockStatement\" ? sourceNode.body.body : sourceNode.body\n      },\n      [Environment]: {\n        value: scope\n      },\n      [IsConstructor]: {\n        value: isConstructor\n      },\n      [ThisMode]: {\n        value: lexicalThis ? Mode.LEXICAL : Mode.STRICT\n      }\n    });\n    const len = ExpectedArgumentCount(sourceNode.params);\n    Object.defineProperty(F, \"length\", {\n      configurable: true,\n      value: len\n    });\n    if (debug || externalSourceForDebug) {\n      Object.defineProperty(F, DebuggerCall, {\n        value: function () {\n          // eslint-disable-next-line prefer-rest-params\n          return CallFunction(F, this, arguments);\n        }\n      });\n    }\n    return F;\n  }\n  function ExpectedArgumentCount(params) {\n    let count = 0;\n    for (const param of params) {\n      switch (param.type) {\n        case \"AssignmentPattern\":\n        case \"RestElement\":\n          return count;\n        default:\n          count++;\n      }\n    }\n    return count;\n  }\n\n  // Patterns initialization.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-bindinginitialization\n  function* BindingInitialization(node, value, environment) {\n    switch (node.type) {\n      case \"Identifier\":\n        return InitializeBoundName(node.name, value, environment);\n      case \"ObjectPattern\":\n        RequireObjectCoercible(value);\n        return yield* PropertyBindingInitialization(node.properties, value, environment);\n      case \"ArrayPattern\":\n        {\n          const iteratorRecord = CreateListIteratorRecord(value);\n          return yield* IteratorBindingInitialization(node.elements, iteratorRecord, environment);\n        }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization\n  function* PropertyBindingInitialization(properties, value, environment) {\n    const excludedNames = new Set();\n    for (const prop of properties) {\n      if (prop.type === \"RestElement\") {\n        return RestBindingInitialization(prop, value, environment, excludedNames);\n      }\n      if (!prop.computed && prop.key.type === \"Identifier\") {\n        yield* KeyedBindingInitialization(prop.value, value, environment, prop.key.name);\n        excludedNames.add(prop.key.name);\n      } else {\n        const P = yield* EvaluateComputedPropertyName(prop.key);\n        yield* KeyedBindingInitialization(prop.value, value, environment, P);\n        excludedNames.add(P);\n      }\n    }\n    return NormalCompletion(Empty);\n  }\n\n  // https://tc39.es/ecma262/#prod-ComputedPropertyName\n  function* EvaluateComputedPropertyName(node) {\n    const propName = GetValue(yield* Evaluate(node));\n    return ToPropertyKey(propName);\n  }\n\n  // https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization\n  function RestBindingInitialization(restProperty, value, environment, excludedNames) {\n    const lhs = ResolveBinding(restProperty.argument.name, environment);\n    const restObj = CopyDataProperties({}, value, excludedNames);\n    if (!environment) {\n      return PutValue(lhs, restObj);\n    }\n    return InitializeReferencedBinding(lhs, restObj);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-iteratorbindinginitialization\n  function* IteratorBindingInitialization(elements, iteratorRecord, environment) {\n    if (elements.length === 0) {\n      return NormalCompletion(Empty);\n    }\n    let result;\n    for (const node of elements) {\n      if (!node) {\n        // Elision element.\n        iteratorRecord.next();\n        result = NormalCompletion(Empty);\n      } else if (node.type === \"RestElement\") {\n        // Rest element.\n        if (node.argument.type === \"Identifier\") {\n          const lhs = ResolveBinding(node.argument.name, environment);\n          const A = new ArrayConstructor();\n          let n = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const {\n              done,\n              value\n            } = iteratorRecord.next();\n            if (done) {\n              result = environment ? InitializeReferencedBinding(lhs, A) : PutValue(lhs, A);\n              break;\n            }\n            A[n] = value;\n            n++;\n          }\n        } else {\n          const A = new ArrayConstructor();\n          let n = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const {\n              done,\n              value\n            } = iteratorRecord.next();\n            if (done) {\n              result = yield* BindingInitialization(node.argument, A, environment);\n              break;\n            }\n            A[n] = value;\n            n++;\n          }\n        }\n      } else {\n        // Normal element.\n        const bindingElement = node.type === \"AssignmentPattern\" ? node.left : node;\n        switch (bindingElement.type) {\n          case \"ObjectPattern\":\n          case \"ArrayPattern\":\n            {\n              let v;\n              const {\n                done,\n                value\n              } = iteratorRecord.next();\n              if (!done) {\n                v = value;\n              }\n              if (node.type === \"AssignmentPattern\" && v === undefined) {\n                const defaultValue = yield* Evaluate(node.right);\n                v = GetValue(defaultValue);\n              }\n              result = yield* BindingInitialization(bindingElement, v, environment);\n              break;\n            }\n          case \"Identifier\":\n            {\n              const bindingId = bindingElement.name;\n              const lhs = ResolveBinding(bindingId, environment);\n              let v;\n              const {\n                done,\n                value\n              } = iteratorRecord.next();\n              if (!done) {\n                v = value;\n              }\n              if (node.type === \"AssignmentPattern\" && v === undefined) {\n                if (IsAnonymousFunctionDefinition(node.right)) {\n                  v = NamedEvaluation(node.right, bindingId);\n                } else {\n                  const defaultValue = yield* Evaluate(node.right);\n                  v = GetValue(defaultValue);\n                }\n              }\n              result = environment ? InitializeReferencedBinding(lhs, v) : PutValue(lhs, v);\n              break;\n            }\n        }\n      }\n    }\n    return result;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization\n  function* KeyedBindingInitialization(node, value, environment, propertyName) {\n    const isIdentifier = node.type === \"Identifier\" || node.type === \"AssignmentPattern\" && node.left.type === \"Identifier\";\n    if (isIdentifier) {\n      const bindingId = node.type === \"Identifier\" ? node.name : node.left.name;\n      const lhs = ResolveBinding(bindingId, environment);\n      let v = GetV(value, propertyName);\n      if (node.type === \"AssignmentPattern\" && v === undefined) {\n        if (IsAnonymousFunctionDefinition(node.right)) {\n          v = NamedEvaluation(node.right, bindingId);\n        } else {\n          const defaultValue = yield* Evaluate(node.right);\n          v = GetValue(defaultValue);\n        }\n      }\n      if (!environment) {\n        return PutValue(lhs, v);\n      }\n      return InitializeReferencedBinding(lhs, v);\n    }\n    let v = GetV(value, propertyName);\n    if (node.type === \"AssignmentPattern\" && v === undefined) {\n      const defaultValue = yield* Evaluate(node.right);\n      v = GetValue(defaultValue);\n    }\n    return yield* BindingInitialization(node.type === \"AssignmentPattern\" ? node.left : node, v, environment);\n  }\n\n  // https://tc39.es/ecma262/#sec-initializeboundname\n  function InitializeBoundName(name, value, environment) {\n    // Assert: environment is always present.\n    environment.InitializeBinding(name, value);\n    return NormalCompletion(Empty);\n  }\n  function ThrowIfFunctionIsInvalid(func) {\n    if (func.async || func.generator) {\n      throw new SyntaxError(`${func.async ? \"Async\" : \"Generator\"} function is not allowed`);\n    }\n    if (expressionOnly && !func.expression) {\n      throw new SyntaxError(\"Only an `Expression` is allowed in `ArrowFunctionExpression`'s body\");\n    }\n  }\n  if (expressionOnly) {\n    return GetValue(unwind(Evaluate(rootAst)));\n  }\n  (_hooks$beforeEvaluate4 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate4 === void 0 || _hooks$beforeEvaluate4.call(hooks, rootAst);\n  ThrowIfFunctionIsInvalid(rootAst);\n  const [fn] = collectBoundNames(rootAst);\n  // Create an immutable binding for the root function.\n  rootEnv.CreateImmutableBinding(fn, true);\n  const fo = InstantiateFunctionObject(rootAst, rootEnv);\n  rootEnv.InitializeBinding(fn, fo);\n  if (debug) {\n    Object.defineProperties(fo, {\n      [DebuggerScope]: {\n        value: function () {\n          return getRunningContext().LexicalEnvironment;\n        }\n      },\n      [DebuggerNode]: {\n        value: function () {\n          return currentNode;\n        }\n      }\n    });\n  }\n  return fo;\n}\nfunction unwind(iterator) {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const {\n      done,\n      value\n    } = iterator.next();\n    if (done) {\n      return value;\n    }\n  }\n}\n//# sourceMappingURL=cook.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n// https://tc39.es/ecma262/#sec-execution-contexts\nexport class AnalysisContext {\n  constructor() {\n    _defineProperty(this, \"VariableEnvironment\", void 0);\n    _defineProperty(this, \"LexicalEnvironment\", void 0);\n  }\n}\n\n// https://tc39.es/ecma262/#sec-environment-records\nexport class AnalysisEnvironment {\n  constructor(outer) {\n    _defineProperty(this, \"OuterEnv\", void 0);\n    _defineProperty(this, \"bindingSet\", new Set());\n    this.OuterEnv = outer;\n  }\n  HasBinding(name) {\n    return this.bindingSet.has(name);\n  }\n  CreateBinding(name) {\n    this.bindingSet.add(name);\n  }\n}\n//# sourceMappingURL=AnalysisContext.js.map","import { hasOwnProperty } from \"./hasOwnProperty.js\";\nimport { AnalysisContext, AnalysisEnvironment } from \"./AnalysisContext.js\";\nimport { collectBoundNames, collectScopedDeclarations, containsExpression } from \"./traverse.js\";\n/**\n * Analysis an AST of a storyboard function or an evaluation expression.\n *\n * @param rootAst - The root AST.\n * @param options - Analysis options.\n * @returns A set of global variables the root AST attempts to access.\n */\nexport function precook(rootAst) {\n  let {\n    expressionOnly,\n    visitors,\n    withParent,\n    externalSourceForDebug,\n    hooks = {}\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const attemptToVisitGlobals = new Set();\n  const analysisContextStack = [];\n  const rootEnv = new AnalysisEnvironment(null);\n  const rootContext = new AnalysisContext();\n  rootContext.VariableEnvironment = rootEnv;\n  rootContext.LexicalEnvironment = rootEnv;\n  analysisContextStack.push(rootContext);\n  function getRunningContext() {\n    return analysisContextStack[analysisContextStack.length - 1];\n  }\n  function visit(node) {\n    if (visitors && hasOwnProperty(visitors, node.type)) {\n      visitors[node.type](node);\n    }\n  }\n  function EvaluateChildren(node, keys, parent) {\n    for (const key of keys) {\n      Evaluate(node[key], parent === null || parent === void 0 ? void 0 : parent.concat({\n        node,\n        key\n      }));\n    }\n  }\n  function Evaluate(node, parent) {\n    if (Array.isArray(node)) {\n      node.forEach((n, index) => {\n        Evaluate(n, parent ? parent.slice(0, -1).concat({\n          ...parent[parent.length - 1],\n          index\n        }) : parent);\n      });\n    } else if (node) {\n      var _hooks$beforeVisit, _hooks$beforeVisitUnk;\n      // `node` maybe `null` in some cases.\n      (_hooks$beforeVisit = hooks.beforeVisit) === null || _hooks$beforeVisit === void 0 || _hooks$beforeVisit.call(hooks, node, parent);\n      visit(node);\n      // Expressions:\n      switch (node.type) {\n        case \"Identifier\":\n          if (!ResolveBinding(node.name)) {\n            var _hooks$beforeVisitGlo;\n            (_hooks$beforeVisitGlo = hooks.beforeVisitGlobal) === null || _hooks$beforeVisitGlo === void 0 || _hooks$beforeVisitGlo.call(hooks, node, parent);\n            attemptToVisitGlobals.add(node.name);\n          }\n          return;\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          EvaluateChildren(node, [\"elements\"], parent);\n          return;\n        case \"ArrowFunctionExpression\":\n          {\n            const env = getRunningContext().LexicalEnvironment;\n            const closure = OrdinaryFunctionCreate(node, env, true);\n            CallFunction(closure, parent);\n            return;\n          }\n        case \"AssignmentPattern\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          EvaluateChildren(node, [\"left\", \"right\"], parent);\n          return;\n        case \"CallExpression\":\n        case \"NewExpression\":\n          EvaluateChildren(node, [\"callee\", \"arguments\"], parent);\n          return;\n        case \"ChainExpression\":\n          EvaluateChildren(node, [\"expression\"], parent);\n          return;\n        case \"ConditionalExpression\":\n          EvaluateChildren(node, [\"test\", \"consequent\", \"alternate\"], parent);\n          return;\n        case \"MemberExpression\":\n          EvaluateChildren(node, [\"object\"], parent);\n          if (node.computed) {\n            EvaluateChildren(node, [\"property\"], parent);\n          }\n          return;\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          EvaluateChildren(node, [\"properties\"], parent);\n          return;\n        case \"Property\":\n          if (node.computed) {\n            EvaluateChildren(node, [\"key\"], parent);\n          }\n          EvaluateChildren(node, [\"value\"], parent);\n          return;\n        case \"RestElement\":\n        case \"SpreadElement\":\n        case \"UnaryExpression\":\n          EvaluateChildren(node, [\"argument\"], parent);\n          return;\n        case \"SequenceExpression\":\n        case \"TemplateLiteral\":\n          EvaluateChildren(node, [\"expressions\"], parent);\n          return;\n        case \"TaggedTemplateExpression\":\n          EvaluateChildren(node, [\"tag\", \"quasi\"], parent);\n          return;\n        case \"Literal\":\n          return;\n      }\n      if (!expressionOnly) {\n        // Statements and assignments:\n        switch (node.type) {\n          case \"AssignmentExpression\":\n            EvaluateChildren(node, [\"right\", \"left\"], parent);\n            return;\n          case \"BlockStatement\":\n            {\n              if (!node.body.length) {\n                return;\n              }\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const blockEnv = new AnalysisEnvironment(oldEnv);\n              BlockDeclarationInstantiation(node.body, blockEnv);\n              runningContext.LexicalEnvironment = blockEnv;\n              EvaluateChildren(node, [\"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"BreakStatement\":\n          case \"ContinueStatement\":\n          case \"EmptyStatement\":\n            return;\n          case \"CatchClause\":\n            {\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const catchEnv = new AnalysisEnvironment(oldEnv);\n              BoundNamesInstantiation(node.param, catchEnv);\n              runningContext.LexicalEnvironment = catchEnv;\n              EvaluateChildren(node, [\"param\", \"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"DoWhileStatement\":\n            EvaluateChildren(node, [\"body\", \"test\"], parent);\n            return;\n          case \"ExpressionStatement\":\n          case \"TSAsExpression\":\n            EvaluateChildren(node, [\"expression\"], parent);\n            return;\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            {\n              // ForIn/OfHeadEvaluation\n              const lexicalBinding = node.left.type === \"VariableDeclaration\" && node.left.kind !== \"var\";\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              if (lexicalBinding) {\n                const newEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.left, newEnv);\n                runningContext.LexicalEnvironment = newEnv;\n              }\n              EvaluateChildren(node, [\"right\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n\n              // ForIn/OfBodyEvaluation\n              if (lexicalBinding) {\n                const iterationEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.left, iterationEnv);\n                runningContext.LexicalEnvironment = iterationEnv;\n              }\n              EvaluateChildren(node, [\"left\", \"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"ForStatement\":\n            {\n              var _node$init;\n              const lexicalBinding = ((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === \"VariableDeclaration\" && node.init.kind !== \"var\";\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              if (lexicalBinding) {\n                const loopEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.init, loopEnv);\n                runningContext.LexicalEnvironment = loopEnv;\n              }\n              EvaluateChildren(node, [\"init\", \"test\", \"body\", \"update\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"FunctionDeclaration\":\n            {\n              const [fn] = collectBoundNames(node);\n              const env = getRunningContext().LexicalEnvironment;\n              const fo = OrdinaryFunctionCreate(node, env);\n              env.CreateBinding(fn);\n              CallFunction(fo, parent);\n              return;\n            }\n          case \"FunctionExpression\":\n            {\n              const closure = InstantiateOrdinaryFunctionExpression(node);\n              CallFunction(closure, parent);\n              return;\n            }\n          case \"IfStatement\":\n            EvaluateChildren(node, [\"test\", \"consequent\", \"alternate\"], parent);\n            return;\n          case \"ReturnStatement\":\n          case \"ThrowStatement\":\n          case \"UpdateExpression\":\n            EvaluateChildren(node, [\"argument\"], parent);\n            return;\n          case \"SwitchCase\":\n            EvaluateChildren(node, [\"test\", \"consequent\"], parent);\n            return;\n          case \"SwitchStatement\":\n            {\n              EvaluateChildren(node, [\"discriminant\"], parent);\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const blockEnv = new AnalysisEnvironment(oldEnv);\n              BlockDeclarationInstantiation(node.cases, blockEnv);\n              runningContext.LexicalEnvironment = blockEnv;\n              EvaluateChildren(node, [\"cases\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"ThisExpression\":\n            {\n              if (!externalSourceForDebug) {\n                break;\n              }\n              return;\n            }\n          case \"TryStatement\":\n            EvaluateChildren(node, [\"block\", \"handler\", \"finalizer\"], parent);\n            return;\n          case \"VariableDeclaration\":\n            EvaluateChildren(node, [\"declarations\"], parent);\n            return;\n          case \"VariableDeclarator\":\n            EvaluateChildren(node, [\"id\", \"init\"], parent);\n            return;\n          case \"WhileStatement\":\n            EvaluateChildren(node, [\"test\", \"body\"], parent);\n            return;\n        }\n      }\n      const silent = (_hooks$beforeVisitUnk = hooks.beforeVisitUnknown) === null || _hooks$beforeVisitUnk === void 0 ? void 0 : _hooks$beforeVisitUnk.call(hooks, node, parent);\n      if (!silent) {\n        // eslint-disable-next-line no-console\n        console.warn(`Unsupported node type \\`${node.type}\\``);\n      }\n    }\n  }\n  function BoundNamesInstantiation(declarations, env) {\n    for (const name of collectBoundNames(declarations)) {\n      env.CreateBinding(name);\n    }\n  }\n  function ResolveBinding(name) {\n    const env = getRunningContext().LexicalEnvironment;\n    return GetIdentifierReference(env, name);\n  }\n  function GetIdentifierReference(env, name) {\n    return !!env && (env.HasBinding(name) || GetIdentifierReference(env.OuterEnv, name));\n  }\n  function BlockDeclarationInstantiation(code, env) {\n    const declarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: false\n    });\n    BoundNamesInstantiation(declarations, env);\n  }\n  function CallFunction(closure, parent) {\n    PrepareOrdinaryCall(closure);\n    FunctionDeclarationInstantiation(closure, parent);\n    Evaluate(closure.ECMAScriptCode, parent === null || parent === void 0 ? void 0 : parent.concat({\n      node: closure.Function,\n      key: \"body\"\n    }).concat(closure.Function.body.type === \"BlockStatement\" ? {\n      node: closure.Function.body,\n      key: \"body\"\n    } : []));\n    analysisContextStack.pop();\n  }\n  function PrepareOrdinaryCall(F) {\n    const calleeContext = new AnalysisContext();\n    const localEnv = new AnalysisEnvironment(F.Environment);\n    calleeContext.VariableEnvironment = localEnv;\n    calleeContext.LexicalEnvironment = localEnv;\n    analysisContextStack.push(calleeContext);\n  }\n  function FunctionDeclarationInstantiation(func, parent) {\n    const calleeContext = getRunningContext();\n    const code = func.ECMAScriptCode;\n    const formals = func.FormalParameters;\n    const hasParameterExpressions = containsExpression(formals);\n    const varDeclarations = collectScopedDeclarations(code, {\n      var: true,\n      topLevel: true\n    });\n    const varNames = collectBoundNames(varDeclarations);\n    const argumentsObjectNeeded = !!externalSourceForDebug && func.ThisMode !== \"LEXICAL\";\n    const env = calleeContext.LexicalEnvironment;\n    BoundNamesInstantiation(formals, env);\n    if (argumentsObjectNeeded) {\n      env.CreateBinding(\"arguments\");\n    }\n    Evaluate(formals, parent === null || parent === void 0 ? void 0 : parent.concat({\n      node: func.Function,\n      key: \"params\"\n    }));\n    let varEnv;\n    if (!hasParameterExpressions) {\n      // NOTE: Only a single Environment Record is needed for the parameters\n      // and top-level vars.\n      for (const n of varNames) {\n        env.CreateBinding(n);\n      }\n      varEnv = env;\n    } else {\n      // NOTE: A separate Environment Record is needed to ensure that closures\n      // created by expressions in the formal parameter list do not have\n      // visibility of declarations in the function body.\n      varEnv = new AnalysisEnvironment(env);\n      calleeContext.VariableEnvironment = varEnv;\n      for (const n of varNames) {\n        varEnv.CreateBinding(n);\n      }\n    }\n    const lexEnv = varEnv;\n    calleeContext.LexicalEnvironment = lexEnv;\n    const lexDeclarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: true\n    });\n    BoundNamesInstantiation(lexDeclarations, lexEnv);\n  }\n  function InstantiateOrdinaryFunctionExpression(functionExpression) {\n    const scope = getRunningContext().LexicalEnvironment;\n    if (!functionExpression.id) {\n      return OrdinaryFunctionCreate(functionExpression, scope);\n    }\n    const name = functionExpression.id.name;\n    const funcEnv = new AnalysisEnvironment(scope);\n    funcEnv.CreateBinding(name);\n    return OrdinaryFunctionCreate(functionExpression, funcEnv);\n  }\n  function OrdinaryFunctionCreate(func, scope, lexicalThis) {\n    return {\n      Function: func,\n      FormalParameters: func.params,\n      ECMAScriptCode: func.body.type === \"BlockStatement\" ? func.body.body : func.body,\n      Environment: scope,\n      ThisMode: lexicalThis ? \"LEXICAL\" : \"STRICT\"\n    };\n  }\n  Evaluate(rootAst, withParent ? [] : undefined);\n  return attemptToVisitGlobals;\n}\n//# sourceMappingURL=precook.js.map","export function hasOwnProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n//# sourceMappingURL=hasOwnProperty.js.map","import { parseAsEstree } from \"./parse.js\";\nimport { precook } from \"./precook.js\";\nlet ASTCache = new WeakMap();\nexport function precookFunction(source) {\n  let {\n    typescript,\n    cacheKey,\n    ...restOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let func = cacheKey ? ASTCache.get(cacheKey) : undefined;\n  if (!func) {\n    func = parseAsEstree(source, {\n      typescript\n    });\n    if (cacheKey) {\n      ASTCache.set(cacheKey, func);\n    }\n  }\n  const attemptToVisitGlobals = precook(func, restOptions);\n  return {\n    function: func,\n    attemptToVisitGlobals\n  };\n}\nexport function clearFunctionASTCache() {\n  ASTCache = new WeakMap();\n}\n//# sourceMappingURL=precookFunction.js.map","import { parse, parseExpression } from \"@babel/parser\";\nexport function parseAsEstreeExpression(source) {\n  return parseExpression(source, {\n    plugins: [\"estree\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }]],\n    attachComment: false\n  });\n}\nexport function parseAsEstree(source) {\n  let {\n    typescript\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const file = parse(source, {\n    plugins: [\"estree\", typescript && \"typescript\"].filter(Boolean),\n    strictMode: true,\n    attachComment: false\n  });\n  const body = file.program.body;\n  const jsNodes = typescript ? [] : body;\n  if (typescript) {\n    for (const node of body) {\n      if (node.type.startsWith(\"TS\")) {\n        if (/Enum|Import|Export/.test(node.type)) {\n          throw new SyntaxError(`Unsupported TypeScript syntax: ${node.type}`);\n        }\n      } else {\n        jsNodes.push(node);\n      }\n    }\n  }\n  if (jsNodes.length === 0) {\n    throw new SyntaxError(\"Function declaration not found\");\n  }\n  if (jsNodes.length > 1 || jsNodes[0].type !== \"FunctionDeclaration\") {\n    throw new SyntaxError(`Expect a single function declaration at top level, but received: ${jsNodes.map(node => `\"${node.type}\"`).join(\", \")}`);\n  }\n  return jsNodes[0];\n}\n//# sourceMappingURL=parse.js.map","import { parseAsEstreeExpression } from \"./parse.js\";\nimport { precook } from \"./precook.js\";\nconst ASTCache = new Map();\n// `raw` should always be asserted by `isEvaluable`.\nexport function preevaluate(raw) {\n  let {\n    cache,\n    ...restOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const fixes = [];\n  const source = raw.replace(/^\\s*<%[~=]?\\s|\\s%>\\s*$/g, m => {\n    fixes.push(m);\n    return \"\";\n  });\n  let expression = cache ? ASTCache.get(source) : undefined;\n  if (!expression) {\n    expression = parseAsEstreeExpression(source);\n    if (cache) {\n      ASTCache.set(source, expression);\n    }\n  }\n  const attemptToVisitGlobals = precook(expression, {\n    ...restOptions,\n    expressionOnly: true\n  });\n  return {\n    expression,\n    attemptToVisitGlobals,\n    source,\n    prefix: fixes[0],\n    suffix: fixes[1]\n  };\n}\nexport function isEvaluable(raw) {\n  return /^\\s*<%[~=]?\\s/.test(raw) && /\\s%>\\s*$/.test(raw);\n}\nexport function shouldAllowRecursiveEvaluations(raw) {\n  return /^\\s*<%~\\s/.test(raw);\n}\nexport function isTrackAll(raw) {\n  return /^\\s*<%=\\s/.test(raw) && /\\s%>\\s*$/.test(raw);\n}\nexport function clearExpressionASTCache() {\n  ASTCache.clear();\n}\n//# sourceMappingURL=preevaluate.js.map"],"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","toPropertyKey","t","i","r","e","Symbol","toPrimitive","call","TypeError","String","_typeof","o","iterator","constructor","prototype","Mode","SourceNode","for","FormalParameters","ECMAScriptCode","Environment","IsConstructor","ThisMode","DebuggerCall","DebuggerScope","DebuggerNode","DebuggerReturn","ExecutionContext","this","BindingStatus","EnvironmentRecord","outer","Map","undefined","OuterEnv","HasBinding","name","bindingMap","has","CreateMutableBinding","deletable","set","mutable","NormalCompletion","CreateImmutableBinding","strict","InitializeBinding","binding","get","assign","initialized","SetMutableBinding","_strict","ReferenceError","GetBindingValue","HasThisBinding","DeclarativeEnvironment","FunctionEnvironment","F","super","LEXICAL","ThisBindingStatus","UNINITIALIZED","BindThisValue","INITIALIZED","Error","ThisValue","GetThisBinding","ReferenceRecord","base","referenceName","Base","ReferenceName","Strict","CompletionRecord","type","Type","Value","Empty","collectBoundNames","root","names","Set","collect","node","Array","isArray","n","add","declarations","id","elements","left","properties","argument","from","containsExpression","some","computed","collectScopedDeclarations","options","nextOptions","var","Number","topLevel","push","kind","consequent","body","alternate","init","cases","block","handler","finalizer","IsPropertyReference","V","InitializeReferencedBinding","W","CopyDataProperties","target","source","excludedItems","keys","getOwnPropertyNames","concat","getOwnPropertySymbols","nextKey","desc","getOwnPropertyDescriptor","ForDeclarationBindingInstantiation","forDeclaration","env","isConst","LoopContinues","completion","UpdateEmpty","GetValue","ToPropertyKey","arg","GetV","P","PutValue","CreateListIteratorRecord","args","cooked","RequireObjectCoercible","GetIdentifierReference","ApplyStringOrNumericBinaryOperator","leftValue","operator","rightValue","SyntaxError","reservedObjects","WeakSet","Function","self","window","global","getGlobal","allowedConstructors","URL","URLSearchParams","WeakMap","RegExp","globalExecutionContextStack","__dev_only_clearGlobalExecutionContextStack","length","__dev_only_getGlobalExecutionContextStack","cook","rootAst","codeSource","_hooks$beforeEvaluate4","rules","debug","externalSourceForDebug","globalVariables","ArrayConstructor","hooks","arguments","expressionOnly","doSanitize","sanitize","rootEnv","rootContext","VariableEnvironment","LexicalEnvironment","executionContextStack","entries","TemplateMap","currentNode","Evaluate","optionalChainRef","forceYield","_hooks$beforeEvaluate","_hooks$beforeBranch2","beforeEvaluate","endsWith","expression","array","element","spreadValues","ThrowIfFunctionIsInvalid","InstantiateArrowFunctionExpression","rightRef","right","funcName","substring","start","end","thisValue","ref","callee","func","optional","skipped","EvaluateCall","test","ResolveBinding","regex","raw","flags","includes","pattern","baseValue","object","result","propertyKey","EvaluatePropertyAccessWithExpressionKey","property","identifier","propertyNameString","EvaluatePropertyAccessWithIdentifierKey","constructExpr","argList","ArgumentListEvaluation","constructorName","Date","isAllowedConstructor","EvaluateNew","prop","propName","EvaluateComputedPropertyName","propValue","method","SetFunctionName","expr","expressions","chunks","quasis","index","val","join","tagRef","tag","tagFunc","quasi","ApplyUnaryOperator","lref","rval","IsAnonymousFunctionDefinition","NamedEvaluation","DestructuringAssignmentEvaluation","lval","substr","ApplyStringOrNumericAssignment","oldEnv","getRunningContext","blockEnv","BlockDeclarationInstantiation","blockValue","EvaluateStatementList","EvaluateBreakableStatement","stmtResult","DoWhileLoopEvaluation","lhs","lhsKind","uninitializedBoundNames","iterationKind","keyResult","runningContext","newEnv","exprRef","exprValue","EnumerateObjectProperties","ForInOfHeadEvaluation","stmt","iteratorRecord","destructuring","done","nextValue","next","lhsRef","iterationEnv","lhsName","BindingInitialization","status","return","innerResult","ForInOfBodyEvaluation","ForInOfLoopEvaluation","_node$init","ForBodyEvaluation","update","loopEnv","boundNames","dn","perIterationLets","bodyResult","ForLoopEvaluation","InstantiateOrdinaryFunctionExpression","_hooks$beforeBranch","beforeBranch","v","GetThisEnvironment","oldValue","newValue","prefix","switchValue","discriminant","R","input","defaultCaseIndex","findIndex","switchCase","hasDefaultCase","A","slice","found","C","CaseClauseIsSelected","foundInB","B","CaseBlockEvaluation","error","_hooks$beforeEvaluate2","thrownValue","param","catchEnv","argName","CatchClauseEvaluation","declarator","bindingId","WhileLoopEvaluation","increment","perIterationBindings","CreatePerIterationEnvironment","lastIterationEnv","thisIterationEnv","bn","lastValue","excludedNames","valueTarget","KeyedDestructuringAssignmentEvaluation","RestDestructuringAssignmentEvaluation","PropertyDestructuringAssignmentEvaluation","assignmentTarget","isObjectOrArray","IteratorDestructuringAssignmentEvaluation","propertyName","rhsValue","restProperty","code","d","IsConstantDeclaration","fn","fo","InstantiateFunctionObject","debuggerCall","apply","templateLiteral","memo","rawObj","map","template","freeze","GetTemplateObject","CallFunction","closure","thisArgument","_hooks$beforeCall","beforeCall","calleeContext","localEnv","OrdinaryCallBindThis","PrepareForOrdinaryCall","formals","parameterNames","hasParameterExpressions","varDeclarations","varNames","functionNames","functionsToInitialize","unshift","noVar","argumentsObjectNeeded","paramName","parameterBindings","ao","argumentObject","values","ThrowTypeError","CreateUnmappedArgumentsObject","varEnv","IteratorBindingInitialization","instantiatedVarNames","initialValue","lexEnv","lexDeclarations","f","FunctionDeclarationInstantiation","EvaluateFunctionBody","OrdinaryCallEvaluateBody","pop","statements","s","_hooks$beforeEvaluate3","scope","OrdinaryFunctionCreate","functionExpression","funcEnv","arrowFunction","sourceNode","isConstructor","lexicalThis","unwind","defineProperties","params","STRICT","len","count","ExpectedArgumentCount","environment","InitializeBoundName","RestBindingInitialization","KeyedBindingInitialization","PropertyBindingInitialization","restObj","bindingElement","async","generator","AnalysisContext","AnalysisEnvironment","bindingSet","CreateBinding","precook","visitors","withParent","attemptToVisitGlobals","analysisContextStack","EvaluateChildren","parent","forEach","_hooks$beforeVisit","_hooks$beforeVisitUnk","beforeVisit","hasOwnProperty","visit","_hooks$beforeVisitGlo","beforeVisitGlobal","BoundNamesInstantiation","lexicalBinding","beforeVisitUnknown","console","warn","PrepareOrdinaryCall","ASTCache","precookFunction","typescript","cacheKey","restOptions","parse","plugins","filter","Boolean","strictMode","attachComment","program","jsNodes","startsWith","parseAsEstree","function","clearFunctionASTCache","preevaluate","cache","fixes","replace","m","parseExpression","proposal","parseAsEstreeExpression","suffix","isEvaluable","shouldAllowRecursiveEvaluations","isTrackAll","clearExpressionASTCache","clear"],"sourceRoot":""}