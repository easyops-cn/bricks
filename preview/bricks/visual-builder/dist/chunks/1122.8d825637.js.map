{"version":3,"file":"chunks/1122.8d825637.js","mappings":"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","sources":["webpack:///../../node_modules/@next-core/cook/dist/esm/ExecutionContext.js","webpack:///../../node_modules/@next-core/cook/dist/esm/traverse.js","webpack:///../../node_modules/@next-core/cook/dist/esm/context-free.js","webpack:///../../node_modules/@next-core/cook/dist/esm/sanitize.js","webpack:///../../node_modules/@next-core/cook/dist/esm/cook.js","webpack:///../../node_modules/@next-core/cook/dist/esm/AnalysisContext.js","webpack:///../../node_modules/@next-core/cook/dist/esm/precook.js","webpack:///../../node_modules/@next-core/cook/dist/esm/hasOwnProperty.js","webpack:///../../node_modules/@next-core/cook/dist/esm/precookFunction.js","webpack:///../../node_modules/@next-core/cook/dist/esm/parse.js","webpack:///../../node_modules/@next-core/cook/dist/esm/preevaluate.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nexport let Mode = /*#__PURE__*/function (Mode) {\n  Mode[Mode[\"LEXICAL\"] = 0] = \"LEXICAL\";\n  Mode[Mode[\"STRICT\"] = 1] = \"STRICT\";\n  return Mode;\n}({});\nexport const SourceNode = Symbol.for(\"SourceNode\");\nexport const FormalParameters = Symbol.for(\"FormalParameters\");\nexport const ECMAScriptCode = Symbol.for(\"ECMAScriptCode\");\nexport const Environment = Symbol.for(\"Environment\");\nexport const IsConstructor = Symbol.for(\"IsConstructor\");\nexport const ThisMode = Symbol.for(\"ThisMode\");\nexport const DebuggerCall = Symbol.for(\"$DebuggerCall$\");\nexport const DebuggerScope = Symbol.for(\"$DebuggerScope$\");\nexport const DebuggerNode = Symbol.for(\"$DebuggerNode$\");\nexport const DebuggerReturn = Symbol.for(\"$DebuggerReturn$\");\n\n// https://tc39.es/ecma262/#sec-execution-contexts\nexport class ExecutionContext {\n  constructor() {\n    _defineProperty(this, \"VariableEnvironment\", void 0);\n    _defineProperty(this, \"LexicalEnvironment\", void 0);\n    _defineProperty(this, \"Function\", void 0);\n  }\n}\nexport let BindingStatus = /*#__PURE__*/function (BindingStatus) {\n  BindingStatus[BindingStatus[\"UNINITIALIZED\"] = 0] = \"UNINITIALIZED\";\n  BindingStatus[BindingStatus[\"LEXICAL\"] = 1] = \"LEXICAL\";\n  BindingStatus[BindingStatus[\"INITIALIZED\"] = 2] = \"INITIALIZED\";\n  return BindingStatus;\n}({});\n\n// https://tc39.es/ecma262/#sec-environment-records\nexport class EnvironmentRecord {\n  constructor(outer) {\n    _defineProperty(this, \"OuterEnv\", void 0);\n    _defineProperty(this, \"bindingMap\", new Map());\n    _defineProperty(this, \"ThisValue\", undefined);\n    _defineProperty(this, \"ThisBindingStatus\", void 0);\n    this.OuterEnv = outer;\n  }\n  HasBinding(name) {\n    return this.bindingMap.has(name);\n  }\n  CreateMutableBinding(name, deletable) {\n    // Assert: binding does not exist.\n    this.bindingMap.set(name, {\n      mutable: true,\n      deletable\n    });\n    return NormalCompletion(undefined);\n  }\n\n  /**\n   * Create an immutable binding.\n   *\n   * @param name - The binding name.\n   * @param strict - For named function expressions, strict is false, otherwise it's true.\n   * @returns CompletionRecord.\n   */\n  CreateImmutableBinding(name, strict) {\n    // Assert: binding does not exist.\n    this.bindingMap.set(name, {\n      strict\n    });\n    return NormalCompletion(undefined);\n  }\n  InitializeBinding(name, value) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists and uninitialized.\n    Object.assign(binding, {\n      initialized: true,\n      value\n    });\n    return NormalCompletion(undefined);\n  }\n\n  /**\n   * Update a mutable binding value, including function declarations.\n   *\n   * @param name - The binding name.\n   * @param value - The binding value.\n   * @param strict - For functions, strict is always false, otherwise it depends on strict-mode.\n   * @returns\n   */\n  SetMutableBinding(name, value, _strict) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists.\n    if (!binding.initialized) {\n      throw new ReferenceError(`${name} is not initialized`);\n    } else if (binding.mutable) {\n      binding.value = value;\n    } else {\n      throw new TypeError(`Assignment to constant variable`);\n    }\n    return NormalCompletion(undefined);\n  }\n  GetBindingValue(name, _strict) {\n    const binding = this.bindingMap.get(name);\n    // Assert: binding exists.\n    if (!binding.initialized) {\n      throw new ReferenceError(`${name} is not initialized`);\n    }\n    return binding.value;\n  }\n  HasThisBinding() {\n    return false;\n  }\n}\nexport class DeclarativeEnvironment extends EnvironmentRecord {}\nexport class FunctionEnvironment extends EnvironmentRecord {\n  constructor(F) {\n    super(F[Environment]);\n    if (F[ThisMode] === Mode.LEXICAL) {\n      this.ThisBindingStatus = BindingStatus.LEXICAL;\n    } else {\n      this.ThisBindingStatus = BindingStatus.UNINITIALIZED;\n    }\n  }\n  HasThisBinding() {\n    return this.ThisBindingStatus !== BindingStatus.LEXICAL;\n  }\n  BindThisValue(value) {\n    // Assert: envRec.[[ThisBindingStatus]] is not LEXICAL.\n    if (this.ThisBindingStatus === BindingStatus.INITIALIZED) {\n      throw new Error(\"This binding has been initialized\");\n    }\n    this.ThisValue = value;\n    this.ThisBindingStatus = BindingStatus.INITIALIZED;\n  }\n  GetThisBinding() {\n    // Assert: envRec.[[ThisBindingStatus]] is not LEXICAL.\n    if (this.ThisBindingStatus === BindingStatus.UNINITIALIZED) {\n      throw new Error(\"This binding is not initialized\");\n    }\n    return this.ThisValue;\n  }\n}\n// https://tc39.es/ecma262/#sec-reference-record-specification-type\nexport class ReferenceRecord {\n  constructor(base, referenceName, strict) {\n    _defineProperty(this, \"Base\", void 0);\n    _defineProperty(this, \"ReferenceName\", void 0);\n    /** Whether the reference is in strict mode. */\n    _defineProperty(this, \"Strict\", void 0);\n    this.Base = base;\n    this.ReferenceName = referenceName;\n    this.Strict = strict;\n  }\n}\n\n// https://tc39.es/ecma262/#sec-completion-record-specification-type\nexport class CompletionRecord {\n  constructor(type, value) {\n    _defineProperty(this, \"Type\", void 0);\n    _defineProperty(this, \"Value\", void 0);\n    this.Type = type;\n    this.Value = value;\n  }\n}\n// https://tc39.es/ecma262/#sec-normalcompletion\nexport function NormalCompletion(value) {\n  return new CompletionRecord(\"normal\", value);\n}\nexport const Empty = Symbol(\"empty completion\");\n//# sourceMappingURL=ExecutionContext.js.map","export function collectBoundNames(root) {\n  const names = new Set();\n  const collect = node => {\n    if (Array.isArray(node)) {\n      for (const n of node) {\n        collect(n);\n      }\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"Identifier\":\n          names.add(node.name);\n          return;\n        case \"VariableDeclaration\":\n          return collect(node.declarations);\n        case \"VariableDeclarator\":\n          return collect(node.id);\n        case \"ArrayPattern\":\n          return collect(node.elements);\n        case \"AssignmentPattern\":\n          return collect(node.left);\n        case \"ObjectPattern\":\n          return collect(node.properties);\n        case \"Property\":\n          return collect(node.value);\n        case \"RestElement\":\n          return collect(node.argument);\n        case \"FunctionDeclaration\":\n          return collect(node.id);\n      }\n    }\n  };\n  collect(root);\n  return Array.from(names);\n}\nexport function containsExpression(root) {\n  const collect = node => {\n    if (Array.isArray(node)) {\n      return node.some(collect);\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"ArrayPattern\":\n          return collect(node.elements);\n        case \"AssignmentPattern\":\n          return true;\n        case \"ObjectPattern\":\n          return collect(node.properties);\n        case \"Property\":\n          return node.computed || collect(node.value);\n        case \"RestElement\":\n          return collect(node.argument);\n      }\n    }\n  };\n  return collect(root);\n}\nexport function collectScopedDeclarations(root, options) {\n  const declarations = [];\n  const nextOptions = {\n    var: options.var\n  };\n  const collect = (node, options) => {\n    if (Array.isArray(node)) {\n      for (const n of node) {\n        collect(n, options);\n      }\n    } else if (node) {\n      // `node` maybe `null` in some cases.\n      switch (node.type) {\n        case \"FunctionDeclaration\":\n          // At the top level of a function, or script, function declarations are\n          // treated like var declarations rather than like lexical declarations.\n          // See https://tc39.es/ecma262/#sec-static-semantics-toplevellexicallydeclarednames\n          if (Number(!options.var) ^ Number(options.topLevel)) {\n            declarations.push(node);\n          }\n          return;\n        case \"VariableDeclaration\":\n          if (Number(!options.var) ^ Number(node.kind === \"var\")) {\n            declarations.push(node);\n          }\n          return;\n        case \"SwitchCase\":\n          collect(node.consequent, nextOptions);\n          return;\n        case \"CatchClause\":\n          collect(node.body, nextOptions);\n          return;\n      }\n      if (options.var) {\n        switch (node.type) {\n          case \"BlockStatement\":\n            collect(node.body, nextOptions);\n            return;\n          case \"IfStatement\":\n            collect(node.consequent, nextOptions);\n            collect(node.alternate, nextOptions);\n            return;\n          case \"DoWhileStatement\":\n          case \"WhileStatement\":\n            collect(node.body, nextOptions);\n            return;\n          case \"ForStatement\":\n            collect(node.init, nextOptions);\n            collect(node.body, nextOptions);\n            return;\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            collect(node.left, nextOptions);\n            collect(node.body, nextOptions);\n            return;\n          case \"SwitchStatement\":\n            collect(node.cases, nextOptions);\n            return;\n          case \"TryStatement\":\n            collect(node.block, nextOptions);\n            collect(node.handler, nextOptions);\n            collect(node.finalizer, nextOptions);\n            return;\n        }\n      }\n    }\n  };\n  collect(root, options);\n  return declarations;\n}\n//# sourceMappingURL=traverse.js.map","import { CompletionRecord, Empty, EnvironmentRecord, NormalCompletion, ReferenceRecord } from \"./ExecutionContext.js\";\nimport { collectBoundNames } from \"./traverse.js\";\n\n// https://tc39.es/ecma262/#sec-ispropertyreference\nexport function IsPropertyReference(V) {\n  return V.Base !== \"unresolvable\" && !(V.Base instanceof EnvironmentRecord);\n}\n\n// https://tc39.es/ecma262/#sec-initializereferencedbinding\nexport function InitializeReferencedBinding(V, W) {\n  const base = V.Base;\n  return base.InitializeBinding(V.ReferenceName, W);\n}\n\n// https://tc39.es/ecma262/#sec-copydataproperties\nexport function CopyDataProperties(target, source, excludedItems) {\n  if (source === undefined || source === null) {\n    return target;\n  }\n  const keys = Object.getOwnPropertyNames(source).concat(Object.getOwnPropertySymbols(source));\n  for (const nextKey of keys) {\n    if (!excludedItems.has(nextKey)) {\n      const desc = Object.getOwnPropertyDescriptor(source, nextKey);\n      if (desc !== null && desc !== void 0 && desc.enumerable) {\n        target[nextKey] = source[nextKey];\n      }\n    }\n  }\n  return target;\n}\n\n// https://tc39.es/ecma262/#sec-runtime-semantics-fordeclarationbindinginstantiation\nexport function ForDeclarationBindingInstantiation(forDeclaration, env) {\n  const isConst = forDeclaration.kind === \"const\";\n  for (const name of collectBoundNames(forDeclaration)) {\n    if (isConst) {\n      env.CreateImmutableBinding(name, true);\n    } else {\n      env.CreateMutableBinding(name, false);\n    }\n  }\n}\n\n// https://tc39.es/ecma262/#sec-loopcontinues\nexport function LoopContinues(completion) {\n  return completion.Type === \"normal\" || completion.Type == \"continue\";\n}\n\n// https://tc39.es/ecma262/#sec-updateempty\nexport function UpdateEmpty(completion, value) {\n  if (completion.Value !== Empty) {\n    return completion;\n  }\n  return new CompletionRecord(completion.Type, value);\n}\n\n// https://tc39.es/ecma262/#sec-getvalue\nexport function GetValue(V) {\n  if (V instanceof CompletionRecord) {\n    // Assert: V.Type is normal.\n    V = V.Value;\n  }\n  if (!(V instanceof ReferenceRecord)) {\n    return V;\n  }\n  if (V.Base === \"unresolvable\") {\n    throw new ReferenceError(`${V.ReferenceName} is not defined`);\n  }\n  if (V.Base instanceof EnvironmentRecord) {\n    const base = V.Base;\n    return base.GetBindingValue(V.ReferenceName, V.Strict);\n  }\n  return V.Base[V.ReferenceName];\n}\n\n// https://tc39.es/ecma262/#sec-topropertykey\nexport function ToPropertyKey(arg) {\n  if (typeof arg === \"symbol\") {\n    return arg;\n  }\n  return String(arg);\n}\n\n// https://tc39.es/ecma262/#sec-getv\nexport function GetV(V, P) {\n  return V[P];\n}\n\n// https://tc39.es/ecma262/#sec-putvalue\nexport function PutValue(V, W) {\n  // Assert: V is a ReferenceRecord.\n  if (V.Base === \"unresolvable\") {\n    throw new ReferenceError(`${V.ReferenceName} is not defined`);\n  }\n  if (V.Base instanceof EnvironmentRecord) {\n    return V.Base.SetMutableBinding(V.ReferenceName, W, V.Strict);\n  }\n  V.Base[V.ReferenceName] = W;\n  return NormalCompletion(undefined);\n}\n\n// https://tc39.es/ecma262/#sec-createlistiteratorRecord\nexport function CreateListIteratorRecord(args) {\n  if (!isIterable(args)) {\n    throw new TypeError(`${typeof args} is not iterable`);\n  }\n  return args[Symbol.iterator]();\n}\n\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nexport function RequireObjectCoercible(arg) {\n  if (arg === null || arg === undefined) {\n    throw new TypeError(\"Cannot destructure properties of undefined or null\");\n  }\n}\n\n// https://tc39.es/ecma262/#sec-getidentifierreference\nexport function GetIdentifierReference(env, name, strict) {\n  if (!env) {\n    return new ReferenceRecord(\"unresolvable\", name, strict);\n  }\n  if (env.HasBinding(name)) {\n    return new ReferenceRecord(env, name, strict);\n  }\n  return GetIdentifierReference(env.OuterEnv, name, strict);\n}\n\n// https://tc39.es/ecma262/#sec-applystringornumericbinaryoperator\nexport function ApplyStringOrNumericBinaryOperator(leftValue, operator, rightValue) {\n  switch (operator) {\n    case \"+\":\n      return leftValue + rightValue;\n    case \"-\":\n      return leftValue - rightValue;\n    case \"/\":\n      return leftValue / rightValue;\n    case \"%\":\n      return leftValue % rightValue;\n    case \"*\":\n      return leftValue * rightValue;\n    case \"**\":\n      return leftValue ** rightValue;\n    case \"==\":\n      return leftValue == rightValue;\n    case \"===\":\n      return leftValue === rightValue;\n    case \"!=\":\n      return leftValue != rightValue;\n    case \"!==\":\n      return leftValue !== rightValue;\n    case \">\":\n      return leftValue > rightValue;\n    case \"<\":\n      return leftValue < rightValue;\n    case \">=\":\n      return leftValue >= rightValue;\n    case \"<=\":\n      return leftValue <= rightValue;\n    case \"in\":\n      return leftValue in rightValue;\n  }\n  throw new SyntaxError(`Unsupported binary operator \\`${operator}\\``);\n}\n\n// https://tc39.es/ecma262/#sec-assignment-operators\nexport function ApplyStringOrNumericAssignment(leftValue, operator, rightValue) {\n  switch (operator) {\n    case \"+=\":\n    case \"-=\":\n    case \"*=\":\n    case \"/=\":\n    case \"%=\":\n    case \"**=\":\n      return ApplyStringOrNumericBinaryOperator(leftValue, operator.substr(0, operator.length - 1), rightValue);\n  }\n  throw new SyntaxError(`Unsupported assignment operator \\`${operator}\\``);\n}\n\n// https://tc39.es/ecma262/#sec-unary-operators\nexport function ApplyUnaryOperator(target, operator) {\n  switch (operator) {\n    case \"!\":\n      return !target;\n    case \"+\":\n      return +target;\n    case \"-\":\n      return -target;\n    case \"void\":\n      return undefined;\n  }\n  throw new SyntaxError(`Unsupported unary operator \\`${operator}\\``);\n}\nexport function isIterable(cooked) {\n  if (Array.isArray(cooked)) {\n    return true;\n  }\n  if (cooked === null || cooked === undefined) {\n    return false;\n  }\n  return typeof cooked[Symbol.iterator] === \"function\";\n}\n//# sourceMappingURL=context-free.js.map","// Ref https://github.com/tc39/proposal-global\n// In addition, the es6-shim had to switch from Function('return this')()\n// due to CSP concerns, such that the current check to handle browsers,\n// node, web workers, and frames is:\n// istanbul ignore next\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getGlobal() {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}\n\n/**\n * There are chances to construct a `Function` from a string, etc.\n * ```\n * ((a,b)=>a[b])(()=>1, 'constructor')('console.log(`yo`)')()\n * ```\n */\nconst reservedObjects = new WeakSet([\n// `Function(\"...\")` is considered *extremely vulnerable*.\nFunction,\n// `Object.assign()` is considered vulnerable.\nObject,\n// `prototype` is considered vulnerable.\nFunction.prototype, Object.prototype,\n// Global `window` is considered vulnerable, too.\ngetGlobal()]);\nexport function sanitize(cooked) {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  if (reservedObjects.has(cooked)) {\n    throw new TypeError(\"Cannot access reserved objects such as `Function`.\");\n  }\n}\nconst allowedConstructors = new WeakSet([Array, Map, Set, URL, URLSearchParams, WeakMap, WeakSet, RegExp]);\nexport function isAllowedConstructor(constructor) {\n  // `Date` maybe mocked when running tests for storyboard functions.\n  return allowedConstructors.has(constructor) || constructor === Date;\n}\n//# sourceMappingURL=sanitize.js.map","import { ApplyStringOrNumericAssignment, CreateListIteratorRecord, ApplyStringOrNumericBinaryOperator, GetV, GetValue, InitializeReferencedBinding, IsPropertyReference, LoopContinues, PutValue, RequireObjectCoercible, ToPropertyKey, UpdateEmpty, ApplyUnaryOperator, GetIdentifierReference, ForDeclarationBindingInstantiation, CopyDataProperties } from \"./context-free.js\";\nimport { CompletionRecord, DebuggerCall, DebuggerNode, DebuggerReturn, DebuggerScope, DeclarativeEnvironment, ECMAScriptCode, Empty, Environment, ExecutionContext, FormalParameters, FunctionEnvironment, IsConstructor, NormalCompletion, ReferenceRecord, SourceNode, Mode, ThisMode } from \"./ExecutionContext.js\";\nimport { sanitize, isAllowedConstructor } from \"./sanitize.js\";\nimport { collectBoundNames, collectScopedDeclarations, containsExpression } from \"./traverse.js\";\nconst globalExecutionContextStack = [];\nexport function __dev_only_clearGlobalExecutionContextStack() {\n  globalExecutionContextStack.length = 0;\n}\nexport function __dev_only_getGlobalExecutionContextStack() {\n  return globalExecutionContextStack;\n}\n\n/** For next-core internal usage only. */\nexport function cook(rootAst, codeSource) {\n  var _hooks$beforeEvaluate4;\n  let {\n    rules,\n    debug,\n    externalSourceForDebug,\n    globalVariables = {},\n    // Allow debugger to override Array constructor.\n    ArrayConstructor = Array,\n    hooks = {}\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const expressionOnly = rootAst.type !== \"FunctionDeclaration\";\n  function doSanitize(cooked) {\n    if (!externalSourceForDebug) {\n      sanitize(cooked);\n    }\n  }\n  const rootEnv = new DeclarativeEnvironment(null);\n  const rootContext = new ExecutionContext();\n  rootContext.VariableEnvironment = rootEnv;\n  rootContext.LexicalEnvironment = rootEnv;\n  const executionContextStack = [rootContext];\n  for (const [key, value] of Object.entries(globalVariables)) {\n    rootEnv.CreateImmutableBinding(key, true);\n    rootEnv.InitializeBinding(key, value);\n  }\n  const TemplateMap = new WeakMap();\n\n  // https://tc39.es/ecma262/#sec-gettemplateobject\n  function GetTemplateObject(templateLiteral) {\n    const memo = TemplateMap.get(templateLiteral);\n    if (memo) {\n      return memo;\n    }\n    const rawObj = templateLiteral.quasis.map(quasi => quasi.value.raw);\n    const template = templateLiteral.quasis.map(quasi => quasi.value.cooked);\n    Object.freeze(rawObj);\n    Object.defineProperty(template, \"raw\", {\n      value: rawObj,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    });\n    Object.freeze(template);\n    TemplateMap.set(templateLiteral, template);\n    return template;\n  }\n  let currentNode;\n  function* Evaluate(node, optionalChainRef, forceYield) {\n    var _hooks$beforeEvaluate, _hooks$beforeBranch2;\n    (_hooks$beforeEvaluate = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate === void 0 || _hooks$beforeEvaluate.call(hooks, node);\n    currentNode = node;\n    if (debug && (forceYield || node.type.endsWith(\"Statement\") && !(node.type === \"ExpressionStatement\" && (node.expression.type === \"CallExpression\" || node.expression.type === \"TaggedTemplateExpression\")) && node.type !== \"TryStatement\" && node.type !== \"BlockStatement\" && node.type !== \"DoWhileStatement\" && node.type !== \"WhileStatement\" && node.type !== \"ForStatement\" && node.type !== \"ForInStatement\" && node.type !== \"ForOfStatement\")) {\n      yield;\n    }\n    // Expressions:\n    switch (node.type) {\n      case \"ArrayExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-array-initializer\n          const array = new ArrayConstructor();\n          for (const element of node.elements) {\n            if (!element) {\n              array.length += 1;\n            } else if (element.type === \"SpreadElement\") {\n              const spreadValues = GetValue(yield* Evaluate(element.argument));\n              array.push(...spreadValues);\n            } else {\n              array.push(GetValue(yield* Evaluate(element)));\n            }\n          }\n          return NormalCompletion(array);\n        }\n      case \"ArrowFunctionExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-arrow-function-definitions\n          ThrowIfFunctionIsInvalid(node);\n          const closure = InstantiateArrowFunctionExpression(node);\n          return NormalCompletion(closure);\n        }\n      case \"BinaryExpression\":\n        {\n          const leftRef = yield* Evaluate(node.left);\n          const leftValue = GetValue(leftRef);\n          const rightRef = yield* Evaluate(node.right);\n          const rightValue = GetValue(rightRef);\n          if (expressionOnly && node.operator === \"|>\") {\n            // Minimal pipeline operator is supported only in expression-only mode.\n            // See https://tc39.es/proposal-pipeline-operator\n            // and https://github.com/tc39/proposal-pipeline-operator\n            if (typeof rightValue !== \"function\") {\n              const funcName = codeSource.substring(node.right.start, node.right.end);\n              throw new TypeError(`${funcName} is not a function`);\n            }\n            let thisValue;\n            if (rightRef instanceof ReferenceRecord) {\n              if (IsPropertyReference(rightRef)) {\n                thisValue = rightRef.Base;\n              }\n            }\n            return NormalCompletion(rightValue.call(thisValue, leftValue));\n          }\n          // https://tc39.es/ecma262/#sec-additive-operators\n          const result = ApplyStringOrNumericBinaryOperator(leftValue, node.operator, rightValue);\n          return NormalCompletion(result);\n        }\n      case \"CallExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-function-calls\n          const ref = (yield* Evaluate(node.callee, optionalChainRef)).Value;\n          const func = GetValue(ref);\n          if ((func === undefined || func === null) && (node.optional || optionalChainRef !== null && optionalChainRef !== void 0 && optionalChainRef.skipped)) {\n            optionalChainRef.skipped = true;\n            return NormalCompletion(undefined);\n          }\n          doSanitize(func);\n          if (debug) yield;\n          return yield* EvaluateCall(func, ref, node.arguments, node.callee);\n        }\n      case \"ChainExpression\":\n        // https://tc39.es/ecma262/#sec-optional-chains\n        return yield* Evaluate(node.expression, {});\n      case \"ConditionalExpression\":\n        // https://tc39.es/ecma262/#sec-conditional-operator\n        return NormalCompletion(GetValue(yield* Evaluate(GetValue(yield* Evaluate(node.test)) ? node.consequent : node.alternate)));\n      case \"Identifier\":\n        // https://tc39.es/ecma262/#sec-identifiers\n        return NormalCompletion(ResolveBinding(node.name));\n      case \"Literal\":\n        {\n          // https://tc39.es/ecma262/#sec-primary-expression-literals\n          if (node.regex) {\n            if (node.value === null) {\n              // Invalid regular expression fails silently in @babel/parser.\n              throw new SyntaxError(`Invalid regular expression: ${node.raw}`);\n            }\n            if (node.regex.flags.includes(\"u\")) {\n              // Currently unicode flag is not fully supported across major browsers.\n              throw new SyntaxError(`Unsupported unicode flag in regular expression: ${node.raw}`);\n            }\n            // Always create a new RegExp, because the AST will be reused.\n            return NormalCompletion(new RegExp(node.regex.pattern, node.regex.flags));\n          }\n          return NormalCompletion(node.value);\n        }\n      case \"LogicalExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-binary-logical-operators\n          const leftValue = GetValue(yield* Evaluate(node.left));\n          switch (node.operator) {\n            case \"&&\":\n              return NormalCompletion(leftValue && GetValue(yield* Evaluate(node.right)));\n            case \"||\":\n              return NormalCompletion(leftValue || GetValue(yield* Evaluate(node.right)));\n            case \"??\":\n              return NormalCompletion(leftValue ?? GetValue(yield* Evaluate(node.right)));\n            // istanbul ignore next\n            default:\n              throw new SyntaxError(\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore never reach here.\n              `Unsupported logical operator '${node.operator}'`);\n          }\n        }\n      case \"MemberExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-property-accessors\n          const baseReference = (yield* Evaluate(node.object, optionalChainRef)).Value;\n          const baseValue = GetValue(baseReference);\n          if ((baseValue === undefined || baseValue === null) && (node.optional || optionalChainRef !== null && optionalChainRef !== void 0 && optionalChainRef.skipped)) {\n            optionalChainRef.skipped = true;\n            return NormalCompletion(undefined);\n          }\n          doSanitize(baseValue);\n          const result = node.computed ? yield* EvaluatePropertyAccessWithExpressionKey(baseValue, node.property, true) : EvaluatePropertyAccessWithIdentifierKey(baseValue, node.property, true);\n          doSanitize(result);\n          return NormalCompletion(result);\n        }\n      case \"NewExpression\":\n        // https://tc39.es/ecma262/#sec-new-operator\n        return yield* EvaluateNew(node.callee, node.arguments);\n      case \"ObjectExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-object-initializer\n          const object = {};\n          for (const prop of node.properties) {\n            if (prop.type === \"SpreadElement\") {\n              const fromValue = GetValue(yield* Evaluate(prop.argument));\n              CopyDataProperties(object, fromValue, new Set());\n            } else {\n              if (prop.kind !== \"init\") {\n                throw new SyntaxError(\"Unsupported object getter/setter\");\n              }\n              const propName = !prop.computed && prop.key.type === \"Identifier\" ? prop.key.name : yield* EvaluateComputedPropertyName(prop.key);\n              if (propName === \"__proto__\") {\n                throw new TypeError(\"Setting '__proto__' property is not allowed\");\n              }\n              const propValue = GetValue(yield* Evaluate(prop.value));\n              if (prop.method && typeof propValue === \"function\") {\n                SetFunctionName(propValue, propName);\n              }\n              object[propName] = propValue;\n            }\n          }\n          return NormalCompletion(object);\n        }\n      case \"SequenceExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-comma-operator\n          let result;\n          for (const expr of node.expressions) {\n            result = NormalCompletion(GetValue(yield* Evaluate(expr)));\n          }\n          return result;\n        }\n      case \"TemplateLiteral\":\n        {\n          // https://tc39.es/ecma262/#sec-template-literals\n          const chunks = [node.quasis[0].value.cooked];\n          let index = 0;\n          for (const expr of node.expressions) {\n            const val = GetValue(yield* Evaluate(expr));\n            chunks.push(String(val));\n            chunks.push(node.quasis[index += 1].value.cooked);\n          }\n          return NormalCompletion(chunks.join(\"\"));\n        }\n      case \"TaggedTemplateExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-tagged-templates\n          const tagRef = (yield* Evaluate(node.tag)).Value;\n          const tagFunc = GetValue(tagRef);\n          doSanitize(tagFunc);\n          if (debug) yield;\n          return yield* EvaluateCall(tagFunc, tagRef, node.quasi, node.tag);\n        }\n      case \"UnaryExpression\":\n        {\n          // https://tc39.es/ecma262/#sec-unary-operators\n          const ref = (yield* Evaluate(node.argument)).Value;\n          if (!expressionOnly && node.operator === \"delete\") {\n            // Delete operator is supported only in function mode.\n            if (!(ref instanceof ReferenceRecord)) {\n              return NormalCompletion(true);\n            }\n            // istanbul ignore else\n            if (IsPropertyReference(ref)) {\n              const deleteStatus = delete ref.Base[ref.ReferenceName];\n              return NormalCompletion(deleteStatus);\n            }\n            // Should never reach here in strict mode.\n          }\n          if (node.operator === \"typeof\") {\n            if (ref instanceof ReferenceRecord && ref.Base === \"unresolvable\") {\n              return NormalCompletion(\"undefined\");\n            }\n            return NormalCompletion(typeof GetValue(ref));\n          }\n          return NormalCompletion(ApplyUnaryOperator(GetValue(ref), node.operator));\n        }\n    }\n    if (!expressionOnly) {\n      // Statements and assignments:\n      switch (node.type) {\n        case \"AssignmentExpression\":\n          {\n            // https://tc39.es/ecma262/#sec-assignment-operators\n            if (node.operator === \"=\") {\n              if (!(node.left.type === \"ArrayPattern\" || node.left.type === \"ObjectPattern\")) {\n                const lref = (yield* Evaluate(node.left)).Value;\n                let rval;\n                if (IsAnonymousFunctionDefinition(node.right) && node.left.type === \"Identifier\") {\n                  rval = NamedEvaluation(node.right, node.left.name);\n                } else {\n                  const rref = yield* Evaluate(node.right);\n                  rval = GetValue(rref);\n                }\n                PutValue(lref, rval);\n                return NormalCompletion(rval);\n              }\n              const rref = yield* Evaluate(node.right);\n              const rval = GetValue(rref);\n              yield* DestructuringAssignmentEvaluation(node.left, rval);\n              return NormalCompletion(rval);\n            }\n            // Operators other than `=`.\n            const lref = (yield* Evaluate(node.left)).Value;\n            const lval = GetValue(lref);\n            const rref = yield* Evaluate(node.right);\n            const rval = GetValue(rref);\n            const r = ApplyStringOrNumericAssignment(lval, node.operator, rval);\n            PutValue(lref, r);\n            return NormalCompletion(r);\n          }\n        case \"BlockStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-block\n            if (!node.body.length) {\n              return NormalCompletion(Empty);\n            }\n            const oldEnv = getRunningContext().LexicalEnvironment;\n            const blockEnv = new DeclarativeEnvironment(oldEnv);\n            BlockDeclarationInstantiation(node.body, blockEnv);\n            getRunningContext().LexicalEnvironment = blockEnv;\n            const blockValue = yield* EvaluateStatementList(node.body);\n            getRunningContext().LexicalEnvironment = oldEnv;\n            return blockValue;\n          }\n        case \"BreakStatement\":\n          // https://tc39.es/ecma262/#sec-break-statement\n          return new CompletionRecord(\"break\", Empty);\n        case \"ContinueStatement\":\n          // https://tc39.es/ecma262/#sec-continue-statement\n          return new CompletionRecord(\"continue\", Empty);\n        case \"EmptyStatement\":\n          // https://tc39.es/ecma262/#sec-empty-statement\n          return NormalCompletion(Empty);\n        case \"DoWhileStatement\":\n          // https://tc39.es/ecma262/#sec-do-while-statement\n          return EvaluateBreakableStatement(yield* DoWhileLoopEvaluation(node));\n        case \"ExpressionStatement\":\n        case \"TSAsExpression\":\n          // https://tc39.es/ecma262/#sec-expression-statement\n          return yield* Evaluate(node.expression);\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n          // https://tc39.es/ecma262/#sec-for-in-and-for-of-statements\n          return EvaluateBreakableStatement(yield* ForInOfLoopEvaluation(node));\n        case \"ForStatement\":\n          // https://tc39.es/ecma262/#sec-for-statement\n          return EvaluateBreakableStatement(yield* ForLoopEvaluation(node));\n        case \"FunctionDeclaration\":\n          // https://tc39.es/ecma262/#sec-function-definitions\n          return NormalCompletion(Empty);\n        case \"FunctionExpression\":\n          // https://tc39.es/ecma262/#sec-function-defining-expressions\n          ThrowIfFunctionIsInvalid(node);\n          return NormalCompletion(InstantiateOrdinaryFunctionExpression(node));\n        case \"IfStatement\":\n          // https://tc39.es/ecma262/#sec-if-statement\n          if (GetValue(yield* Evaluate(node.test))) {\n            var _hooks$beforeBranch;\n            (_hooks$beforeBranch = hooks.beforeBranch) === null || _hooks$beforeBranch === void 0 || _hooks$beforeBranch.call(hooks, node, \"if\");\n            return UpdateEmpty(yield* Evaluate(node.consequent), undefined);\n          }\n          (_hooks$beforeBranch2 = hooks.beforeBranch) === null || _hooks$beforeBranch2 === void 0 || _hooks$beforeBranch2.call(hooks, node, \"else\");\n          if (node.alternate) {\n            return UpdateEmpty(yield* Evaluate(node.alternate), undefined);\n          }\n          return NormalCompletion(undefined);\n        case \"ReturnStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-return-statement\n            let v;\n            if (node.argument) {\n              const exprRef = yield* Evaluate(node.argument);\n              v = GetValue(exprRef);\n            }\n            return new CompletionRecord(\"return\", v);\n          }\n        case \"ThisExpression\":\n          {\n            if (!externalSourceForDebug) {\n              break;\n            }\n            const envRec = GetThisEnvironment();\n            return NormalCompletion(envRec.GetThisBinding());\n          }\n        case \"ThrowStatement\":\n          // https://tc39.es/ecma262/#sec-throw-statement\n          throw GetValue(yield* Evaluate(node.argument));\n        case \"UpdateExpression\":\n          {\n            // https://tc39.es/ecma262/#sec-update-expressions\n            const lhs = (yield* Evaluate(node.argument)).Value;\n            const oldValue = Number(GetValue(lhs));\n            const newValue = node.operator === \"++\" ? oldValue + 1 : oldValue - 1;\n            PutValue(lhs, newValue);\n            return NormalCompletion(node.prefix ? newValue : oldValue);\n          }\n        case \"SwitchCase\":\n          return yield* EvaluateStatementList(node.consequent);\n        case \"SwitchStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-switch-statement\n            const exprRef = yield* Evaluate(node.discriminant);\n            const switchValue = GetValue(exprRef);\n            const oldEnv = getRunningContext().LexicalEnvironment;\n            const blockEnv = new DeclarativeEnvironment(oldEnv);\n            BlockDeclarationInstantiation(node.cases, blockEnv);\n            getRunningContext().LexicalEnvironment = blockEnv;\n            const R = yield* CaseBlockEvaluation(node.cases, switchValue);\n            getRunningContext().LexicalEnvironment = oldEnv;\n            return EvaluateBreakableStatement(R);\n          }\n        case \"TryStatement\":\n          {\n            // https://tc39.es/ecma262/#sec-try-statement\n            let R;\n            try {\n              R = yield* Evaluate(node.block);\n            } catch (error) {\n              if (node.handler) {\n                var _hooks$beforeEvaluate2;\n                currentNode = node.handler;\n                (_hooks$beforeEvaluate2 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate2 === void 0 || _hooks$beforeEvaluate2.call(hooks, node.handler);\n                R = yield* CatchClauseEvaluation(node.handler, error);\n              } else {\n                throw error;\n              }\n            } finally {\n              if (node.finalizer) {\n                const F = yield* Evaluate(node.finalizer);\n                if (F.Type !== \"normal\") {\n                  R = F;\n                }\n              }\n            }\n            return R;\n          }\n        case \"VariableDeclaration\":\n          {\n            // https://tc39.es/ecma262/#sec-declarations-and-the-variable-statement\n            let result;\n            for (const declarator of node.declarations) {\n              currentNode = declarator;\n              if (!declarator.init) {\n                // Assert: a declarator without init is always an identifier.\n                if (node.kind === \"var\") {\n                  result = NormalCompletion(Empty);\n                } else {\n                  const lhs = ResolveBinding(declarator.id.name);\n                  result = InitializeReferencedBinding(lhs, undefined);\n                }\n              } else if (declarator.id.type === \"Identifier\") {\n                currentNode = declarator.init;\n                if (debug && currentNode.type !== \"CallExpression\" && currentNode.type !== \"TaggedTemplateExpression\") yield;\n                const bindingId = declarator.id.name;\n                const lhs = ResolveBinding(bindingId);\n                let value;\n                if (IsAnonymousFunctionDefinition(declarator.init)) {\n                  value = NamedEvaluation(declarator.init, bindingId);\n                } else {\n                  const rhs = yield* Evaluate(declarator.init);\n                  value = GetValue(rhs);\n                }\n                result = node.kind === \"var\" ? PutValue(lhs, value) : InitializeReferencedBinding(lhs, value);\n              } else {\n                currentNode = declarator.init;\n                if (debug && currentNode.type !== \"CallExpression\" && currentNode.type !== \"TaggedTemplateExpression\") yield;\n                const rhs = yield* Evaluate(declarator.init);\n                const rval = GetValue(rhs);\n                result = yield* BindingInitialization(declarator.id, rval, node.kind === \"var\" ? undefined : getRunningContext().LexicalEnvironment);\n              }\n            }\n            return result;\n          }\n        case \"WhileStatement\":\n          // https://tc39.es/ecma262/#sec-while-statement\n          return EvaluateBreakableStatement(yield* WhileLoopEvaluation(node));\n      }\n    }\n    // eslint-disable-next-line no-console\n    throw new SyntaxError(`Unsupported node type \\`${node.type}\\``);\n  }\n\n  // https://tc39.es/ecma262/#sec-execution-contexts\n  function getRunningContext() {\n    return executionContextStack[executionContextStack.length - 1];\n  }\n\n  // https://tc39.es/ecma262/#sec-resolvebinding\n  function ResolveBinding(name, env) {\n    if (!env) {\n      env = getRunningContext().LexicalEnvironment;\n    }\n    return GetIdentifierReference(env, name, true);\n  }\n\n  // Try statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-catchclauseevaluation\n  function* CatchClauseEvaluation(node, thrownValue) {\n    if (!node.param) {\n      return yield* Evaluate(node.body);\n    }\n    const oldEnv = getRunningContext().LexicalEnvironment;\n    const catchEnv = new DeclarativeEnvironment(oldEnv);\n    for (const argName of collectBoundNames(node.param)) {\n      catchEnv.CreateMutableBinding(argName, false);\n    }\n    getRunningContext().LexicalEnvironment = catchEnv;\n    yield* BindingInitialization(node.param, thrownValue, catchEnv);\n    const B = yield* Evaluate(node.body);\n    getRunningContext().LexicalEnvironment = oldEnv;\n    return B;\n  }\n\n  // Iteration statements and switch statements.\n  // https://tc39.es/ecma262/#prod-BreakableStatement\n  function EvaluateBreakableStatement(stmtResult) {\n    return stmtResult.Type === \"break\" ? stmtResult.Value === Empty ? NormalCompletion(undefined) : NormalCompletion(stmtResult.Value) : stmtResult;\n  }\n\n  // Switch statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation\n  function* CaseBlockEvaluation(cases, input) {\n    let V;\n    const defaultCaseIndex = cases.findIndex(switchCase => !switchCase.test);\n    const hasDefaultCase = defaultCaseIndex >= 0;\n    const A = hasDefaultCase ? cases.slice(0, defaultCaseIndex) : cases;\n    let found = false;\n    for (const C of A) {\n      if (!found) {\n        found = yield* CaseClauseIsSelected(C, input);\n      }\n      if (found) {\n        const R = yield* Evaluate(C);\n        if (R.Value !== Empty) {\n          V = R.Value;\n        }\n        if (R.Type !== \"normal\") {\n          return UpdateEmpty(R, V);\n        }\n      }\n    }\n    if (!hasDefaultCase) {\n      return NormalCompletion(V);\n    }\n    let foundInB = false;\n    const B = cases.slice(defaultCaseIndex + 1);\n    if (!found) {\n      for (const C of B) {\n        if (!foundInB) {\n          foundInB = yield* CaseClauseIsSelected(C, input);\n        }\n        if (foundInB) {\n          const R = yield* Evaluate(C);\n          if (R.Value !== Empty) {\n            V = R.Value;\n          }\n          if (R.Type !== \"normal\") {\n            return UpdateEmpty(R, V);\n          }\n        }\n      }\n    }\n    if (foundInB) {\n      return NormalCompletion(V);\n    }\n    const R = yield* Evaluate(cases[defaultCaseIndex]);\n    if (R.Value !== Empty) {\n      V = R.Value;\n    }\n    if (R.Type !== \"normal\") {\n      return UpdateEmpty(R, V);\n    }\n\n    // NOTE: The following is another complete iteration of the second CaseClauses.\n    for (const C of B) {\n      const R = yield* Evaluate(C);\n      if (R.Value !== Empty) {\n        V = R.Value;\n      }\n      if (R.Type !== \"normal\") {\n        return UpdateEmpty(R, V);\n      }\n    }\n    return NormalCompletion(V);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected\n  function* CaseClauseIsSelected(C, input) {\n    const clauseSelector = GetValue(yield* Evaluate(C.test));\n    return input === clauseSelector;\n  }\n\n  // While statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-whileloopevaluation\n  function* WhileLoopEvaluation(node) {\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const exprValue = GetValue(yield* Evaluate(node.test, undefined, true));\n      if (!exprValue) {\n        return NormalCompletion(V);\n      }\n      const stmtResult = yield* Evaluate(node.body);\n      if (!LoopContinues(stmtResult)) {\n        return UpdateEmpty(stmtResult, V);\n      }\n      if (stmtResult.Value !== Empty) {\n        V = stmtResult.Value;\n      }\n    }\n  }\n\n  // Do-while Statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-dowhileloopevaluation\n  function* DoWhileLoopEvaluation(node) {\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const stmtResult = yield* Evaluate(node.body);\n      if (!LoopContinues(stmtResult)) {\n        return UpdateEmpty(stmtResult, V);\n      }\n      if (stmtResult.Value !== Empty) {\n        V = stmtResult.Value;\n      }\n      const exprValue = GetValue(yield* Evaluate(node.test, undefined, true));\n      if (!exprValue) {\n        return NormalCompletion(V);\n      }\n    }\n  }\n\n  // For in/of statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forinofloopevaluation\n  function* ForInOfLoopEvaluation(node) {\n    const lhs = node.left;\n    const isVariableDeclaration = lhs.type === \"VariableDeclaration\";\n    const lhsKind = isVariableDeclaration ? lhs.kind === \"var\" ? \"varBinding\" : \"lexicalBinding\" : \"assignment\";\n    const uninitializedBoundNames = lhsKind === \"lexicalBinding\" ? collectBoundNames(lhs) : [];\n    const iterationKind = node.type === \"ForInStatement\" ? \"enumerate\" : \"iterate\";\n    const keyResult = yield* ForInOfHeadEvaluation(uninitializedBoundNames, node.right, iterationKind);\n    if (keyResult.Type !== \"normal\") {\n      // When enumerate, if the target is nil, a break completion will be returned.\n      return keyResult;\n    }\n    return yield* ForInOfBodyEvaluation(lhs, node.body, keyResult.Value, iterationKind, lhsKind);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forinofheadevaluation\n  function* ForInOfHeadEvaluation(uninitializedBoundNames, expr, iterationKind) {\n    const runningContext = getRunningContext();\n    const oldEnv = runningContext.LexicalEnvironment;\n    if (uninitializedBoundNames.length > 0) {\n      const newEnv = new DeclarativeEnvironment(oldEnv);\n      for (const name of uninitializedBoundNames) {\n        newEnv.CreateMutableBinding(name, false);\n      }\n      runningContext.LexicalEnvironment = newEnv;\n    }\n    const exprRef = yield* Evaluate(expr, undefined, true);\n    runningContext.LexicalEnvironment = oldEnv;\n    const exprValue = GetValue(exprRef);\n    if (iterationKind === \"enumerate\") {\n      if (exprValue === null || exprValue === undefined) {\n        return new CompletionRecord(\"break\", Empty);\n      }\n      const iterator = EnumerateObjectProperties(exprValue);\n      return NormalCompletion(iterator);\n    }\n    const iterator = CreateListIteratorRecord(exprValue);\n    return NormalCompletion(iterator);\n  }\n  function* ForInOfBodyEvaluation(node, stmt, iteratorRecord, iterationKind, lhsKind) {\n    const lhs = lhsKind === \"assignment\" ? node : node.declarations[0].id;\n    const oldEnv = getRunningContext().LexicalEnvironment;\n    let V;\n    // When `destructuring` is false,\n    // For `node` whose `kind` is assignment:\n    //   `lhs` is an `Identifier` or a `MemberExpression`,\n    // Otherwise:\n    //   `lhs` is an `Identifier`.\n    const destructuring = lhs.type === \"ObjectPattern\" || lhs.type === \"ArrayPattern\";\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      currentNode = lhs;\n      const {\n        done,\n        value: nextValue\n      } = iteratorRecord.next();\n      if (done) {\n        if (debug) yield;\n        return NormalCompletion(V);\n      }\n      let lhsRef;\n      let iterationEnv;\n      if (lhsKind === \"lexicalBinding\") {\n        iterationEnv = new DeclarativeEnvironment(oldEnv);\n        ForDeclarationBindingInstantiation(node, iterationEnv);\n        getRunningContext().LexicalEnvironment = iterationEnv;\n        if (debug) yield;\n        if (!destructuring) {\n          const [lhsName] = collectBoundNames(lhs);\n          lhsRef = ResolveBinding(lhsName);\n        }\n      } else {\n        if (debug) yield;\n        if (!destructuring) {\n          lhsRef = (yield* Evaluate(lhs)).Value;\n        }\n      }\n      destructuring ? lhsKind === \"assignment\" ? yield* DestructuringAssignmentEvaluation(lhs, nextValue) : lhsKind === \"varBinding\" ? yield* BindingInitialization(lhs, nextValue, undefined) : yield* BindingInitialization(lhs, nextValue, iterationEnv) : lhsKind === \"lexicalBinding\" ? InitializeReferencedBinding(lhsRef, nextValue) : PutValue(lhsRef, nextValue);\n      const result = yield* Evaluate(stmt);\n      getRunningContext().LexicalEnvironment = oldEnv;\n      if (!LoopContinues(result)) {\n        const status = UpdateEmpty(result, V);\n        if (!(iterationKind === \"enumerate\" || iteratorRecord.return === undefined)) {\n          // Perform *IteratorClose*\n          // https://tc39.es/ecma262/#sec-iteratorclose\n          const innerResult = iteratorRecord.return();\n          if (!innerResult || ![\"object\", \"function\"].includes(typeof innerResult)) {\n            throw new TypeError(`Iterator result is not an object`);\n          }\n        }\n        return status;\n      }\n      if (result.Value !== Empty) {\n        V = result.Value;\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-enumerate-object-properties\n  function* EnumerateObjectProperties(value) {\n    for (const key in value) {\n      yield key;\n    }\n  }\n\n  // For statements.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-forloopevaluation\n  function* ForLoopEvaluation(node) {\n    var _node$init;\n    if (((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === \"VariableDeclaration\") {\n      // `for (var … ; … ; … ) …`\n      if (node.init.kind === \"var\") {\n        yield* Evaluate(node.init);\n        return yield* ForBodyEvaluation(node.test, node.update, node.body, []);\n      }\n      // `for (let/const … ; … ; … ) …`\n      const oldEnv = getRunningContext().LexicalEnvironment;\n      const loopEnv = new DeclarativeEnvironment(oldEnv);\n      const isConst = node.init.kind === \"const\";\n      const boundNames = collectBoundNames(node.init);\n      for (const dn of boundNames) {\n        if (isConst) {\n          loopEnv.CreateImmutableBinding(dn, true);\n        } else {\n          loopEnv.CreateMutableBinding(dn, false);\n        }\n      }\n      getRunningContext().LexicalEnvironment = loopEnv;\n      yield* Evaluate(node.init);\n      const perIterationLets = isConst ? [] : Array.from(boundNames);\n      const bodyResult = yield* ForBodyEvaluation(node.test, node.update, node.body, perIterationLets);\n      getRunningContext().LexicalEnvironment = oldEnv;\n      return bodyResult;\n    }\n    // `for ( … ; … ; … ) …`\n    if (node.init) {\n      const exprRef = yield* Evaluate(node.init);\n      GetValue(exprRef);\n    }\n    return yield* ForBodyEvaluation(node.test, node.update, node.body, []);\n  }\n\n  // https://tc39.es/ecma262/#sec-forbodyevaluation\n  function* ForBodyEvaluation(test, increment, stmt, perIterationBindings) {\n    CreatePerIterationEnvironment(perIterationBindings);\n    let V;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (test) {\n        const testRef = yield* Evaluate(test, undefined, true);\n        const testValue = GetValue(testRef);\n        if (!testValue) {\n          return NormalCompletion(V);\n        }\n      }\n      const result = yield* Evaluate(stmt);\n      if (!LoopContinues(result)) {\n        return UpdateEmpty(result, V);\n      }\n      if (result.Value) {\n        V = result.Value;\n      }\n      CreatePerIterationEnvironment(perIterationBindings);\n      if (increment) {\n        const incRef = yield* Evaluate(increment, undefined, true);\n        GetValue(incRef);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-createperiterationenvironment\n  function CreatePerIterationEnvironment(perIterationBindings) {\n    if (perIterationBindings.length === 0) {\n      return;\n    }\n    const lastIterationEnv = getRunningContext().LexicalEnvironment;\n    const outer = lastIterationEnv.OuterEnv;\n    const thisIterationEnv = new DeclarativeEnvironment(outer);\n    for (const bn of perIterationBindings) {\n      thisIterationEnv.CreateMutableBinding(bn, false);\n      const lastValue = lastIterationEnv.GetBindingValue(bn, false);\n      thisIterationEnv.InitializeBinding(bn, lastValue);\n    }\n    getRunningContext().LexicalEnvironment = thisIterationEnv;\n  }\n\n  // Destructuring assignments.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-destructuringassignmentevaluation\n  function* DestructuringAssignmentEvaluation(pattern, value) {\n    if (pattern.type === \"ObjectPattern\") {\n      RequireObjectCoercible(value);\n      if (pattern.properties.length > 0) {\n        yield* PropertyDestructuringAssignmentEvaluation(pattern.properties, value);\n      }\n      return NormalCompletion(Empty);\n    }\n    const iteratorRecord = CreateListIteratorRecord(value);\n    return yield* IteratorDestructuringAssignmentEvaluation(pattern.elements, iteratorRecord);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-propertydestructuringassignmentevaluation\n  function* PropertyDestructuringAssignmentEvaluation(properties, value) {\n    const excludedNames = new Set();\n    for (const prop of properties) {\n      if (prop.type === \"Property\") {\n        const propName = !prop.computed && prop.key.type === \"Identifier\" ? prop.key.name : yield* EvaluateComputedPropertyName(prop.key);\n        const valueTarget = prop.value.type === \"AssignmentPattern\" ? prop.value.left : prop.value;\n        if (valueTarget.type === \"Identifier\") {\n          const lref = ResolveBinding(valueTarget.name);\n          let v = GetV(value, propName);\n          if (prop.value.type === \"AssignmentPattern\" && v === undefined) {\n            if (IsAnonymousFunctionDefinition(prop.value.right)) {\n              v = NamedEvaluation(prop.value.right, valueTarget.name);\n            } else {\n              const defaultValue = yield* Evaluate(prop.value.right);\n              v = GetValue(defaultValue);\n            }\n          }\n          PutValue(lref, v);\n          excludedNames.add(propName);\n        } else {\n          yield* KeyedDestructuringAssignmentEvaluation(prop.value, value, propName);\n          excludedNames.add(propName);\n        }\n      } else {\n        yield* RestDestructuringAssignmentEvaluation(prop, value, excludedNames);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-keyeddestructuringassignmentevaluation\n  function* KeyedDestructuringAssignmentEvaluation(node, value, propertyName) {\n    const assignmentTarget = node.type === \"AssignmentPattern\" ? node.left : node;\n    const isObjectOrArray = assignmentTarget.type === \"ArrayPattern\" || assignmentTarget.type === \"ObjectPattern\";\n    let lref;\n    if (!isObjectOrArray) {\n      lref = (yield* Evaluate(assignmentTarget)).Value;\n    }\n    const v = GetV(value, propertyName);\n    let rhsValue;\n    if (node.type === \"AssignmentPattern\" && v === undefined) {\n      // `assignmentTarget.type` is never \"Identifier\" here.\n      const defaultValue = yield* Evaluate(node.right);\n      rhsValue = GetValue(defaultValue);\n    } else {\n      rhsValue = v;\n    }\n    if (isObjectOrArray) {\n      return yield* DestructuringAssignmentEvaluation(assignmentTarget, rhsValue);\n    }\n    return PutValue(lref, rhsValue);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-restdestructuringassignmentevaluation\n  function* RestDestructuringAssignmentEvaluation(restProperty, value, excludedNames) {\n    const lref = (yield* Evaluate(restProperty.argument)).Value;\n    const restObj = CopyDataProperties({}, value, excludedNames);\n    return PutValue(lref, restObj);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-iteratordestructuringassignmentevaluation\n  function* IteratorDestructuringAssignmentEvaluation(elements, iteratorRecord) {\n    let status = NormalCompletion(Empty);\n    for (const element of elements) {\n      if (!element) {\n        iteratorRecord.next();\n        status = NormalCompletion(Empty);\n        continue;\n      }\n      const assignmentTarget = element.type === \"RestElement\" ? element.argument : element.type === \"AssignmentPattern\" ? element.left : element;\n      const isObjectOrArray = assignmentTarget.type === \"ArrayPattern\" || assignmentTarget.type === \"ObjectPattern\";\n      let lref;\n      if (!isObjectOrArray) {\n        lref = (yield* Evaluate(assignmentTarget)).Value;\n      }\n      let v;\n      if (element.type !== \"RestElement\") {\n        const {\n          done,\n          value: nextValue\n        } = iteratorRecord.next();\n        const value = done ? undefined : nextValue;\n        if (element.type === \"AssignmentPattern\" && value === undefined) {\n          if (IsAnonymousFunctionDefinition(element.right) && assignmentTarget.type === \"Identifier\") {\n            v = NamedEvaluation(element.right, assignmentTarget.name);\n          } else {\n            const defaultValue = yield* Evaluate(element.right);\n            v = GetValue(defaultValue);\n          }\n        } else {\n          v = value;\n        }\n      } else {\n        // RestElement\n        v = new ArrayConstructor();\n        let n = 0;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          const {\n            done,\n            value: nextValue\n          } = iteratorRecord.next();\n          if (done) {\n            break;\n          }\n          v[n] = nextValue;\n          n++;\n        }\n      }\n      if (isObjectOrArray) {\n        status = yield* DestructuringAssignmentEvaluation(assignmentTarget, v);\n      } else {\n        status = PutValue(lref, v);\n      }\n    }\n    return status;\n  }\n\n  // Object expressions.\n  // https://tc39.es/ecma262/#sec-evaluate-property-access-with-expression-key\n  function* EvaluatePropertyAccessWithExpressionKey(baseValue, expression, strict) {\n    const propertyNameReference = yield* Evaluate(expression);\n    const propertyNameValue = GetValue(propertyNameReference);\n    const propertyKey = ToPropertyKey(propertyNameValue);\n    return new ReferenceRecord(baseValue, propertyKey, strict);\n  }\n\n  // https://tc39.es/ecma262/#sec-evaluate-property-access-with-identifier-key\n  function EvaluatePropertyAccessWithIdentifierKey(baseValue, identifier, strict) {\n    currentNode = identifier;\n    const propertyNameString = identifier.name;\n    return new ReferenceRecord(baseValue, propertyNameString, strict);\n  }\n\n  // Block statements.\n  // https://tc39.es/ecma262/#sec-blockdeclarationinstantiation\n  function BlockDeclarationInstantiation(code, env) {\n    const declarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: false\n    });\n    for (const d of declarations) {\n      const IsConstantDeclaration = d.type === \"VariableDeclaration\" && d.kind === \"const\";\n      for (const dn of collectBoundNames(d)) {\n        if (IsConstantDeclaration) {\n          env.CreateImmutableBinding(dn, true);\n        } else {\n          env.CreateMutableBinding(dn, false);\n        }\n      }\n      if (d.type === \"FunctionDeclaration\") {\n        const [fn] = collectBoundNames(d);\n        const fo = InstantiateFunctionObject(d, env);\n        env.InitializeBinding(fn, fo);\n      }\n    }\n  }\n\n  // Function declarations and expressions.\n  // https://tc39.es/ecma262/#sec-evaluatecall\n  function* EvaluateCall(func, ref, args, callee) {\n    let thisValue;\n    if (ref instanceof ReferenceRecord) {\n      if (IsPropertyReference(ref)) {\n        thisValue = ref.Base;\n      }\n    }\n    const argList = yield* ArgumentListEvaluation(args);\n    if (typeof func !== \"function\") {\n      const funcName = codeSource.substring(callee.start, callee.end);\n      throw new TypeError(`${funcName} is not a function`);\n    }\n    if (debug || externalSourceForDebug) {\n      const debuggerCall = func[DebuggerCall];\n      if (debuggerCall) {\n        const result = yield* debuggerCall.apply(thisValue, argList);\n        doSanitize(result);\n        return NormalCompletion(result);\n      }\n    }\n    const result = func.apply(thisValue, argList);\n    doSanitize(result);\n    return NormalCompletion(result);\n  }\n\n  // https://tc39.es/ecma262/#sec-evaluatenew\n  function* EvaluateNew(constructExpr, args) {\n    const ref = yield* Evaluate(constructExpr);\n    const constructor = GetValue(ref);\n    const argList = yield* ArgumentListEvaluation(args);\n    if (typeof constructor !== \"function\" || constructor[IsConstructor] === false) {\n      const constructorName = codeSource.substring(constructExpr.start, constructExpr.end);\n      throw new TypeError(`${constructorName} is not a constructor`);\n    }\n    if (!externalSourceForDebug && !isAllowedConstructor(constructor) && constructor !== ArrayConstructor) {\n      const constructorName = codeSource.substring(constructExpr.start, constructExpr.end);\n      throw new TypeError(`${constructorName} is not an allowed constructor`);\n    }\n    return NormalCompletion(new constructor(...argList));\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-argumentlistevaluation\n  function* ArgumentListEvaluation(args) {\n    const array = [];\n    if (Array.isArray(args)) {\n      for (const arg of args) {\n        if (arg.type === \"SpreadElement\") {\n          const spreadValues = GetValue(yield* Evaluate(arg.argument));\n          array.push(...spreadValues);\n        } else {\n          array.push(GetValue(yield* Evaluate(arg)));\n        }\n      }\n    } else {\n      array.push(GetTemplateObject(args));\n      for (const expr of args.expressions) {\n        array.push(GetValue(yield* Evaluate(expr)));\n      }\n    }\n    return array;\n  }\n\n  // https://tc39.es/ecma262/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n  function* CallFunction(closure, thisArgument, args) {\n    var _hooks$beforeCall;\n    (_hooks$beforeCall = hooks.beforeCall) === null || _hooks$beforeCall === void 0 || _hooks$beforeCall.call(hooks, closure[SourceNode]);\n    const calleeContext = PrepareForOrdinaryCall(closure);\n    OrdinaryCallBindThis(closure, calleeContext, thisArgument);\n    const result = yield* OrdinaryCallEvaluateBody(closure, args);\n    if (debug) {\n      currentNode = {\n        ...closure[SourceNode],\n        [DebuggerReturn]: true\n      };\n      yield {\n        type: \"return\",\n        value: result.Type === \"return\" ? result.Value : undefined\n      };\n    }\n    executionContextStack.pop();\n    globalExecutionContextStack.pop();\n    if (result.Type === \"return\") {\n      return result.Value;\n    }\n    return undefined;\n  }\n\n  // https://tc39.es/ecma262/#sec-prepareforordinarycall\n  function PrepareForOrdinaryCall(F) {\n    const calleeContext = new ExecutionContext();\n    calleeContext.Function = F;\n    const localEnv = new FunctionEnvironment(F);\n    calleeContext.VariableEnvironment = localEnv;\n    calleeContext.LexicalEnvironment = localEnv;\n    executionContextStack.push(calleeContext);\n    globalExecutionContextStack.push(calleeContext);\n    return calleeContext;\n  }\n  function OrdinaryCallBindThis(F, calleeContext, thisArgument) {\n    if (F[ThisMode] === Mode.LEXICAL) {\n      return;\n    }\n    const localEnv = calleeContext.LexicalEnvironment;\n    localEnv === null || localEnv === void 0 || localEnv.BindThisValue(thisArgument);\n  }\n\n  // https://tc39.es/ecma262/#sec-ordinarycallevaluatebody\n  function* OrdinaryCallEvaluateBody(F, args) {\n    return yield* EvaluateFunctionBody(F[ECMAScriptCode], F, args);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-evaluatefunctionbody\n  function* EvaluateFunctionBody(body, F, args) {\n    yield* FunctionDeclarationInstantiation(F, args);\n    if (Array.isArray(body)) {\n      return yield* EvaluateStatementList(body);\n    }\n    return new CompletionRecord(\"return\", GetValue(yield* Evaluate(body)));\n  }\n\n  // https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation\n  function* EvaluateStatementList(statements) {\n    let result = NormalCompletion(Empty);\n    for (const stmt of statements) {\n      const s = yield* Evaluate(stmt);\n      if (s.Type !== \"normal\") {\n        return s;\n      }\n      result = UpdateEmpty(result, s.Value);\n    }\n    return result;\n  }\n  function GetThisEnvironment() {\n    let env = getRunningContext().LexicalEnvironment;\n    while (env) {\n      if (env.HasThisBinding()) {\n        return env;\n      }\n      env = env.OuterEnv;\n    }\n    throw new Error(\"Accessing global this is forbidden\");\n  }\n\n  // https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition\n  function IsAnonymousFunctionDefinition(node) {\n    // No ParenthesizedExpression in ESTree.\n    return node.type === \"FunctionExpression\" && !node.id || node.type === \"ArrowFunctionExpression\";\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-namedevaluation\n  function NamedEvaluation(node, name) {\n    var _hooks$beforeEvaluate3;\n    (_hooks$beforeEvaluate3 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate3 === void 0 || _hooks$beforeEvaluate3.call(hooks, node);\n    // No ParenthesizedExpression in ESTree.\n    switch (node.type) {\n      case \"FunctionExpression\":\n        return InstantiateOrdinaryFunctionExpression(node, name);\n      case \"ArrowFunctionExpression\":\n        return InstantiateArrowFunctionExpression(node, name);\n      // istanbul ignore next: should never happen\n      default:\n        throw new Error(`Unexpected node type for NamedEvaluation: ${node.type}`);\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-functiondeclarationinstantiation\n  function* FunctionDeclarationInstantiation(func, args) {\n    const calleeContext = getRunningContext();\n    const code = func[ECMAScriptCode];\n    const formals = func[FormalParameters];\n    const parameterNames = collectBoundNames(formals);\n    const hasParameterExpressions = containsExpression(formals);\n    const varDeclarations = collectScopedDeclarations(code, {\n      var: true,\n      topLevel: true\n    });\n    const varNames = collectBoundNames(varDeclarations);\n\n    // `functionNames` ∈ `varNames`\n    // `functionsToInitialize` ≈ `functionNames`\n    const functionNames = [];\n    const functionsToInitialize = [];\n    for (let i = varDeclarations.length - 1; i >= 0; i--) {\n      const d = varDeclarations[i];\n      if (d.type === \"FunctionDeclaration\") {\n        ThrowIfFunctionIsInvalid(d);\n        const [fn] = collectBoundNames(d);\n        if (!functionNames.includes(fn)) {\n          functionNames.unshift(fn);\n          functionsToInitialize.unshift(d);\n        }\n      } else if (rules !== null && rules !== void 0 && rules.noVar) {\n        throw new SyntaxError(\"Var declaration is not recommended, use `let` or `const` instead\");\n      }\n    }\n\n    // let argumentsObjectNeeded = true;\n    // if (func[ThisMode] === Mode.LEXICAL) {\n    //   // NOTE: Arrow functions never have an arguments object.\n    //   argumentsObjectNeeded = false;\n    // } else if (parameterNames.includes(\"arguments\")) {\n    //   argumentsObjectNeeded = false;\n    // } else if (!hasParameterExpressions && (\n    //   varNames.includes(\"arguments\") ||\n    //   collectBoundNames(collectScopedDeclarations(code, { var: false })).includes(\"arguments\")\n    // )) {\n    //   argumentsObjectNeeded = false;\n    // }\n    // NOTE: In strict mode, no parameter/function/var/lexical names can be \"arguments\".\n    const argumentsObjectNeeded = !!externalSourceForDebug && func[ThisMode] !== Mode.LEXICAL;\n    const env = calleeContext.LexicalEnvironment;\n    for (const paramName of parameterNames) {\n      // In strict mode, it's guaranteed no duplicate params exist.\n      env.CreateMutableBinding(paramName, false);\n    }\n    let parameterBindings = parameterNames;\n    if (argumentsObjectNeeded) {\n      const ao = CreateUnmappedArgumentsObject(args);\n      env.CreateImmutableBinding(\"arguments\", false);\n      env.InitializeBinding(\"arguments\", ao);\n      parameterBindings = parameterNames.concat(\"arguments\");\n    }\n    const iteratorRecord = CreateListIteratorRecord(args);\n    yield* IteratorBindingInitialization(formals, iteratorRecord, env);\n    let varEnv;\n    if (!hasParameterExpressions) {\n      // NOTE: Only a single Environment Record is needed for the parameters\n      // and top-level vars.\n      // `varNames` are unique.\n      const instantiatedVarNames = [...parameterBindings];\n      for (const n of varNames) {\n        if (!instantiatedVarNames.includes(n)) {\n          instantiatedVarNames.push(n);\n          env.CreateMutableBinding(n, false);\n          env.InitializeBinding(n, undefined);\n        }\n      }\n      varEnv = env;\n    } else {\n      // NOTE: A separate Environment Record is needed to ensure that closures\n      // created by expressions in the formal parameter list do not have\n      // visibility of declarations in the function body.\n      varEnv = new DeclarativeEnvironment(env);\n      calleeContext.VariableEnvironment = varEnv;\n      // `varNames` are unique.\n      const instantiatedVarNames = [];\n      for (const n of varNames) {\n        if (!instantiatedVarNames.includes(n)) {\n          instantiatedVarNames.push(n);\n          varEnv.CreateMutableBinding(n, false);\n          let initialValue;\n          if (parameterBindings.includes(n) && !functionNames.includes(n)) {\n            initialValue = env.GetBindingValue(n, false);\n          }\n          varEnv.InitializeBinding(n, initialValue);\n          // NOTE: A var with the same name as a formal parameter initially has\n          // the same value as the corresponding initialized parameter.\n        }\n      }\n    }\n    const lexEnv = varEnv;\n    calleeContext.LexicalEnvironment = lexEnv;\n    const lexDeclarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: true\n    });\n    for (const d of lexDeclarations) {\n      for (const dn of collectBoundNames(d)) {\n        // Only lexical VariableDeclaration here in top-level.\n        if (d.kind === \"const\") {\n          lexEnv.CreateImmutableBinding(dn, true);\n        } else {\n          lexEnv.CreateMutableBinding(dn, false);\n        }\n      }\n    }\n    for (const f of functionsToInitialize) {\n      const [fn] = collectBoundNames(f);\n      const fo = InstantiateFunctionObject(f, lexEnv);\n      varEnv.SetMutableBinding(fn, fo, false);\n    }\n  }\n  function CreateUnmappedArgumentsObject(args) {\n    const argList = [...args];\n    const argumentObject = {};\n    Object.defineProperty(argumentObject, \"length\", {\n      value: argList.length,\n      writable: true,\n      configurable: true\n    });\n    for (let index = 0; index < argList.length; index++) {\n      argumentObject[String(index)] = argList[index];\n    }\n    Object.defineProperty(argumentObject, Symbol.iterator, {\n      value: Array.prototype.values,\n      writable: true,\n      configurable: true\n    });\n    const ThrowTypeError = () => {\n      throw new TypeError(\"'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them\");\n    };\n    Object.defineProperty(argumentObject, \"callee\", {\n      get: ThrowTypeError,\n      set: ThrowTypeError\n    });\n    return argumentObject;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiatefunctionobject\n  function InstantiateFunctionObject(func, scope) {\n    const F = OrdinaryFunctionCreate(func, scope, true, false);\n    if (func.id) {\n      SetFunctionName(F, func.id.name);\n    }\n    return F;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiateordinaryfunctionexpression\n  function InstantiateOrdinaryFunctionExpression(functionExpression, name) {\n    const scope = getRunningContext().LexicalEnvironment;\n    if (functionExpression.id) {\n      const name = functionExpression.id.name;\n      const funcEnv = new DeclarativeEnvironment(scope);\n      funcEnv.CreateImmutableBinding(name, false);\n      const closure = OrdinaryFunctionCreate(functionExpression, funcEnv, true, false);\n      SetFunctionName(closure, name);\n      funcEnv.InitializeBinding(name, closure);\n      return closure;\n    } else {\n      const closure = OrdinaryFunctionCreate(functionExpression, scope, true, false);\n      SetFunctionName(closure, name ?? \"\");\n      return closure;\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-instantiatearrowfunctionexpression\n  function InstantiateArrowFunctionExpression(arrowFunction, name) {\n    const scope = getRunningContext().LexicalEnvironment;\n    const closure = OrdinaryFunctionCreate(arrowFunction, scope, false, true);\n    SetFunctionName(closure, name ?? \"\");\n    return closure;\n  }\n  function SetFunctionName(F, name) {\n    Object.defineProperty(F, \"name\", {\n      value: name,\n      configurable: true\n    });\n  }\n\n  // https://tc39.es/ecma262/#sec-ordinaryfunctioncreate\n  function OrdinaryFunctionCreate(sourceNode, scope, isConstructor, lexicalThis) {\n    const F = function () {\n      // eslint-disable-next-line prefer-rest-params\n      return unwind(CallFunction(F, this, arguments));\n    };\n    Object.defineProperties(F, {\n      [SourceNode]: {\n        value: sourceNode\n      },\n      [FormalParameters]: {\n        value: sourceNode.params\n      },\n      [ECMAScriptCode]: {\n        value: sourceNode.body.type === \"BlockStatement\" ? sourceNode.body.body : sourceNode.body\n      },\n      [Environment]: {\n        value: scope\n      },\n      [IsConstructor]: {\n        value: isConstructor\n      },\n      [ThisMode]: {\n        value: lexicalThis ? Mode.LEXICAL : Mode.STRICT\n      }\n    });\n    const len = ExpectedArgumentCount(sourceNode.params);\n    Object.defineProperty(F, \"length\", {\n      configurable: true,\n      value: len\n    });\n    if (debug || externalSourceForDebug) {\n      Object.defineProperty(F, DebuggerCall, {\n        value: function () {\n          // eslint-disable-next-line prefer-rest-params\n          return CallFunction(F, this, arguments);\n        }\n      });\n    }\n    return F;\n  }\n  function ExpectedArgumentCount(params) {\n    let count = 0;\n    for (const param of params) {\n      switch (param.type) {\n        case \"AssignmentPattern\":\n        case \"RestElement\":\n          return count;\n        default:\n          count++;\n      }\n    }\n    return count;\n  }\n\n  // Patterns initialization.\n  // https://tc39.es/ecma262/#sec-runtime-semantics-bindinginitialization\n  function* BindingInitialization(node, value, environment) {\n    switch (node.type) {\n      case \"Identifier\":\n        return InitializeBoundName(node.name, value, environment);\n      case \"ObjectPattern\":\n        RequireObjectCoercible(value);\n        return yield* PropertyBindingInitialization(node.properties, value, environment);\n      case \"ArrayPattern\":\n        {\n          const iteratorRecord = CreateListIteratorRecord(value);\n          return yield* IteratorBindingInitialization(node.elements, iteratorRecord, environment);\n        }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-propertybindinginitialization\n  function* PropertyBindingInitialization(properties, value, environment) {\n    const excludedNames = new Set();\n    for (const prop of properties) {\n      if (prop.type === \"RestElement\") {\n        return RestBindingInitialization(prop, value, environment, excludedNames);\n      }\n      if (!prop.computed && prop.key.type === \"Identifier\") {\n        yield* KeyedBindingInitialization(prop.value, value, environment, prop.key.name);\n        excludedNames.add(prop.key.name);\n      } else {\n        const P = yield* EvaluateComputedPropertyName(prop.key);\n        yield* KeyedBindingInitialization(prop.value, value, environment, P);\n        excludedNames.add(P);\n      }\n    }\n    return NormalCompletion(Empty);\n  }\n\n  // https://tc39.es/ecma262/#prod-ComputedPropertyName\n  function* EvaluateComputedPropertyName(node) {\n    const propName = GetValue(yield* Evaluate(node));\n    return ToPropertyKey(propName);\n  }\n\n  // https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-restbindinginitialization\n  function RestBindingInitialization(restProperty, value, environment, excludedNames) {\n    const lhs = ResolveBinding(restProperty.argument.name, environment);\n    const restObj = CopyDataProperties({}, value, excludedNames);\n    if (!environment) {\n      return PutValue(lhs, restObj);\n    }\n    return InitializeReferencedBinding(lhs, restObj);\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-iteratorbindinginitialization\n  function* IteratorBindingInitialization(elements, iteratorRecord, environment) {\n    if (elements.length === 0) {\n      return NormalCompletion(Empty);\n    }\n    let result;\n    for (const node of elements) {\n      if (!node) {\n        // Elision element.\n        iteratorRecord.next();\n        result = NormalCompletion(Empty);\n      } else if (node.type === \"RestElement\") {\n        // Rest element.\n        if (node.argument.type === \"Identifier\") {\n          const lhs = ResolveBinding(node.argument.name, environment);\n          const A = new ArrayConstructor();\n          let n = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const {\n              done,\n              value\n            } = iteratorRecord.next();\n            if (done) {\n              result = environment ? InitializeReferencedBinding(lhs, A) : PutValue(lhs, A);\n              break;\n            }\n            A[n] = value;\n            n++;\n          }\n        } else {\n          const A = new ArrayConstructor();\n          let n = 0;\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const {\n              done,\n              value\n            } = iteratorRecord.next();\n            if (done) {\n              result = yield* BindingInitialization(node.argument, A, environment);\n              break;\n            }\n            A[n] = value;\n            n++;\n          }\n        }\n      } else {\n        // Normal element.\n        const bindingElement = node.type === \"AssignmentPattern\" ? node.left : node;\n        switch (bindingElement.type) {\n          case \"ObjectPattern\":\n          case \"ArrayPattern\":\n            {\n              let v;\n              const {\n                done,\n                value\n              } = iteratorRecord.next();\n              if (!done) {\n                v = value;\n              }\n              if (node.type === \"AssignmentPattern\" && v === undefined) {\n                const defaultValue = yield* Evaluate(node.right);\n                v = GetValue(defaultValue);\n              }\n              result = yield* BindingInitialization(bindingElement, v, environment);\n              break;\n            }\n          case \"Identifier\":\n            {\n              const bindingId = bindingElement.name;\n              const lhs = ResolveBinding(bindingId, environment);\n              let v;\n              const {\n                done,\n                value\n              } = iteratorRecord.next();\n              if (!done) {\n                v = value;\n              }\n              if (node.type === \"AssignmentPattern\" && v === undefined) {\n                if (IsAnonymousFunctionDefinition(node.right)) {\n                  v = NamedEvaluation(node.right, bindingId);\n                } else {\n                  const defaultValue = yield* Evaluate(node.right);\n                  v = GetValue(defaultValue);\n                }\n              }\n              result = environment ? InitializeReferencedBinding(lhs, v) : PutValue(lhs, v);\n              break;\n            }\n        }\n      }\n    }\n    return result;\n  }\n\n  // https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization\n  function* KeyedBindingInitialization(node, value, environment, propertyName) {\n    const isIdentifier = node.type === \"Identifier\" || node.type === \"AssignmentPattern\" && node.left.type === \"Identifier\";\n    if (isIdentifier) {\n      const bindingId = node.type === \"Identifier\" ? node.name : node.left.name;\n      const lhs = ResolveBinding(bindingId, environment);\n      let v = GetV(value, propertyName);\n      if (node.type === \"AssignmentPattern\" && v === undefined) {\n        if (IsAnonymousFunctionDefinition(node.right)) {\n          v = NamedEvaluation(node.right, bindingId);\n        } else {\n          const defaultValue = yield* Evaluate(node.right);\n          v = GetValue(defaultValue);\n        }\n      }\n      if (!environment) {\n        return PutValue(lhs, v);\n      }\n      return InitializeReferencedBinding(lhs, v);\n    }\n    let v = GetV(value, propertyName);\n    if (node.type === \"AssignmentPattern\" && v === undefined) {\n      const defaultValue = yield* Evaluate(node.right);\n      v = GetValue(defaultValue);\n    }\n    return yield* BindingInitialization(node.type === \"AssignmentPattern\" ? node.left : node, v, environment);\n  }\n\n  // https://tc39.es/ecma262/#sec-initializeboundname\n  function InitializeBoundName(name, value, environment) {\n    // Assert: environment is always present.\n    environment.InitializeBinding(name, value);\n    return NormalCompletion(Empty);\n  }\n  function ThrowIfFunctionIsInvalid(func) {\n    if (func.async || func.generator) {\n      throw new SyntaxError(`${func.async ? \"Async\" : \"Generator\"} function is not allowed`);\n    }\n    if (expressionOnly && !func.expression) {\n      throw new SyntaxError(\"Only an `Expression` is allowed in `ArrowFunctionExpression`'s body\");\n    }\n  }\n  if (expressionOnly) {\n    return GetValue(unwind(Evaluate(rootAst)));\n  }\n  (_hooks$beforeEvaluate4 = hooks.beforeEvaluate) === null || _hooks$beforeEvaluate4 === void 0 || _hooks$beforeEvaluate4.call(hooks, rootAst);\n  ThrowIfFunctionIsInvalid(rootAst);\n  const [fn] = collectBoundNames(rootAst);\n  // Create an immutable binding for the root function.\n  rootEnv.CreateImmutableBinding(fn, true);\n  const fo = InstantiateFunctionObject(rootAst, rootEnv);\n  rootEnv.InitializeBinding(fn, fo);\n  if (debug) {\n    Object.defineProperties(fo, {\n      [DebuggerScope]: {\n        value: function () {\n          return getRunningContext().LexicalEnvironment;\n        }\n      },\n      [DebuggerNode]: {\n        value: function () {\n          return currentNode;\n        }\n      }\n    });\n  }\n  return fo;\n}\nfunction unwind(iterator) {\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const {\n      done,\n      value\n    } = iterator.next();\n    if (done) {\n      return value;\n    }\n  }\n}\n//# sourceMappingURL=cook.js.map","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n// https://tc39.es/ecma262/#sec-execution-contexts\nexport class AnalysisContext {\n  constructor() {\n    _defineProperty(this, \"VariableEnvironment\", void 0);\n    _defineProperty(this, \"LexicalEnvironment\", void 0);\n  }\n}\n\n// https://tc39.es/ecma262/#sec-environment-records\nexport class AnalysisEnvironment {\n  constructor(outer) {\n    _defineProperty(this, \"OuterEnv\", void 0);\n    _defineProperty(this, \"bindingSet\", new Set());\n    this.OuterEnv = outer;\n  }\n  HasBinding(name) {\n    return this.bindingSet.has(name);\n  }\n  CreateBinding(name) {\n    this.bindingSet.add(name);\n  }\n}\n//# sourceMappingURL=AnalysisContext.js.map","import { hasOwnProperty } from \"./hasOwnProperty.js\";\nimport { AnalysisContext, AnalysisEnvironment } from \"./AnalysisContext.js\";\nimport { collectBoundNames, collectScopedDeclarations, containsExpression } from \"./traverse.js\";\n/**\n * Analysis an AST of a storyboard function or an evaluation expression.\n *\n * @param rootAst - The root AST.\n * @param options - Analysis options.\n * @returns A set of global variables the root AST attempts to access.\n */\nexport function precook(rootAst) {\n  let {\n    expressionOnly,\n    visitors,\n    withParent,\n    externalSourceForDebug,\n    hooks = {}\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const attemptToVisitGlobals = new Set();\n  const analysisContextStack = [];\n  const rootEnv = new AnalysisEnvironment(null);\n  const rootContext = new AnalysisContext();\n  rootContext.VariableEnvironment = rootEnv;\n  rootContext.LexicalEnvironment = rootEnv;\n  analysisContextStack.push(rootContext);\n  function getRunningContext() {\n    return analysisContextStack[analysisContextStack.length - 1];\n  }\n  function visit(node) {\n    if (visitors && hasOwnProperty(visitors, node.type)) {\n      visitors[node.type](node);\n    }\n  }\n  function EvaluateChildren(node, keys, parent) {\n    for (const key of keys) {\n      Evaluate(node[key], parent === null || parent === void 0 ? void 0 : parent.concat({\n        node,\n        key\n      }));\n    }\n  }\n  function Evaluate(node, parent) {\n    if (Array.isArray(node)) {\n      node.forEach((n, index) => {\n        Evaluate(n, parent ? parent.slice(0, -1).concat({\n          ...parent[parent.length - 1],\n          index\n        }) : parent);\n      });\n    } else if (node) {\n      var _hooks$beforeVisit, _hooks$beforeVisitUnk;\n      // `node` maybe `null` in some cases.\n      (_hooks$beforeVisit = hooks.beforeVisit) === null || _hooks$beforeVisit === void 0 || _hooks$beforeVisit.call(hooks, node, parent);\n      visit(node);\n      // Expressions:\n      switch (node.type) {\n        case \"Identifier\":\n          if (!ResolveBinding(node.name)) {\n            var _hooks$beforeVisitGlo;\n            (_hooks$beforeVisitGlo = hooks.beforeVisitGlobal) === null || _hooks$beforeVisitGlo === void 0 || _hooks$beforeVisitGlo.call(hooks, node, parent);\n            attemptToVisitGlobals.add(node.name);\n          }\n          return;\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          EvaluateChildren(node, [\"elements\"], parent);\n          return;\n        case \"ArrowFunctionExpression\":\n          {\n            const env = getRunningContext().LexicalEnvironment;\n            const closure = OrdinaryFunctionCreate(node, env, true);\n            CallFunction(closure, parent);\n            return;\n          }\n        case \"AssignmentPattern\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          EvaluateChildren(node, [\"left\", \"right\"], parent);\n          return;\n        case \"CallExpression\":\n        case \"NewExpression\":\n          EvaluateChildren(node, [\"callee\", \"arguments\"], parent);\n          return;\n        case \"ChainExpression\":\n          EvaluateChildren(node, [\"expression\"], parent);\n          return;\n        case \"ConditionalExpression\":\n          EvaluateChildren(node, [\"test\", \"consequent\", \"alternate\"], parent);\n          return;\n        case \"MemberExpression\":\n          EvaluateChildren(node, [\"object\"], parent);\n          if (node.computed) {\n            EvaluateChildren(node, [\"property\"], parent);\n          }\n          return;\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          EvaluateChildren(node, [\"properties\"], parent);\n          return;\n        case \"Property\":\n          if (node.computed) {\n            EvaluateChildren(node, [\"key\"], parent);\n          }\n          EvaluateChildren(node, [\"value\"], parent);\n          return;\n        case \"RestElement\":\n        case \"SpreadElement\":\n        case \"UnaryExpression\":\n          EvaluateChildren(node, [\"argument\"], parent);\n          return;\n        case \"SequenceExpression\":\n        case \"TemplateLiteral\":\n          EvaluateChildren(node, [\"expressions\"], parent);\n          return;\n        case \"TaggedTemplateExpression\":\n          EvaluateChildren(node, [\"tag\", \"quasi\"], parent);\n          return;\n        case \"Literal\":\n          return;\n      }\n      if (!expressionOnly) {\n        // Statements and assignments:\n        switch (node.type) {\n          case \"AssignmentExpression\":\n            EvaluateChildren(node, [\"right\", \"left\"], parent);\n            return;\n          case \"BlockStatement\":\n            {\n              if (!node.body.length) {\n                return;\n              }\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const blockEnv = new AnalysisEnvironment(oldEnv);\n              BlockDeclarationInstantiation(node.body, blockEnv);\n              runningContext.LexicalEnvironment = blockEnv;\n              EvaluateChildren(node, [\"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"BreakStatement\":\n          case \"ContinueStatement\":\n          case \"EmptyStatement\":\n            return;\n          case \"CatchClause\":\n            {\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const catchEnv = new AnalysisEnvironment(oldEnv);\n              BoundNamesInstantiation(node.param, catchEnv);\n              runningContext.LexicalEnvironment = catchEnv;\n              EvaluateChildren(node, [\"param\", \"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"DoWhileStatement\":\n            EvaluateChildren(node, [\"body\", \"test\"], parent);\n            return;\n          case \"ExpressionStatement\":\n          case \"TSAsExpression\":\n            EvaluateChildren(node, [\"expression\"], parent);\n            return;\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            {\n              // ForIn/OfHeadEvaluation\n              const lexicalBinding = node.left.type === \"VariableDeclaration\" && node.left.kind !== \"var\";\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              if (lexicalBinding) {\n                const newEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.left, newEnv);\n                runningContext.LexicalEnvironment = newEnv;\n              }\n              EvaluateChildren(node, [\"right\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n\n              // ForIn/OfBodyEvaluation\n              if (lexicalBinding) {\n                const iterationEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.left, iterationEnv);\n                runningContext.LexicalEnvironment = iterationEnv;\n              }\n              EvaluateChildren(node, [\"left\", \"body\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"ForStatement\":\n            {\n              var _node$init;\n              const lexicalBinding = ((_node$init = node.init) === null || _node$init === void 0 ? void 0 : _node$init.type) === \"VariableDeclaration\" && node.init.kind !== \"var\";\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              if (lexicalBinding) {\n                const loopEnv = new AnalysisEnvironment(oldEnv);\n                BoundNamesInstantiation(node.init, loopEnv);\n                runningContext.LexicalEnvironment = loopEnv;\n              }\n              EvaluateChildren(node, [\"init\", \"test\", \"body\", \"update\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"FunctionDeclaration\":\n            {\n              const [fn] = collectBoundNames(node);\n              const env = getRunningContext().LexicalEnvironment;\n              const fo = OrdinaryFunctionCreate(node, env);\n              env.CreateBinding(fn);\n              CallFunction(fo, parent);\n              return;\n            }\n          case \"FunctionExpression\":\n            {\n              const closure = InstantiateOrdinaryFunctionExpression(node);\n              CallFunction(closure, parent);\n              return;\n            }\n          case \"IfStatement\":\n            EvaluateChildren(node, [\"test\", \"consequent\", \"alternate\"], parent);\n            return;\n          case \"ReturnStatement\":\n          case \"ThrowStatement\":\n          case \"UpdateExpression\":\n            EvaluateChildren(node, [\"argument\"], parent);\n            return;\n          case \"SwitchCase\":\n            EvaluateChildren(node, [\"test\", \"consequent\"], parent);\n            return;\n          case \"SwitchStatement\":\n            {\n              EvaluateChildren(node, [\"discriminant\"], parent);\n              const runningContext = getRunningContext();\n              const oldEnv = runningContext.LexicalEnvironment;\n              const blockEnv = new AnalysisEnvironment(oldEnv);\n              BlockDeclarationInstantiation(node.cases, blockEnv);\n              runningContext.LexicalEnvironment = blockEnv;\n              EvaluateChildren(node, [\"cases\"], parent);\n              runningContext.LexicalEnvironment = oldEnv;\n              return;\n            }\n          case \"ThisExpression\":\n            {\n              if (!externalSourceForDebug) {\n                break;\n              }\n              return;\n            }\n          case \"TryStatement\":\n            EvaluateChildren(node, [\"block\", \"handler\", \"finalizer\"], parent);\n            return;\n          case \"VariableDeclaration\":\n            EvaluateChildren(node, [\"declarations\"], parent);\n            return;\n          case \"VariableDeclarator\":\n            EvaluateChildren(node, [\"id\", \"init\"], parent);\n            return;\n          case \"WhileStatement\":\n            EvaluateChildren(node, [\"test\", \"body\"], parent);\n            return;\n        }\n      }\n      const silent = (_hooks$beforeVisitUnk = hooks.beforeVisitUnknown) === null || _hooks$beforeVisitUnk === void 0 ? void 0 : _hooks$beforeVisitUnk.call(hooks, node, parent);\n      if (!silent) {\n        // eslint-disable-next-line no-console\n        console.warn(`Unsupported node type \\`${node.type}\\``);\n      }\n    }\n  }\n  function BoundNamesInstantiation(declarations, env) {\n    for (const name of collectBoundNames(declarations)) {\n      env.CreateBinding(name);\n    }\n  }\n  function ResolveBinding(name) {\n    const env = getRunningContext().LexicalEnvironment;\n    return GetIdentifierReference(env, name);\n  }\n  function GetIdentifierReference(env, name) {\n    return !!env && (env.HasBinding(name) || GetIdentifierReference(env.OuterEnv, name));\n  }\n  function BlockDeclarationInstantiation(code, env) {\n    const declarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: false\n    });\n    BoundNamesInstantiation(declarations, env);\n  }\n  function CallFunction(closure, parent) {\n    PrepareOrdinaryCall(closure);\n    FunctionDeclarationInstantiation(closure, parent);\n    Evaluate(closure.ECMAScriptCode, parent === null || parent === void 0 ? void 0 : parent.concat({\n      node: closure.Function,\n      key: \"body\"\n    }).concat(closure.Function.body.type === \"BlockStatement\" ? {\n      node: closure.Function.body,\n      key: \"body\"\n    } : []));\n    analysisContextStack.pop();\n  }\n  function PrepareOrdinaryCall(F) {\n    const calleeContext = new AnalysisContext();\n    const localEnv = new AnalysisEnvironment(F.Environment);\n    calleeContext.VariableEnvironment = localEnv;\n    calleeContext.LexicalEnvironment = localEnv;\n    analysisContextStack.push(calleeContext);\n  }\n  function FunctionDeclarationInstantiation(func, parent) {\n    const calleeContext = getRunningContext();\n    const code = func.ECMAScriptCode;\n    const formals = func.FormalParameters;\n    const hasParameterExpressions = containsExpression(formals);\n    const varDeclarations = collectScopedDeclarations(code, {\n      var: true,\n      topLevel: true\n    });\n    const varNames = collectBoundNames(varDeclarations);\n    const argumentsObjectNeeded = !!externalSourceForDebug && func.ThisMode !== \"LEXICAL\";\n    const env = calleeContext.LexicalEnvironment;\n    BoundNamesInstantiation(formals, env);\n    if (argumentsObjectNeeded) {\n      env.CreateBinding(\"arguments\");\n    }\n    Evaluate(formals, parent === null || parent === void 0 ? void 0 : parent.concat({\n      node: func.Function,\n      key: \"params\"\n    }));\n    let varEnv;\n    if (!hasParameterExpressions) {\n      // NOTE: Only a single Environment Record is needed for the parameters\n      // and top-level vars.\n      for (const n of varNames) {\n        env.CreateBinding(n);\n      }\n      varEnv = env;\n    } else {\n      // NOTE: A separate Environment Record is needed to ensure that closures\n      // created by expressions in the formal parameter list do not have\n      // visibility of declarations in the function body.\n      varEnv = new AnalysisEnvironment(env);\n      calleeContext.VariableEnvironment = varEnv;\n      for (const n of varNames) {\n        varEnv.CreateBinding(n);\n      }\n    }\n    const lexEnv = varEnv;\n    calleeContext.LexicalEnvironment = lexEnv;\n    const lexDeclarations = collectScopedDeclarations(code, {\n      var: false,\n      topLevel: true\n    });\n    BoundNamesInstantiation(lexDeclarations, lexEnv);\n  }\n  function InstantiateOrdinaryFunctionExpression(functionExpression) {\n    const scope = getRunningContext().LexicalEnvironment;\n    if (!functionExpression.id) {\n      return OrdinaryFunctionCreate(functionExpression, scope);\n    }\n    const name = functionExpression.id.name;\n    const funcEnv = new AnalysisEnvironment(scope);\n    funcEnv.CreateBinding(name);\n    return OrdinaryFunctionCreate(functionExpression, funcEnv);\n  }\n  function OrdinaryFunctionCreate(func, scope, lexicalThis) {\n    return {\n      Function: func,\n      FormalParameters: func.params,\n      ECMAScriptCode: func.body.type === \"BlockStatement\" ? func.body.body : func.body,\n      Environment: scope,\n      ThisMode: lexicalThis ? \"LEXICAL\" : \"STRICT\"\n    };\n  }\n  Evaluate(rootAst, withParent ? [] : undefined);\n  return attemptToVisitGlobals;\n}\n//# sourceMappingURL=precook.js.map","export function hasOwnProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n//# sourceMappingURL=hasOwnProperty.js.map","import { parseAsEstree } from \"./parse.js\";\nimport { precook } from \"./precook.js\";\nlet ASTCache = new WeakMap();\nexport function precookFunction(source) {\n  let {\n    typescript,\n    cacheKey,\n    ...restOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let func = cacheKey ? ASTCache.get(cacheKey) : undefined;\n  if (!func) {\n    func = parseAsEstree(source, {\n      typescript\n    });\n    if (cacheKey) {\n      ASTCache.set(cacheKey, func);\n    }\n  }\n  const attemptToVisitGlobals = precook(func, restOptions);\n  return {\n    function: func,\n    attemptToVisitGlobals\n  };\n}\nexport function clearFunctionASTCache() {\n  ASTCache = new WeakMap();\n}\n//# sourceMappingURL=precookFunction.js.map","import { parse, parseExpression } from \"@babel/parser\";\nexport function parseAsEstreeExpression(source) {\n  return parseExpression(source, {\n    plugins: [\"estree\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }]],\n    attachComment: false\n  });\n}\nexport function parseAsEstree(source) {\n  let {\n    typescript\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const file = parse(source, {\n    plugins: [\"estree\", typescript && \"typescript\"].filter(Boolean),\n    strictMode: true,\n    attachComment: false\n  });\n  const body = file.program.body;\n  const jsNodes = typescript ? [] : body;\n  if (typescript) {\n    for (const node of body) {\n      if (node.type.startsWith(\"TS\")) {\n        if (/Enum|Import|Export/.test(node.type)) {\n          throw new SyntaxError(`Unsupported TypeScript syntax: ${node.type}`);\n        }\n      } else {\n        jsNodes.push(node);\n      }\n    }\n  }\n  if (jsNodes.length === 0) {\n    throw new SyntaxError(\"Function declaration not found\");\n  }\n  if (jsNodes.length > 1 || jsNodes[0].type !== \"FunctionDeclaration\") {\n    throw new SyntaxError(`Expect a single function declaration at top level, but received: ${jsNodes.map(node => `\"${node.type}\"`).join(\", \")}`);\n  }\n  return jsNodes[0];\n}\n//# sourceMappingURL=parse.js.map","import { parseAsEstreeExpression } from \"./parse.js\";\nimport { precook } from \"./precook.js\";\nconst ASTCache = new Map();\n// `raw` should always be asserted by `isEvaluable`.\nexport function preevaluate(raw) {\n  let {\n    cache,\n    ...restOptions\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const fixes = [];\n  const source = raw.replace(/^\\s*<%[~=]?\\s|\\s%>\\s*$/g, m => {\n    fixes.push(m);\n    return \"\";\n  });\n  let expression = cache ? ASTCache.get(source) : undefined;\n  if (!expression) {\n    expression = parseAsEstreeExpression(source);\n    if (cache) {\n      ASTCache.set(source, expression);\n    }\n  }\n  const attemptToVisitGlobals = precook(expression, {\n    ...restOptions,\n    expressionOnly: true\n  });\n  return {\n    expression,\n    attemptToVisitGlobals,\n    source,\n    prefix: fixes[0],\n    suffix: fixes[1]\n  };\n}\nexport function isEvaluable(raw) {\n  return /^\\s*<%[~=]?\\s/.test(raw) && /\\s%>\\s*$/.test(raw);\n}\nexport function shouldAllowRecursiveEvaluations(raw) {\n  return /^\\s*<%~\\s/.test(raw);\n}\nexport function isTrackAll(raw) {\n  return /^\\s*<%=\\s/.test(raw) && /\\s%>\\s*$/.test(raw);\n}\nexport function clearExpressionASTCache() {\n  ASTCache.clear();\n}\n//# sourceMappingURL=preevaluate.js.map"],"names":["Mode","SourceNode","Symbol","for","FormalParameters","ECMAScriptCode","Environment","IsConstructor","ThisMode","DebuggerCall","DebuggerScope","DebuggerNode","DebuggerReturn","ExecutionContext","constructor","this","BindingStatus","EnvironmentRecord","outer","Map","undefined","OuterEnv","HasBinding","name","bindingMap","has","CreateMutableBinding","deletable","set","mutable","NormalCompletion","CreateImmutableBinding","strict","InitializeBinding","value","binding","get","Object","assign","initialized","SetMutableBinding","_strict","ReferenceError","TypeError","GetBindingValue","HasThisBinding","DeclarativeEnvironment","FunctionEnvironment","F","super","LEXICAL","ThisBindingStatus","UNINITIALIZED","BindThisValue","INITIALIZED","Error","ThisValue","GetThisBinding","ReferenceRecord","base","referenceName","Base","ReferenceName","Strict","CompletionRecord","type","Type","Value","Empty","collectBoundNames","root","names","Set","collect","node","Array","isArray","n","add","declarations","id","elements","left","properties","argument","from","containsExpression","some","computed","collectScopedDeclarations","options","nextOptions","var","Number","topLevel","push","kind","consequent","body","alternate","init","cases","block","handler","finalizer","IsPropertyReference","V","InitializeReferencedBinding","W","CopyDataProperties","target","source","excludedItems","keys","getOwnPropertyNames","concat","getOwnPropertySymbols","nextKey","desc","getOwnPropertyDescriptor","enumerable","ForDeclarationBindingInstantiation","forDeclaration","env","isConst","LoopContinues","completion","UpdateEmpty","GetValue","ToPropertyKey","arg","String","GetV","P","PutValue","CreateListIteratorRecord","args","cooked","iterator","RequireObjectCoercible","GetIdentifierReference","ApplyStringOrNumericBinaryOperator","leftValue","operator","rightValue","SyntaxError","reservedObjects","WeakSet","Function","prototype","self","window","global","getGlobal","allowedConstructors","URL","URLSearchParams","WeakMap","RegExp","globalExecutionContextStack","__dev_only_clearGlobalExecutionContextStack","length","__dev_only_getGlobalExecutionContextStack","cook","rootAst","codeSource","_hooks$beforeEvaluate4","rules","debug","externalSourceForDebug","globalVariables","ArrayConstructor","hooks","arguments","expressionOnly","doSanitize","sanitize","rootEnv","rootContext","VariableEnvironment","LexicalEnvironment","executionContextStack","key","entries","TemplateMap","currentNode","Evaluate","optionalChainRef","forceYield","_hooks$beforeEvaluate","_hooks$beforeBranch2","beforeEvaluate","call","endsWith","expression","array","element","spreadValues","ThrowIfFunctionIsInvalid","InstantiateArrowFunctionExpression","rightRef","right","funcName","substring","start","end","thisValue","ref","callee","func","optional","skipped","EvaluateCall","test","ResolveBinding","regex","raw","flags","includes","pattern","baseValue","object","result","propertyKey","EvaluatePropertyAccessWithExpressionKey","property","identifier","propertyNameString","EvaluatePropertyAccessWithIdentifierKey","constructExpr","argList","ArgumentListEvaluation","constructorName","Date","isAllowedConstructor","EvaluateNew","prop","propName","EvaluateComputedPropertyName","propValue","method","SetFunctionName","expr","expressions","chunks","quasis","index","val","join","tagRef","tag","tagFunc","quasi","ApplyUnaryOperator","lref","rval","IsAnonymousFunctionDefinition","NamedEvaluation","DestructuringAssignmentEvaluation","lval","r","substr","ApplyStringOrNumericAssignment","oldEnv","getRunningContext","blockEnv","BlockDeclarationInstantiation","blockValue","EvaluateStatementList","EvaluateBreakableStatement","stmtResult","DoWhileLoopEvaluation","lhs","lhsKind","uninitializedBoundNames","iterationKind","keyResult","runningContext","newEnv","exprRef","exprValue","EnumerateObjectProperties","ForInOfHeadEvaluation","stmt","iteratorRecord","destructuring","done","nextValue","next","lhsRef","iterationEnv","lhsName","BindingInitialization","status","return","innerResult","ForInOfBodyEvaluation","ForInOfLoopEvaluation","_node$init","ForBodyEvaluation","update","loopEnv","boundNames","dn","perIterationLets","bodyResult","ForLoopEvaluation","InstantiateOrdinaryFunctionExpression","_hooks$beforeBranch","beforeBranch","v","GetThisEnvironment","oldValue","newValue","prefix","switchValue","discriminant","R","input","defaultCaseIndex","findIndex","switchCase","hasDefaultCase","A","slice","found","C","CaseClauseIsSelected","foundInB","B","CaseBlockEvaluation","error","_hooks$beforeEvaluate2","thrownValue","param","catchEnv","argName","CatchClauseEvaluation","declarator","bindingId","WhileLoopEvaluation","increment","perIterationBindings","CreatePerIterationEnvironment","lastIterationEnv","thisIterationEnv","bn","lastValue","excludedNames","valueTarget","KeyedDestructuringAssignmentEvaluation","RestDestructuringAssignmentEvaluation","PropertyDestructuringAssignmentEvaluation","assignmentTarget","isObjectOrArray","IteratorDestructuringAssignmentEvaluation","propertyName","rhsValue","restProperty","code","d","IsConstantDeclaration","fn","fo","InstantiateFunctionObject","debuggerCall","apply","templateLiteral","memo","rawObj","map","template","freeze","defineProperty","writable","configurable","GetTemplateObject","CallFunction","closure","thisArgument","_hooks$beforeCall","beforeCall","calleeContext","localEnv","OrdinaryCallBindThis","PrepareForOrdinaryCall","formals","parameterNames","hasParameterExpressions","varDeclarations","varNames","functionNames","functionsToInitialize","i","unshift","noVar","argumentsObjectNeeded","paramName","parameterBindings","ao","argumentObject","values","ThrowTypeError","CreateUnmappedArgumentsObject","varEnv","IteratorBindingInitialization","instantiatedVarNames","initialValue","lexEnv","lexDeclarations","f","FunctionDeclarationInstantiation","EvaluateFunctionBody","OrdinaryCallEvaluateBody","pop","statements","s","_hooks$beforeEvaluate3","scope","OrdinaryFunctionCreate","functionExpression","funcEnv","arrowFunction","sourceNode","isConstructor","lexicalThis","unwind","defineProperties","params","STRICT","len","count","ExpectedArgumentCount","environment","InitializeBoundName","RestBindingInitialization","KeyedBindingInitialization","PropertyBindingInitialization","restObj","bindingElement","async","generator","AnalysisContext","AnalysisEnvironment","bindingSet","CreateBinding","precook","visitors","withParent","attemptToVisitGlobals","analysisContextStack","EvaluateChildren","parent","forEach","_hooks$beforeVisit","_hooks$beforeVisitUnk","beforeVisit","hasOwnProperty","visit","_hooks$beforeVisitGlo","beforeVisitGlobal","BoundNamesInstantiation","lexicalBinding","beforeVisitUnknown","console","warn","PrepareOrdinaryCall","ASTCache","precookFunction","typescript","cacheKey","restOptions","parse","plugins","filter","Boolean","strictMode","attachComment","program","jsNodes","startsWith","parseAsEstree","function","clearFunctionASTCache","preevaluate","cache","fixes","replace","m","parseExpression","proposal","parseAsEstreeExpression","suffix","isEvaluable","shouldAllowRecursiveEvaluations","isTrackAll","clearExpressionASTCache","clear"],"sourceRoot":""}