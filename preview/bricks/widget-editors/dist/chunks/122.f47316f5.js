"use strict";(globalThis.webpackChunk_next_bricks_widget_editors=globalThis.webpackChunk_next_bricks_widget_editors||[]).push([[122],{4586:(e,t,n)=>{n.d(t,{A:()=>i});var r=n(1369);function i(e,t,n){return(t=(0,r.A)(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}},1369:(e,t,n)=>{n.d(t,{A:()=>i});var r=n(7545);function i(e){var t=function(e,t){if("object"!=(0,r.A)(e)||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var i=n.call(e,"string");if("object"!=(0,r.A)(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==(0,r.A)(t)?t:t+""}},7545:(e,t,n)=>{function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}n.d(t,{A:()=>r})},1122:(e,t,n)=>{n.r(t),n.d(t,{__dev_only_clearGlobalExecutionContextStack:()=>W,__dev_only_getGlobalExecutionContextStack:()=>q,clearExpressionASTCache:()=>ae,clearFunctionASTCache:()=>ee,cook:()=>G,isEvaluable:()=>re,isTrackAll:()=>oe,precook:()=>K,precookFunction:()=>Y,preevaluate:()=>ne,shouldAllowRecursiveEvaluations:()=>ie});var r=n(4586);let i=function(e){return e[e.LEXICAL=0]="LEXICAL",e[e.STRICT=1]="STRICT",e}({});const o=Symbol.for("SourceNode"),a=Symbol.for("FormalParameters"),s=Symbol.for("ECMAScriptCode"),c=Symbol.for("Environment"),l=Symbol.for("IsConstructor"),u=Symbol.for("ThisMode"),d=Symbol.for("$DebuggerCall$"),f=Symbol.for("$DebuggerScope$"),y=Symbol.for("$DebuggerNode$"),p=Symbol.for("$DebuggerReturn$");class m{constructor(){(0,r.A)(this,"VariableEnvironment",void 0),(0,r.A)(this,"LexicalEnvironment",void 0),(0,r.A)(this,"Function",void 0)}}let v=function(e){return e[e.UNINITIALIZED=0]="UNINITIALIZED",e[e.LEXICAL=1]="LEXICAL",e[e.INITIALIZED=2]="INITIALIZED",e}({});class g{constructor(e){(0,r.A)(this,"OuterEnv",void 0),(0,r.A)(this,"bindingMap",new Map),(0,r.A)(this,"ThisValue",void 0),(0,r.A)(this,"ThisBindingStatus",void 0),this.OuterEnv=e}HasBinding(e){return this.bindingMap.has(e)}CreateMutableBinding(e,t){return this.bindingMap.set(e,{mutable:!0,deletable:t}),x(void 0)}CreateImmutableBinding(e,t){return this.bindingMap.set(e,{strict:t}),x(void 0)}InitializeBinding(e,t){const n=this.bindingMap.get(e);return Object.assign(n,{initialized:!0,value:t}),x(void 0)}SetMutableBinding(e,t,n){const r=this.bindingMap.get(e);if(!r.initialized)throw new ReferenceError(`${e} is not initialized`);if(!r.mutable)throw new TypeError("Assignment to constant variable");return r.value=t,x(void 0)}GetBindingValue(e,t){const n=this.bindingMap.get(e);if(!n.initialized)throw new ReferenceError(`${e} is not initialized`);return n.value}HasThisBinding(){return!1}}class h extends g{}class b extends g{constructor(e){super(e[c]),e[u]===i.LEXICAL?this.ThisBindingStatus=v.LEXICAL:this.ThisBindingStatus=v.UNINITIALIZED}HasThisBinding(){return this.ThisBindingStatus!==v.LEXICAL}BindThisValue(e){if(this.ThisBindingStatus===v.INITIALIZED)throw new Error("This binding has been initialized");this.ThisValue=e,this.ThisBindingStatus=v.INITIALIZED}GetThisBinding(){if(this.ThisBindingStatus===v.UNINITIALIZED)throw new Error("This binding is not initialized");return this.ThisValue}}class E{constructor(e,t,n){(0,r.A)(this,"Base",void 0),(0,r.A)(this,"ReferenceName",void 0),(0,r.A)(this,"Strict",void 0),this.Base=e,this.ReferenceName=t,this.Strict=n}}class w{constructor(e,t){(0,r.A)(this,"Type",void 0),(0,r.A)(this,"Value",void 0),this.Type=e,this.Value=t}}function x(e){return new w("normal",e)}const S=Symbol("empty completion");function A(e){const t=new Set,n=e=>{if(Array.isArray(e))for(const t of e)n(t);else if(e)switch(e.type){case"Identifier":return void t.add(e.name);case"VariableDeclaration":return n(e.declarations);case"VariableDeclarator":case"FunctionDeclaration":return n(e.id);case"ArrayPattern":return n(e.elements);case"AssignmentPattern":return n(e.left);case"ObjectPattern":return n(e.properties);case"Property":return n(e.value);case"RestElement":return n(e.argument)}};return n(e),Array.from(t)}function L(e){const t=e=>{if(Array.isArray(e))return e.some(t);if(e)switch(e.type){case"ArrayPattern":return t(e.elements);case"AssignmentPattern":return!0;case"ObjectPattern":return t(e.properties);case"Property":return e.computed||t(e.value);case"RestElement":return t(e.argument)}};return t(e)}function B(e,t){const n=[],r={var:t.var},i=(e,t)=>{if(Array.isArray(e))for(const n of e)i(n,t);else if(e){switch(e.type){case"FunctionDeclaration":return void(Number(!t.var)^Number(t.topLevel)&&n.push(e));case"VariableDeclaration":return void(Number(!t.var)^Number("var"===e.kind)&&n.push(e));case"SwitchCase":return void i(e.consequent,r);case"CatchClause":return void i(e.body,r)}if(t.var)switch(e.type){case"BlockStatement":case"DoWhileStatement":case"WhileStatement":return void i(e.body,r);case"IfStatement":return i(e.consequent,r),void i(e.alternate,r);case"ForStatement":return i(e.init,r),void i(e.body,r);case"ForInStatement":case"ForOfStatement":return i(e.left,r),void i(e.body,r);case"SwitchStatement":return void i(e.cases,r);case"TryStatement":return i(e.block,r),i(e.handler,r),void i(e.finalizer,r)}}};return i(e,t),n}function I(e){return"unresolvable"!==e.Base&&!(e.Base instanceof g)}function T(e,t){return e.Base.InitializeBinding(e.ReferenceName,t)}function C(e,t,n){if(null==t)return e;const r=Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));for(const i of r)if(!n.has(i)){const n=Object.getOwnPropertyDescriptor(t,i);null!=n&&n.enumerable&&(e[i]=t[i])}return e}function k(e,t){const n="const"===e.kind;for(const r of A(e))n?t.CreateImmutableBinding(r,!0):t.CreateMutableBinding(r,!1)}function V(e){return"normal"===e.Type||"continue"==e.Type}function P(e,t){return e.Value!==S?e:new w(e.Type,t)}function O(e){if(e instanceof w&&(e=e.Value),!(e instanceof E))return e;if("unresolvable"===e.Base)throw new ReferenceError(`${e.ReferenceName} is not defined`);return e.Base instanceof g?e.Base.GetBindingValue(e.ReferenceName,e.Strict):e.Base[e.ReferenceName]}function F(e){return"symbol"==typeof e?e:String(e)}function j(e,t){return e[t]}function D(e,t){if("unresolvable"===e.Base)throw new ReferenceError(`${e.ReferenceName} is not defined`);return e.Base instanceof g?e.Base.SetMutableBinding(e.ReferenceName,t,e.Strict):(e.Base[e.ReferenceName]=t,x(void 0))}function M(e){if(t=e,!(Array.isArray(t)||null!=t&&"function"==typeof t[Symbol.iterator]))throw new TypeError(typeof e+" is not iterable");var t;return e[Symbol.iterator]()}function R(e){if(null==e)throw new TypeError("Cannot destructure properties of undefined or null")}function N(e,t,n){return e?e.HasBinding(t)?new E(e,t,n):N(e.OuterEnv,t,n):new E("unresolvable",t,n)}function $(e,t,n){switch(t){case"+":return e+n;case"-":return e-n;case"/":return e/n;case"%":return e%n;case"*":return e*n;case"**":return e**n;case"==":return e==n;case"===":return e===n;case"!=":return e!=n;case"!==":return e!==n;case">":return e>n;case"<":return e<n;case">=":return e>=n;case"<=":return e<=n;case"in":return e in n}throw new SyntaxError(`Unsupported binary operator \`${t}\``)}const z=new WeakSet([Function,Object,Function.prototype,Object.prototype,function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}()]),_=new WeakSet([Array,Map,Set,URL,URLSearchParams,WeakMap,WeakSet,RegExp]),U=[];function W(){U.length=0}function q(){return U}function G(e,t){var n;let{rules:r,debug:v,externalSourceForDebug:g,globalVariables:W={},ArrayConstructor:q=Array,hooks:G={}}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const Z="FunctionDeclaration"!==e.type;function H(e){g||function(e){if(z.has(e))throw new TypeError("Cannot access reserved objects such as `Function`.")}(e)}const K=new h(null),J=new m;J.VariableEnvironment=K,J.LexicalEnvironment=K;const Q=[J];for(const[e,t]of Object.entries(W))K.CreateImmutableBinding(e,!0),K.InitializeBinding(e,t);const Y=new WeakMap;let ee;function*te(e,n,r){var i,o;switch(null===(i=G.beforeEvaluate)||void 0===i||i.call(G,e),ee=e,v&&(r||e.type.endsWith("Statement")&&("ExpressionStatement"!==e.type||"CallExpression"!==e.expression.type&&"TaggedTemplateExpression"!==e.expression.type)&&"TryStatement"!==e.type&&"BlockStatement"!==e.type&&"DoWhileStatement"!==e.type&&"WhileStatement"!==e.type&&"ForStatement"!==e.type&&"ForInStatement"!==e.type&&"ForOfStatement"!==e.type)&&(yield),e.type){case"ArrayExpression":{const t=new q;for(const n of e.elements)if(n)if("SpreadElement"===n.type){const e=O(yield*te(n.argument));t.push(...e)}else t.push(O(yield*te(n)));else t.length+=1;return x(t)}case"ArrowFunctionExpression":return Te(e),x(Ee(e));case"BinaryExpression":{const n=O(yield*te(e.left)),r=yield*te(e.right),i=O(r);if(Z&&"|>"===e.operator){if("function"!=typeof i){const n=t.substring(e.right.start,e.right.end);throw new TypeError(`${n} is not a function`)}let o;return r instanceof E&&I(r)&&(o=r.Base),x(i.call(o,n))}return x($(n,e.operator,i))}case"CallExpression":{const t=(yield*te(e.callee,n)).Value,r=O(t);return null==r&&(e.optional||null!=n&&n.skipped)?(n.skipped=!0,x(void 0)):(H(r),v&&(yield),yield*fe(r,t,e.arguments,e.callee))}case"ChainExpression":return yield*te(e.expression,{});case"ConditionalExpression":return x(O(yield*te(O(yield*te(e.test))?e.consequent:e.alternate)));case"Identifier":return x(re(e.name));case"Literal":if(e.regex){if(null===e.value)throw new SyntaxError(`Invalid regular expression: ${e.raw}`);if(e.regex.flags.includes("u"))throw new SyntaxError(`Unsupported unicode flag in regular expression: ${e.raw}`);return x(new RegExp(e.regex.pattern,e.regex.flags))}return x(e.value);case"LogicalExpression":{const t=O(yield*te(e.left));switch(e.operator){case"&&":return x(t&&O(yield*te(e.right)));case"||":return x(t||O(yield*te(e.right)));case"??":return x(t??O(yield*te(e.right)));default:throw new SyntaxError(`Unsupported logical operator '${e.operator}'`)}}case"MemberExpression":{const t=O((yield*te(e.object,n)).Value);if(null==t&&(e.optional||null!=n&&n.skipped))return n.skipped=!0,x(void 0);H(t);const r=e.computed?yield*function*(e,t,n){const r=F(O(yield*te(t)));return new E(e,r,!0)}(t,e.property):function(e,t,n){ee=t;const r=t.name;return new E(e,r,!0)}(t,e.property);return H(r),x(r)}case"NewExpression":return yield*function*(e,n){const r=O(yield*te(e)),i=yield*ye(n);if("function"!=typeof r||!1===r[l]){const n=t.substring(e.start,e.end);throw new TypeError(`${n} is not a constructor`)}if(!g&&!function(e){return _.has(e)||e===Date}(r)&&r!==q){const n=t.substring(e.start,e.end);throw new TypeError(`${n} is not an allowed constructor`)}return x(new r(...i))}(e.callee,e.arguments);case"ObjectExpression":{const t={};for(const n of e.properties)if("SpreadElement"===n.type)C(t,O(yield*te(n.argument)),new Set);else{if("init"!==n.kind)throw new SyntaxError("Unsupported object getter/setter");const e=n.computed||"Identifier"!==n.key.type?yield*Ae(n.key):n.key.name;if("__proto__"===e)throw new TypeError("Setting '__proto__' property is not allowed");const r=O(yield*te(n.value));n.method&&"function"==typeof r&&we(r,e),t[e]=r}return x(t)}case"SequenceExpression":{let t;for(const n of e.expressions)t=x(O(yield*te(n)));return t}case"TemplateLiteral":{const t=[e.quasis[0].value.cooked];let n=0;for(const r of e.expressions){const i=O(yield*te(r));t.push(String(i)),t.push(e.quasis[n+=1].value.cooked)}return x(t.join(""))}case"TaggedTemplateExpression":{const t=(yield*te(e.tag)).Value,n=O(t);return H(n),v&&(yield),yield*fe(n,t,e.quasi,e.tag)}case"UnaryExpression":{const t=(yield*te(e.argument)).Value;if(!Z&&"delete"===e.operator){if(!(t instanceof E))return x(!0);if(I(t))return x(delete t.Base[t.ReferenceName])}return"typeof"===e.operator?t instanceof E&&"unresolvable"===t.Base?x("undefined"):x(typeof O(t)):x(function(e,t){switch(t){case"!":return!e;case"+":return+e;case"-":return-e;case"void":return}throw new SyntaxError(`Unsupported unary operator \`${t}\``)}(O(t),e.operator))}}if(!Z)switch(e.type){case"AssignmentExpression":{if("="===e.operator){if("ArrayPattern"!==e.left.type&&"ObjectPattern"!==e.left.type){const t=(yield*te(e.left)).Value;let n;return n=ve(e.right)&&"Identifier"===e.left.type?ge(e.right,e.left.name):O(yield*te(e.right)),D(t,n),x(n)}const t=O(yield*te(e.right));return yield*ce(e.left,t),x(t)}const t=(yield*te(e.left)).Value,n=O(t),r=O(yield*te(e.right)),i=function(e,t,n){switch(t){case"+=":case"-=":case"*=":case"/=":case"%=":case"**=":return $(e,t.substr(0,t.length-1),n)}throw new SyntaxError(`Unsupported assignment operator \`${t}\``)}(n,e.operator,r);return D(t,i),x(i)}case"BlockStatement":{if(!e.body.length)return x(S);const t=ne().LexicalEnvironment,n=new h(t);de(e.body,n),ne().LexicalEnvironment=n;const r=yield*me(e.body);return ne().LexicalEnvironment=t,r}case"BreakStatement":return new w("break",S);case"ContinueStatement":return new w("continue",S);case"EmptyStatement":case"FunctionDeclaration":return x(S);case"DoWhileStatement":return ie(yield*function*(e){let t;for(;;){const n=yield*te(e.body);if(!V(n))return P(n,t);if(n.Value!==S&&(t=n.Value),!O(yield*te(e.test,void 0,!0)))return x(t)}}(e));case"ExpressionStatement":case"TSAsExpression":return yield*te(e.expression);case"ForInStatement":case"ForOfStatement":return ie(yield*function*(e){const t=e.left,n="VariableDeclaration"===t.type?"var"===t.kind?"varBinding":"lexicalBinding":"assignment",r="lexicalBinding"===n?A(t):[],i="ForInStatement"===e.type?"enumerate":"iterate",o=yield*function*(e,t,n){const r=ne(),i=r.LexicalEnvironment;if(e.length>0){const t=new h(i);for(const n of e)t.CreateMutableBinding(n,!1);r.LexicalEnvironment=t}const o=yield*te(t,void 0,!0);r.LexicalEnvironment=i;const a=O(o);return"enumerate"===n?null==a?new w("break",S):x(function*(e){for(const t in e)yield t}(a)):x(M(a))}(r,e.right,i);return"normal"!==o.Type?o:yield*function*(e,t,n,r,i){const o="assignment"===i?e:e.declarations[0].id,a=ne().LexicalEnvironment;let s;const c="ObjectPattern"===o.type||"ArrayPattern"===o.type;for(;;){ee=o;const{done:l,value:u}=n.next();if(l)return v&&(yield),x(s);let d,f;if("lexicalBinding"===i){if(f=new h(a),k(e,f),ne().LexicalEnvironment=f,v&&(yield),!c){const[e]=A(o);d=re(e)}}else v&&(yield),c||(d=(yield*te(o)).Value);c?"assignment"===i?yield*ce(o,u):"varBinding"===i?yield*Se(o,u,void 0):yield*Se(o,u,f):"lexicalBinding"===i?T(d,u):D(d,u);const y=yield*te(t);if(ne().LexicalEnvironment=a,!V(y)){const e=P(y,s);if("enumerate"!==r&&void 0!==n.return){const e=n.return();if(!e||!["object","function"].includes(typeof e))throw new TypeError("Iterator result is not an object")}return e}y.Value!==S&&(s=y.Value)}}(t,e.body,o.Value,i,n)}(e));case"ForStatement":return ie(yield*function*(e){var t;if("VariableDeclaration"===(null===(t=e.init)||void 0===t?void 0:t.type)){if("var"===e.init.kind)return yield*te(e.init),yield*ae(e.test,e.update,e.body,[]);const t=ne().LexicalEnvironment,n=new h(t),r="const"===e.init.kind,i=A(e.init);for(const e of i)r?n.CreateImmutableBinding(e,!0):n.CreateMutableBinding(e,!1);ne().LexicalEnvironment=n,yield*te(e.init);const o=r?[]:Array.from(i),a=yield*ae(e.test,e.update,e.body,o);return ne().LexicalEnvironment=t,a}return e.init&&O(yield*te(e.init)),yield*ae(e.test,e.update,e.body,[])}(e));case"FunctionExpression":return Te(e),x(be(e));case"IfStatement":var a;return O(yield*te(e.test))?(null===(a=G.beforeBranch)||void 0===a||a.call(G,e,"if"),P(yield*te(e.consequent),void 0)):(null===(o=G.beforeBranch)||void 0===o||o.call(G,e,"else"),e.alternate?P(yield*te(e.alternate),void 0):x(void 0));case"ReturnStatement":{let t;return e.argument&&(t=O(yield*te(e.argument))),new w("return",t)}case"ThisExpression":if(!g)break;return x(function(){let e=ne().LexicalEnvironment;for(;e;){if(e.HasThisBinding())return e;e=e.OuterEnv}throw new Error("Accessing global this is forbidden")}().GetThisBinding());case"ThrowStatement":throw O(yield*te(e.argument));case"UpdateExpression":{const t=(yield*te(e.argument)).Value,n=Number(O(t)),r="++"===e.operator?n+1:n-1;return D(t,r),x(e.prefix?r:n)}case"SwitchCase":return yield*me(e.consequent);case"SwitchStatement":{const t=O(yield*te(e.discriminant)),n=ne().LexicalEnvironment,r=new h(n);de(e.cases,r),ne().LexicalEnvironment=r;const i=yield*function*(e,t){let n;const r=e.findIndex((e=>!e.test)),i=r>=0,o=i?e.slice(0,r):e;let a=!1;for(const e of o)if(a||(a=yield*oe(e,t)),a){const t=yield*te(e);if(t.Value!==S&&(n=t.Value),"normal"!==t.Type)return P(t,n)}if(!i)return x(n);let s=!1;const c=e.slice(r+1);if(!a)for(const e of c)if(s||(s=yield*oe(e,t)),s){const t=yield*te(e);if(t.Value!==S&&(n=t.Value),"normal"!==t.Type)return P(t,n)}if(s)return x(n);const l=yield*te(e[r]);if(l.Value!==S&&(n=l.Value),"normal"!==l.Type)return P(l,n);for(const e of c){const t=yield*te(e);if(t.Value!==S&&(n=t.Value),"normal"!==t.Type)return P(t,n)}return x(n)}(e.cases,t);return ne().LexicalEnvironment=n,ie(i)}case"TryStatement":{let t;try{t=yield*te(e.block)}catch(n){if(!e.handler)throw n;var s;ee=e.handler,null===(s=G.beforeEvaluate)||void 0===s||s.call(G,e.handler),t=yield*function*(e,t){if(!e.param)return yield*te(e.body);const n=ne().LexicalEnvironment,r=new h(n);for(const t of A(e.param))r.CreateMutableBinding(t,!1);ne().LexicalEnvironment=r,yield*Se(e.param,t,r);const i=yield*te(e.body);return ne().LexicalEnvironment=n,i}(e.handler,n)}finally{if(e.finalizer){const n=yield*te(e.finalizer);"normal"!==n.Type&&(t=n)}}return t}case"VariableDeclaration":{let t;for(const n of e.declarations)if(ee=n,n.init)if("Identifier"===n.id.type){ee=n.init,v&&"CallExpression"!==ee.type&&"TaggedTemplateExpression"!==ee.type&&(yield);const r=n.id.name,i=re(r);let o;o=ve(n.init)?ge(n.init,r):O(yield*te(n.init)),t="var"===e.kind?D(i,o):T(i,o)}else{ee=n.init,v&&"CallExpression"!==ee.type&&"TaggedTemplateExpression"!==ee.type&&(yield);const r=O(yield*te(n.init));t=yield*Se(n.id,r,"var"===e.kind?void 0:ne().LexicalEnvironment)}else t="var"===e.kind?x(S):T(re(n.id.name),void 0);return t}case"WhileStatement":return ie(yield*function*(e){let t;for(;;){if(!O(yield*te(e.test,void 0,!0)))return x(t);const n=yield*te(e.body);if(!V(n))return P(n,t);n.Value!==S&&(t=n.Value)}}(e))}throw new SyntaxError(`Unsupported node type \`${e.type}\``)}function ne(){return Q[Q.length-1]}function re(e,t){return t||(t=ne().LexicalEnvironment),N(t,e,!0)}function ie(e){return"break"===e.Type?e.Value===S?x(void 0):x(e.Value):e}function*oe(e,t){return t===O(yield*te(e.test))}function*ae(e,t,n,r){let i;for(se(r);;){if(e&&!O(yield*te(e,void 0,!0)))return x(i);const o=yield*te(n);if(!V(o))return P(o,i);o.Value&&(i=o.Value),se(r),t&&O(yield*te(t,void 0,!0))}}function se(e){if(0===e.length)return;const t=ne().LexicalEnvironment,n=t.OuterEnv,r=new h(n);for(const n of e){r.CreateMutableBinding(n,!1);const e=t.GetBindingValue(n,!1);r.InitializeBinding(n,e)}ne().LexicalEnvironment=r}function*ce(e,t){if("ObjectPattern"===e.type)return R(t),e.properties.length>0&&(yield*function*(e,t){const n=new Set;for(const r of e)if("Property"===r.type){const e=r.computed||"Identifier"!==r.key.type?yield*Ae(r.key):r.key.name,i="AssignmentPattern"===r.value.type?r.value.left:r.value;if("Identifier"===i.type){const o=re(i.name);let a=j(t,e);"AssignmentPattern"===r.value.type&&void 0===a&&(a=ve(r.value.right)?ge(r.value.right,i.name):O(yield*te(r.value.right))),D(o,a),n.add(e)}else yield*le(r.value,t,e),n.add(e)}else yield*ue(r,t,n)}(e.properties,t)),x(S);const n=M(t);return yield*function*(e,t){let n=x(S);for(const r of e){if(!r){t.next(),n=x(S);continue}const e="RestElement"===r.type?r.argument:"AssignmentPattern"===r.type?r.left:r,i="ArrayPattern"===e.type||"ObjectPattern"===e.type;let o,a;if(i||(o=(yield*te(e)).Value),"RestElement"!==r.type){const{done:n,value:i}=t.next(),o=n?void 0:i;a="AssignmentPattern"===r.type&&void 0===o?ve(r.right)&&"Identifier"===e.type?ge(r.right,e.name):O(yield*te(r.right)):o}else{a=new q;let e=0;for(;;){const{done:n,value:r}=t.next();if(n)break;a[e]=r,e++}}n=i?yield*ce(e,a):D(o,a)}return n}(e.elements,n)}function*le(e,t,n){const r="AssignmentPattern"===e.type?e.left:e,i="ArrayPattern"===r.type||"ObjectPattern"===r.type;let o;i||(o=(yield*te(r)).Value);const a=j(t,n);let s;return s="AssignmentPattern"===e.type&&void 0===a?O(yield*te(e.right)):a,i?yield*ce(r,s):D(o,s)}function*ue(e,t,n){return D((yield*te(e.argument)).Value,C({},t,n))}function de(e,t){const n=B(e,{var:!1,topLevel:!1});for(const e of n){const n="VariableDeclaration"===e.type&&"const"===e.kind;for(const r of A(e))n?t.CreateImmutableBinding(r,!0):t.CreateMutableBinding(r,!1);if("FunctionDeclaration"===e.type){const[n]=A(e),r=he(e,t);t.InitializeBinding(n,r)}}}function*fe(e,n,r,i){let o;n instanceof E&&I(n)&&(o=n.Base);const a=yield*ye(r);if("function"!=typeof e){const e=t.substring(i.start,i.end);throw new TypeError(`${e} is not a function`)}if(v||g){const t=e[d];if(t){const e=yield*t.apply(o,a);return H(e),x(e)}}const s=e.apply(o,a);return H(s),x(s)}function*ye(e){const t=[];if(Array.isArray(e))for(const n of e)if("SpreadElement"===n.type){const e=O(yield*te(n.argument));t.push(...e)}else t.push(O(yield*te(n)));else{t.push(function(e){const t=Y.get(e);if(t)return t;const n=e.quasis.map((e=>e.value.raw)),r=e.quasis.map((e=>e.value.cooked));return Object.freeze(n),Object.defineProperty(r,"raw",{value:n,writable:!1,enumerable:!1,configurable:!1}),Object.freeze(r),Y.set(e,r),r}(e));for(const n of e.expressions)t.push(O(yield*te(n)))}return t}function*pe(e,t,n){var c;null===(c=G.beforeCall)||void 0===c||c.call(G,e[o]),function(e,t,n){if(e[u]===i.LEXICAL)return;const r=t.LexicalEnvironment;null==r||r.BindThisValue(n)}(e,function(e){const t=new m;t.Function=e;const n=new b(e);return t.VariableEnvironment=n,t.LexicalEnvironment=n,Q.push(t),U.push(t),t}(e),t);const l=yield*function*(e,t){return yield*function*(e,t,n){return yield*function*(e,t){const n=ne(),o=e[s],c=e[a],l=A(c),d=L(c),f=B(o,{var:!0,topLevel:!0}),y=A(f),p=[],m=[];for(let e=f.length-1;e>=0;e--){const t=f[e];if("FunctionDeclaration"===t.type){Te(t);const[e]=A(t);p.includes(e)||(p.unshift(e),m.unshift(t))}else if(null!=r&&r.noVar)throw new SyntaxError("Var declaration is not recommended, use `let` or `const` instead")}const v=!!g&&e[u]!==i.LEXICAL,b=n.LexicalEnvironment;for(const e of l)b.CreateMutableBinding(e,!1);let E=l;if(v){const e=function(e){const t=[...e],n={};Object.defineProperty(n,"length",{value:t.length,writable:!0,configurable:!0});for(let e=0;e<t.length;e++)n[String(e)]=t[e];Object.defineProperty(n,Symbol.iterator,{value:Array.prototype.values,writable:!0,configurable:!0});const r=()=>{throw new TypeError("'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them")};return Object.defineProperty(n,"callee",{get:r,set:r}),n}(t);b.CreateImmutableBinding("arguments",!1),b.InitializeBinding("arguments",e),E=l.concat("arguments")}const w=M(t);let x;if(yield*Be(c,w,b),d){x=new h(b),n.VariableEnvironment=x;const e=[];for(const t of y)if(!e.includes(t)){let n;e.push(t),x.CreateMutableBinding(t,!1),E.includes(t)&&!p.includes(t)&&(n=b.GetBindingValue(t,!1)),x.InitializeBinding(t,n)}}else{const e=[...E];for(const t of y)e.includes(t)||(e.push(t),b.CreateMutableBinding(t,!1),b.InitializeBinding(t,void 0));x=b}const S=x;n.LexicalEnvironment=S;const I=B(o,{var:!1,topLevel:!0});for(const e of I)for(const t of A(e))"const"===e.kind?S.CreateImmutableBinding(t,!0):S.CreateMutableBinding(t,!1);for(const e of m){const[t]=A(e),n=he(e,S);x.SetMutableBinding(t,n,!1)}}(t,n),Array.isArray(e)?yield*me(e):new w("return",O(yield*te(e)))}(e[s],e,t)}(e,n);if(v&&(ee={...e[o],[p]:!0},yield{type:"return",value:"return"===l.Type?l.Value:void 0}),Q.pop(),U.pop(),"return"===l.Type)return l.Value}function*me(e){let t=x(S);for(const n of e){const e=yield*te(n);if("normal"!==e.Type)return e;t=P(t,e.Value)}return t}function ve(e){return"FunctionExpression"===e.type&&!e.id||"ArrowFunctionExpression"===e.type}function ge(e,t){var n;switch(null===(n=G.beforeEvaluate)||void 0===n||n.call(G,e),e.type){case"FunctionExpression":return be(e,t);case"ArrowFunctionExpression":return Ee(e,t);default:throw new Error(`Unexpected node type for NamedEvaluation: ${e.type}`)}}function he(e,t){const n=xe(e,t,!0,!1);return e.id&&we(n,e.id.name),n}function be(e,t){const n=ne().LexicalEnvironment;if(e.id){const t=e.id.name,r=new h(n);r.CreateImmutableBinding(t,!1);const i=xe(e,r,!0,!1);return we(i,t),r.InitializeBinding(t,i),i}{const r=xe(e,n,!0,!1);return we(r,t??""),r}}function Ee(e,t){const n=xe(e,ne().LexicalEnvironment,!1,!0);return we(n,t??""),n}function we(e,t){Object.defineProperty(e,"name",{value:t,configurable:!0})}function xe(e,t,n,r){const f=function(){return X(pe(f,this,arguments))};Object.defineProperties(f,{[o]:{value:e},[a]:{value:e.params},[s]:{value:"BlockStatement"===e.body.type?e.body.body:e.body},[c]:{value:t},[l]:{value:n},[u]:{value:r?i.LEXICAL:i.STRICT}});const y=function(e){let t=0;for(const n of e)switch(n.type){case"AssignmentPattern":case"RestElement":return t;default:t++}return t}(e.params);return Object.defineProperty(f,"length",{configurable:!0,value:y}),(v||g)&&Object.defineProperty(f,d,{value:function(){return pe(f,this,arguments)}}),f}function*Se(e,t,n){switch(e.type){case"Identifier":return function(e,t,n){return n.InitializeBinding(e,t),x(S)}(e.name,t,n);case"ObjectPattern":return R(t),yield*function*(e,t,n){const r=new Set;for(const i of e){if("RestElement"===i.type)return Le(i,t,n,r);if(i.computed||"Identifier"!==i.key.type){const e=yield*Ae(i.key);yield*Ie(i.value,t,n,e),r.add(e)}else yield*Ie(i.value,t,n,i.key.name),r.add(i.key.name)}return x(S)}(e.properties,t,n);case"ArrayPattern":{const r=M(t);return yield*Be(e.elements,r,n)}}}function*Ae(e){return F(O(yield*te(e)))}function Le(e,t,n,r){const i=re(e.argument.name,n),o=C({},t,r);return n?T(i,o):D(i,o)}function*Be(e,t,n){if(0===e.length)return x(S);let r;for(const i of e)if(i)if("RestElement"===i.type)if("Identifier"===i.argument.type){const e=re(i.argument.name,n),o=new q;let a=0;for(;;){const{done:i,value:s}=t.next();if(i){r=n?T(e,o):D(e,o);break}o[a]=s,a++}}else{const e=new q;let o=0;for(;;){const{done:a,value:s}=t.next();if(a){r=yield*Se(i.argument,e,n);break}e[o]=s,o++}}else{const e="AssignmentPattern"===i.type?i.left:i;switch(e.type){case"ObjectPattern":case"ArrayPattern":{let o;const{done:a,value:s}=t.next();a||(o=s),"AssignmentPattern"===i.type&&void 0===o&&(o=O(yield*te(i.right))),r=yield*Se(e,o,n);break}case"Identifier":{const o=e.name,a=re(o,n);let s;const{done:c,value:l}=t.next();c||(s=l),"AssignmentPattern"===i.type&&void 0===s&&(s=ve(i.right)?ge(i.right,o):O(yield*te(i.right))),r=n?T(a,s):D(a,s);break}}}else t.next(),r=x(S);return r}function*Ie(e,t,n,r){if("Identifier"===e.type||"AssignmentPattern"===e.type&&"Identifier"===e.left.type){const i="Identifier"===e.type?e.name:e.left.name,o=re(i,n);let a=j(t,r);return"AssignmentPattern"===e.type&&void 0===a&&(a=ve(e.right)?ge(e.right,i):O(yield*te(e.right))),n?T(o,a):D(o,a)}let i=j(t,r);return"AssignmentPattern"===e.type&&void 0===i&&(i=O(yield*te(e.right))),yield*Se("AssignmentPattern"===e.type?e.left:e,i,n)}function Te(e){if(e.async||e.generator)throw new SyntaxError((e.async?"Async":"Generator")+" function is not allowed");if(Z&&!e.expression)throw new SyntaxError("Only an `Expression` is allowed in `ArrowFunctionExpression`'s body")}if(Z)return O(X(te(e)));null===(n=G.beforeEvaluate)||void 0===n||n.call(G,e),Te(e);const[Ce]=A(e);K.CreateImmutableBinding(Ce,!0);const ke=he(e,K);return K.InitializeBinding(Ce,ke),v&&Object.defineProperties(ke,{[f]:{value:function(){return ne().LexicalEnvironment}},[y]:{value:function(){return ee}}}),ke}function X(e){for(;;){const{done:t,value:n}=e.next();if(t)return n}}class Z{constructor(){(0,r.A)(this,"VariableEnvironment",void 0),(0,r.A)(this,"LexicalEnvironment",void 0)}}class H{constructor(e){(0,r.A)(this,"OuterEnv",void 0),(0,r.A)(this,"bindingSet",new Set),this.OuterEnv=e}HasBinding(e){return this.bindingSet.has(e)}CreateBinding(e){this.bindingSet.add(e)}}function K(e){let{expressionOnly:t,visitors:n,withParent:r,externalSourceForDebug:i,hooks:o={}}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const a=new Set,s=[],c=new H(null),l=new Z;function u(){return s[s.length-1]}function d(e,t,n){for(const r of t)f(e[r],null==n?void 0:n.concat({node:e,key:r}))}function f(e,r){if(Array.isArray(e))e.forEach(((e,t)=>{f(e,r?r.slice(0,-1).concat({...r[r.length-1],index:t}):r)}));else if(e){var s,c;switch(null===(s=o.beforeVisit)||void 0===s||s.call(o,e,r),function(e){var t,r;n&&(t=n,r=e.type,Object.prototype.hasOwnProperty.call(t,r))&&n[e.type](e)}(e),e.type){case"Identifier":var l;return b=e.name,void(p(u().LexicalEnvironment,b)||(null===(l=o.beforeVisitGlobal)||void 0===l||l.call(o,e,r),a.add(e.name)));case"ArrayExpression":case"ArrayPattern":return void d(e,["elements"],r);case"ArrowFunctionExpression":return void v(g(e,u().LexicalEnvironment,!0),r);case"AssignmentPattern":case"BinaryExpression":case"LogicalExpression":return void d(e,["left","right"],r);case"CallExpression":case"NewExpression":return void d(e,["callee","arguments"],r);case"ChainExpression":return void d(e,["expression"],r);case"ConditionalExpression":return void d(e,["test","consequent","alternate"],r);case"MemberExpression":return d(e,["object"],r),void(e.computed&&d(e,["property"],r));case"ObjectExpression":case"ObjectPattern":return void d(e,["properties"],r);case"Property":return e.computed&&d(e,["key"],r),void d(e,["value"],r);case"RestElement":case"SpreadElement":case"UnaryExpression":return void d(e,["argument"],r);case"SequenceExpression":case"TemplateLiteral":return void d(e,["expressions"],r);case"TaggedTemplateExpression":return void d(e,["tag","quasi"],r);case"Literal":return}if(!t)switch(e.type){case"AssignmentExpression":return void d(e,["right","left"],r);case"BlockStatement":{if(!e.body.length)return;const t=u(),n=t.LexicalEnvironment,i=new H(n);return m(e.body,i),t.LexicalEnvironment=i,d(e,["body"],r),void(t.LexicalEnvironment=n)}case"BreakStatement":case"ContinueStatement":case"EmptyStatement":return;case"CatchClause":{const t=u(),n=t.LexicalEnvironment,i=new H(n);return y(e.param,i),t.LexicalEnvironment=i,d(e,["param","body"],r),void(t.LexicalEnvironment=n)}case"DoWhileStatement":return void d(e,["body","test"],r);case"ExpressionStatement":case"TSAsExpression":return void d(e,["expression"],r);case"ForInStatement":case"ForOfStatement":{const t="VariableDeclaration"===e.left.type&&"var"!==e.left.kind,n=u(),i=n.LexicalEnvironment;if(t){const t=new H(i);y(e.left,t),n.LexicalEnvironment=t}if(d(e,["right"],r),n.LexicalEnvironment=i,t){const t=new H(i);y(e.left,t),n.LexicalEnvironment=t}return d(e,["left","body"],r),void(n.LexicalEnvironment=i)}case"ForStatement":{var h;const t="VariableDeclaration"===(null===(h=e.init)||void 0===h?void 0:h.type)&&"var"!==e.init.kind,n=u(),i=n.LexicalEnvironment;if(t){const t=new H(i);y(e.init,t),n.LexicalEnvironment=t}return d(e,["init","test","body","update"],r),void(n.LexicalEnvironment=i)}case"FunctionDeclaration":{const[t]=A(e),n=u().LexicalEnvironment,i=g(e,n);return n.CreateBinding(t),void v(i,r)}case"FunctionExpression":{const t=function(e){const t=u().LexicalEnvironment;if(!e.id)return g(e,t);const n=e.id.name,r=new H(t);return r.CreateBinding(n),g(e,r)}(e);return void v(t,r)}case"IfStatement":return void d(e,["test","consequent","alternate"],r);case"ReturnStatement":case"ThrowStatement":case"UpdateExpression":return void d(e,["argument"],r);case"SwitchCase":return void d(e,["test","consequent"],r);case"SwitchStatement":{d(e,["discriminant"],r);const t=u(),n=t.LexicalEnvironment,i=new H(n);return m(e.cases,i),t.LexicalEnvironment=i,d(e,["cases"],r),void(t.LexicalEnvironment=n)}case"ThisExpression":if(!i)break;return;case"TryStatement":return void d(e,["block","handler","finalizer"],r);case"VariableDeclaration":return void d(e,["declarations"],r);case"VariableDeclarator":return void d(e,["id","init"],r);case"WhileStatement":return void d(e,["test","body"],r)}(null===(c=o.beforeVisitUnknown)||void 0===c?void 0:c.call(o,e,r))||console.warn(`Unsupported node type \`${e.type}\``)}var b}function y(e,t){for(const n of A(e))t.CreateBinding(n)}function p(e,t){return!!e&&(e.HasBinding(t)||p(e.OuterEnv,t))}function m(e,t){y(B(e,{var:!1,topLevel:!1}),t)}function v(e,t){!function(e){const t=new Z,n=new H(e.Environment);t.VariableEnvironment=n,t.LexicalEnvironment=n,s.push(t)}(e),function(e,t){const n=u(),r=e.ECMAScriptCode,o=e.FormalParameters,a=L(o),s=A(B(r,{var:!0,topLevel:!0})),c=!!i&&"LEXICAL"!==e.ThisMode,l=n.LexicalEnvironment;let d;if(y(o,l),c&&l.CreateBinding("arguments"),f(o,null==t?void 0:t.concat({node:e.Function,key:"params"})),a){d=new H(l),n.VariableEnvironment=d;for(const e of s)d.CreateBinding(e)}else{for(const e of s)l.CreateBinding(e);d=l}const p=d;n.LexicalEnvironment=p,y(B(r,{var:!1,topLevel:!0}),p)}(e,t),f(e.ECMAScriptCode,null==t?void 0:t.concat({node:e.Function,key:"body"}).concat("BlockStatement"===e.Function.body.type?{node:e.Function.body,key:"body"}:[])),s.pop()}function g(e,t,n){return{Function:e,FormalParameters:e.params,ECMAScriptCode:"BlockStatement"===e.body.type?e.body.body:e.body,Environment:t,ThisMode:n?"LEXICAL":"STRICT"}}return l.VariableEnvironment=c,l.LexicalEnvironment=c,s.push(l),f(e,r?[]:void 0),a}var J=n(3340);let Q=new WeakMap;function Y(e){let{typescript:t,cacheKey:n,...r}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=n?Q.get(n):void 0;return i||(i=function(e){let{typescript:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=(0,J.parse)(e,{plugins:["estree",t&&"typescript"].filter(Boolean),strictMode:!0,attachComment:!1}).program.body,r=t?[]:n;if(t)for(const e of n)if(e.type.startsWith("TS")){if(/Enum|Import|Export/.test(e.type))throw new SyntaxError(`Unsupported TypeScript syntax: ${e.type}`)}else r.push(e);if(0===r.length)throw new SyntaxError("Function declaration not found");if(r.length>1||"FunctionDeclaration"!==r[0].type)throw new SyntaxError(`Expect a single function declaration at top level, but received: ${r.map((e=>`"${e.type}"`)).join(", ")}`);return r[0]}(e,{typescript:t}),n&&Q.set(n,i)),{function:i,attemptToVisitGlobals:K(i,r)}}function ee(){Q=new WeakMap}const te=new Map;function ne(e){let{cache:t,...n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=[],i=e.replace(/^\s*<%[~=]?\s|\s%>\s*$/g,(e=>(r.push(e),"")));let o=t?te.get(i):void 0;return o||(o=function(e){return(0,J.parseExpression)(e,{plugins:["estree",["pipelineOperator",{proposal:"minimal"}]],attachComment:!1})}(i),t&&te.set(i,o)),{expression:o,attemptToVisitGlobals:K(o,{...n,expressionOnly:!0}),source:i,prefix:r[0],suffix:r[1]}}function re(e){return/^\s*<%[~=]?\s/.test(e)&&/\s%>\s*$/.test(e)}function ie(e){return/^\s*<%~\s/.test(e)}function oe(e){return/^\s*<%=\s/.test(e)&&/\s%>\s*$/.test(e)}function ae(){te.clear()}}}]);
//# sourceMappingURL=122.f47316f5.js.map