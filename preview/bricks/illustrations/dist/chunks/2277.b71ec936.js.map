{"version":3,"file":"chunks/2277.b71ec936.js","mappings":"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","sources":["webpack:///../../node_modules/@next-core/inject/dist/esm/interfaces.js","webpack:///../../node_modules/@next-core/inject/dist/esm/lexical.js","webpack:///../../node_modules/@next-core/inject/dist/esm/compile.js","webpack:///../../node_modules/@next-core/inject/dist/esm/syntax.js"],"sourcesContent":["export let LexicalStatus = /*#__PURE__*/function (LexicalStatus) {\n  LexicalStatus[LexicalStatus[\"Initial\"] = 0] = \"Initial\";\n  LexicalStatus[LexicalStatus[\"ExpectField\"] = 1] = \"ExpectField\";\n  LexicalStatus[LexicalStatus[\"ExpectOptionalBeginDefault\"] = 2] = \"ExpectOptionalBeginDefault\";\n  LexicalStatus[LexicalStatus[\"ExpectDefaultValue\"] = 3] = \"ExpectDefaultValue\";\n  LexicalStatus[LexicalStatus[\"ExpectOptionalBeginPipe\"] = 4] = \"ExpectOptionalBeginPipe\";\n  LexicalStatus[LexicalStatus[\"ExpectPipeIdentifier\"] = 5] = \"ExpectPipeIdentifier\";\n  LexicalStatus[LexicalStatus[\"ExpectOptionalBeginPipeParameter\"] = 6] = \"ExpectOptionalBeginPipeParameter\";\n  LexicalStatus[LexicalStatus[\"ExpectPipeParameter\"] = 7] = \"ExpectPipeParameter\";\n  LexicalStatus[LexicalStatus[\"ExpectPlaceholderEnd\"] = 8] = \"ExpectPlaceholderEnd\";\n  return LexicalStatus;\n}({});\nexport let TokenType = /*#__PURE__*/function (TokenType) {\n  TokenType[\"Raw\"] = \"Raw\";\n  TokenType[\"BeginPlaceHolder\"] = \"BeginPlaceHolder\";\n  TokenType[\"Field\"] = \"Field\";\n  TokenType[\"BeginDefault\"] = \"BeginDefault\";\n  TokenType[\"LiteralString\"] = \"LiteralString\";\n  TokenType[\"BeginPipe\"] = \"BeginPipe\";\n  TokenType[\"PipeIdentifier\"] = \"PipeIdentifier\";\n  TokenType[\"BeginPipeParameter\"] = \"BeginPipeParameter\";\n  TokenType[\"EndPlaceHolder\"] = \"EndPlaceHolder\";\n  TokenType[\"JsonValue\"] = \"JsonValue\";\n  return TokenType;\n}({});\nexport let JsonValueType = /*#__PURE__*/function (JsonValueType) {\n  JsonValueType[JsonValueType[\"Array\"] = 0] = \"Array\";\n  JsonValueType[JsonValueType[\"Object\"] = 1] = \"Object\";\n  JsonValueType[JsonValueType[\"String\"] = 2] = \"String\";\n  JsonValueType[JsonValueType[\"Others\"] = 3] = \"Others\";\n  return JsonValueType;\n}({});\n//# sourceMappingURL=interfaces.js.map","import { escapeRegExp } from \"lodash\";\nimport { LexicalStatus, TokenType, JsonValueType } from \"./interfaces.js\";\nexport function getRegExpOfPlaceholder(symbols) {\n  return new RegExp(`(${[].concat(symbols).map(symbol => escapeRegExp(symbol)).join(\"|\")})\\\\{`);\n}\nexport function tokenize(raw, symbols) {\n  const context = {\n    beginPlaceholder: getRegExpOfPlaceholder(symbols),\n    raw,\n    cursor: 0,\n    status: LexicalStatus.Initial,\n    tokens: []\n  };\n  while (context.cursor < raw.length) {\n    switch (context.status) {\n      case LexicalStatus.Initial:\n        eatOptionalRawAndOptionalPlaceholderBegin(context);\n        break;\n      case LexicalStatus.ExpectField:\n        eatWhitespace(context);\n        eatField(context);\n        break;\n      case LexicalStatus.ExpectOptionalBeginDefault:\n        eatWhitespace(context);\n        eatOptionalDefault(context);\n        break;\n      case LexicalStatus.ExpectDefaultValue:\n        eatWhitespace(context);\n        eatDefaultValue(context);\n        break;\n      case LexicalStatus.ExpectOptionalBeginPipe:\n        eatWhitespace(context);\n        eatOptionalBeginPipe(context);\n        break;\n      case LexicalStatus.ExpectPipeIdentifier:\n        eatWhitespace(context);\n        eatPipeIdentifier(context);\n        break;\n      case LexicalStatus.ExpectOptionalBeginPipeParameter:\n        eatWhitespace(context);\n        eatOptionalBeginPipeParameter(context);\n        break;\n      case LexicalStatus.ExpectPipeParameter:\n        eatWhitespace(context);\n        eatPipeParameter(context);\n        break;\n      case LexicalStatus.ExpectPlaceholderEnd:\n        eatWhitespace(context);\n        eatPlaceholderEnd(context);\n        break;\n    }\n  }\n  if (context.status !== LexicalStatus.Initial) {\n    throw new Error(\"Expected a placeholder end '}' at the end\");\n  }\n  return context.tokens;\n}\nfunction eatOptionalRawAndOptionalPlaceholderBegin(context) {\n  var _subRaw$match;\n  const subRaw = getSubRaw(context);\n  const matchedPlaceholder = (_subRaw$match = subRaw.match(context.beginPlaceholder)) === null || _subRaw$match === void 0 ? void 0 : _subRaw$match[0];\n  const subCursor = matchedPlaceholder ? subRaw.indexOf(matchedPlaceholder) : -1;\n  if (subCursor >= 0 && matchedPlaceholder && subRaw.charAt(subCursor + matchedPlaceholder.length) !== \"{\") {\n    const nextCursor = context.cursor + subCursor;\n    if (subCursor > 0) {\n      context.tokens.push({\n        type: TokenType.Raw,\n        value: subRaw.substring(0, subCursor)\n      });\n    }\n    context.tokens.push({\n      type: TokenType.BeginPlaceHolder,\n      loc: {\n        start: nextCursor,\n        end: nextCursor + matchedPlaceholder.length\n      },\n      value: matchedPlaceholder.substring(0, matchedPlaceholder.length - 1)\n    });\n    context.cursor += subCursor + matchedPlaceholder.length;\n    context.status = LexicalStatus.ExpectField;\n  } else {\n    context.tokens.push({\n      type: TokenType.Raw,\n      value: subRaw\n    });\n    context.cursor = context.raw.length;\n  }\n}\nfunction eatWhitespace(context) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  context.cursor += getSubRaw(context).match(/^[ \\r\\n\\t]*/)[0].length;\n}\nfunction eatField(context) {\n  // Only allow alphanumeric, `_`, `.`, `*`, `[`, `]`, `-` and other non-ascii.\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const [value] = getSubRaw(context).match(/^[\\w.*[\\]\\-\\u{80}-\\u{10FFFF}]*/u);\n  context.tokens.push({\n    type: TokenType.Field,\n    value\n  });\n  context.cursor += value.length;\n  context.status = LexicalStatus.ExpectOptionalBeginDefault;\n}\nfunction eatOptionalDefault(context) {\n  if (getSubRaw(context).charAt(0) === \"=\") {\n    context.tokens.push({\n      type: TokenType.BeginDefault\n    });\n    context.cursor += 1;\n    context.status = LexicalStatus.ExpectDefaultValue;\n  } else {\n    context.status = LexicalStatus.ExpectOptionalBeginPipe;\n  }\n}\nfunction eatDefaultValue(context) {\n  eatJsonValueOrLiteralString(context, LexicalStatus.ExpectOptionalBeginPipe);\n}\nfunction eatOptionalBeginPipe(context) {\n  if (getSubRaw(context).charAt(0) === \"|\") {\n    context.tokens.push({\n      type: TokenType.BeginPipe\n    });\n    context.cursor += 1;\n    context.status = LexicalStatus.ExpectPipeIdentifier;\n  } else {\n    context.status = LexicalStatus.ExpectPlaceholderEnd;\n  }\n}\nfunction eatPipeIdentifier(context) {\n  const matches = getSubRaw(context).match(/^[a-zA-Z]\\w*/);\n  if (!matches) {\n    throw new Error(`Expected a pipe identifier at index ${context.cursor} near: ${JSON.stringify(context.raw.substring(context.cursor))}`);\n  }\n  const value = matches[0];\n  context.tokens.push({\n    type: TokenType.PipeIdentifier,\n    value\n  });\n  context.cursor += value.length;\n  context.status = LexicalStatus.ExpectOptionalBeginPipeParameter;\n}\nfunction eatOptionalBeginPipeParameter(context) {\n  if (getSubRaw(context).charAt(0) === \":\") {\n    context.tokens.push({\n      type: TokenType.BeginPipeParameter\n    });\n    context.cursor += 1;\n    context.status = LexicalStatus.ExpectPipeParameter;\n  } else {\n    context.status = LexicalStatus.ExpectOptionalBeginPipe;\n  }\n}\nfunction eatPipeParameter(context) {\n  eatJsonValueOrLiteralString(context, LexicalStatus.ExpectOptionalBeginPipeParameter);\n}\nfunction eatPlaceholderEnd(context) {\n  if (getSubRaw(context).charAt(0) === \"}\") {\n    context.tokens.push({\n      type: TokenType.EndPlaceHolder,\n      loc: {\n        start: context.cursor,\n        end: context.cursor + 1\n      }\n    });\n    context.cursor += 1;\n    context.status = LexicalStatus.Initial;\n  } else {\n    throw new Error(`Expected a placeholder end '}' at index ${context.cursor} near: ${JSON.stringify(context.raw.substring(context.cursor))}`);\n  }\n}\nconst jsonLiteralMap = new Map([[\"false\", false], [\"null\", null], [\"true\", true]]);\nfunction eatJsonValueOrLiteralString(context, nextStatus) {\n  const subRaw = getSubRaw(context);\n  if (/[0-9[{\"]/.test(subRaw.charAt(0)) || /-[0-9]/.test(subRaw.substring(0, 2))) {\n    eatJsonValue(context, nextStatus);\n  } else {\n    // Accept any characters except controls and whitespace.\n    // Only allow alphanumeric, `_`, `-` and other non-ascii.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const [value] = getSubRaw(context).match(/^[\\w\\-\\u{80}-\\u{10FFFF}]*/u);\n    if (jsonLiteralMap.has(value)) {\n      context.tokens.push({\n        type: TokenType.JsonValue,\n        value: jsonLiteralMap.get(value)\n      });\n    } else {\n      context.tokens.push({\n        type: TokenType.LiteralString,\n        value\n      });\n    }\n    context.cursor += value.length;\n    context.status = nextStatus;\n  }\n}\n\n// 我们不需要非常精确地在一段字符串中匹配出一段*完整合法的* JSON value，\n// 而只需要找到一段*可能是完整合法的* JSON value 即可，解析的工作交给 `JSON.parse()`。\n// 由于 JSON 中 object/array/string 的镜像起止符特性，我们尝试去完成这些符号匹配即可。\nfunction eatJsonValue(context, nextStatus) {\n  const subRaw = getSubRaw(context);\n  const firstChar = subRaw.charAt(0);\n  const valueType = firstChar === \"[\" ? JsonValueType.Array : firstChar === \"{\" ? JsonValueType.Object : firstChar === '\"' ? JsonValueType.String : JsonValueType.Others;\n  let subCursor = 0;\n  let objectBracesToMatch = 0;\n  let arrayBracketsToMatch = 0;\n  let stringQuotesToClose = false;\n  let stringBackslashToEscape = false;\n  let matched = false;\n  while (subCursor < subRaw.length) {\n    const char = subRaw.charAt(subCursor);\n    if (stringBackslashToEscape) {\n      stringBackslashToEscape = false;\n    } else if (stringQuotesToClose) {\n      if (char === '\"') {\n        stringQuotesToClose = false;\n      } else if (char === \"\\\\\") {\n        stringBackslashToEscape = true;\n      }\n    } else {\n      switch (char) {\n        case \"[\":\n          arrayBracketsToMatch += 1;\n          break;\n        case \"{\":\n          objectBracesToMatch += 1;\n          break;\n        case \"]\":\n          arrayBracketsToMatch -= 1;\n          break;\n        case \"}\":\n          objectBracesToMatch -= 1;\n          break;\n        case '\"':\n          stringQuotesToClose = true;\n          break;\n      }\n    }\n    subCursor += 1;\n    switch (valueType) {\n      case JsonValueType.Array:\n        matched = !arrayBracketsToMatch;\n        break;\n      case JsonValueType.Object:\n        matched = !objectBracesToMatch;\n        break;\n      case JsonValueType.String:\n        matched = !stringQuotesToClose;\n        break;\n      default:\n        // 对于其它类型，如果下一个字符不再是这些值类型可能的字符时，我们认为 JSON value 完成匹配。\n        // 其它可能的值类型：number/boolean/null/undefined。\n        matched = subCursor < subRaw.length && /[^a-z0-9E.+-]/.test(subRaw.charAt(subCursor));\n    }\n    if (matched) {\n      break;\n    }\n  }\n  if (!matched) {\n    throw new Error(`Failed to match a JSON value at index ${context.cursor} near: ${JSON.stringify(context.raw.substring(context.cursor))}`);\n  }\n  context.tokens.push({\n    type: TokenType.JsonValue,\n    value: JSON.parse(subRaw.substring(0, subCursor))\n  });\n  context.cursor += subCursor;\n  context.status = nextStatus;\n}\nfunction getSubRaw(context) {\n  return context.raw.substring(context.cursor);\n}\n//# sourceMappingURL=lexical.js.map","import { get } from \"lodash\";\nimport { processPipes } from \"@next-core/pipes\";\nimport { parseInjectableString } from \"./syntax.js\";\nimport { getRegExpOfPlaceholder } from \"./lexical.js\";\nexport function transform(raw, context) {\n  return compile(raw, \"@\", context);\n}\nexport function inject(raw, context) {\n  return compile(raw, \"$\", context);\n}\nexport function transformAndInject(raw, context) {\n  return compile(raw, [\"@\", \"$\"], context);\n}\nfunction compile(raw, symbols, context) {\n  // const symbols = [\"@\", \"$\"];\n  if (!isInjectable(raw, symbols)) {\n    return raw;\n  }\n  const transformNode = transformNodeFactory(context.data);\n  const injectNode = injectNodeFactory(context, raw);\n  const tree = parseInjectableString(raw, symbols);\n  const values = tree.elements.map(node => node.type === \"RawString\" ? node.value : node.symbol === \"$\" ? injectNode(node) : transformNode(node));\n  return reduceCompiledValues(values);\n}\nfunction reduceCompiledValues(values) {\n  // If the whole string is a placeholder, we should keep the original value.\n  if (values.length === 1) {\n    return values[0];\n  }\n\n  // If an element is `undefined`, `null` or an empty array `[]`, it is converted to an empty string.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join#Description\n  return values.join(\"\");\n}\nfunction isInjectable(raw, symbols) {\n  return getRegExpOfPlaceholder(symbols).test(raw);\n}\nfunction transformNodeFactory(data) {\n  return function transformNode(node) {\n    // If meet `@{}`, return `data`.\n    let result = node.field ? get(data, node.field) : data;\n    if (result === undefined) {\n      result = node.defaultValue;\n    }\n    return processPipes(result, node.pipes);\n  };\n}\nfunction injectNodeFactory(context, raw) {\n  return function injectNode(node) {\n    const matches = node.field.match(/^(?:(QUERY(?:_ARRAY)?|EVENT|query|event|APP|HASH|ANCHOR|SYS|FLAGS|CTX)\\.)?(.+)$/);\n    if (!matches) {\n      // Keep the original raw partial when meet a unknown namespace.\n      return raw.substring(node.loc.start, node.loc.end);\n    }\n    let [, namespace, subField] = matches;\n\n    // Support namespace with no subfield such as `${ANCHOR}`.\n    // But distinguish with match params. E.g. `${query}` is a match param.\n    if (!namespace && /^[A-Z_]+$/.test(subField)) {\n      namespace = subField;\n      subField = \"*\";\n    }\n    let result;\n    const SimpleContextMap = {\n      SYS: \"sys\",\n      FLAGS: \"flags\"\n    };\n    switch (namespace) {\n      case \"QUERY\":\n      case \"query\":\n        if (subField === \"*\") {\n          result = context.query;\n        } else {\n          result = context.query.has(subField) ? context.query.get(subField) : undefined;\n        }\n        break;\n      case \"QUERY_ARRAY\":\n        result = context.query.has(subField) ? context.query.getAll(subField) : undefined;\n        break;\n      case \"EVENT\":\n      case \"event\":\n        if (context.event === undefined) {\n          // Keep the original raw partial when meet a `${EVENT}` in non-event context.\n          return raw.substring(node.loc.start, node.loc.end);\n        }\n        result = subField === \"*\" ? context.event : get(context.event, subField);\n        break;\n      case \"APP\":\n        result = subField === \"*\" ? context.overrideApp ?? context.app : get(context.overrideApp ?? context.app, subField);\n        break;\n      case \"HASH\":\n        result = context.location.hash;\n        break;\n      case \"SYS\":\n      case \"FLAGS\":\n        result = subField === \"*\" ? context[SimpleContextMap[namespace]] : get(context[SimpleContextMap[namespace]], subField);\n        break;\n      case \"ANCHOR\":\n        {\n          const anchor = context.location.hash ? context.location.hash.substr(1) : null;\n          result = subField === \"*\" ? anchor : get(anchor, subField);\n          break;\n        }\n      case \"CTX\":\n        {\n          const original = raw.substring(node.loc.start, node.loc.end);\n          // eslint-disable-next-line no-console\n          console.error(`CTX is not supported in placeholder any more: \"${original}\"`);\n          return original;\n        }\n      default:\n        if (context.match) {\n          result = context.match.params[subField];\n        } else {\n          // If the context is empty, return the original raw partial.\n          return raw.substring(node.loc.start, node.loc.end);\n        }\n    }\n    if (result === undefined) {\n      result = node.defaultValue;\n    }\n    return processPipes(result, node.pipes);\n  };\n}\n//# sourceMappingURL=compile.js.map","import { tokenize } from \"./lexical.js\";\nimport { TokenType } from \"./interfaces.js\";\nexport function parseInjectableString(raw, symbols) {\n  return parseTokens(tokenize(raw, symbols));\n}\nfunction parseTokens(tokens) {\n  const tree = {\n    type: \"InjectableString\",\n    elements: []\n  };\n  let token;\n  function optionalToken(type) {\n    if (type === tokens[0].type) {\n      token = tokens.shift();\n      return true;\n    }\n    return false;\n  }\n  function acceptToken(type) {\n    token = tokens.shift();\n    if (Array.isArray(type) ? !type.includes(token.type) : type !== token.type) {\n      throw new Error(`Expected token: ${type}, received token: ${token.type}`);\n    }\n  }\n  while (tokens.length > 0) {\n    if (optionalToken(TokenType.Raw)) {\n      tree.elements.push({\n        type: \"RawString\",\n        value: token.value\n      });\n    } else {\n      acceptToken(TokenType.BeginPlaceHolder);\n      const start = token.loc.start;\n      const symbol = token.value;\n      acceptToken(TokenType.Field);\n      const placeholder = {\n        type: \"Placeholder\",\n        symbol,\n        field: token.value,\n        defaultValue: undefined,\n        pipes: [],\n        loc: {\n          start,\n          end: start\n        }\n      };\n      tree.elements.push(placeholder);\n      if (optionalToken(TokenType.BeginDefault)) {\n        acceptToken([TokenType.JsonValue, TokenType.LiteralString]);\n        placeholder.defaultValue = token.value;\n      }\n      while (optionalToken(TokenType.BeginPipe)) {\n        acceptToken(TokenType.PipeIdentifier);\n        const pipe = {\n          type: \"PipeCall\",\n          identifier: token.value,\n          parameters: []\n        };\n        placeholder.pipes.push(pipe);\n        while (optionalToken(TokenType.BeginPipeParameter)) {\n          acceptToken([TokenType.JsonValue, TokenType.LiteralString]);\n          pipe.parameters.push(token.value);\n        }\n      }\n      acceptToken(TokenType.EndPlaceHolder);\n      placeholder.loc.end = token.loc.end;\n    }\n  }\n  return tree;\n}\n//# sourceMappingURL=syntax.js.map"],"names":["LexicalStatus","TokenType","JsonValueType","getRegExpOfPlaceholder","symbols","RegExp","concat","map","symbol","escapeRegExp","join","eatOptionalRawAndOptionalPlaceholderBegin","context","_subRaw$match","subRaw","getSubRaw","matchedPlaceholder","match","beginPlaceholder","subCursor","indexOf","charAt","length","nextCursor","cursor","tokens","push","type","Raw","value","substring","BeginPlaceHolder","loc","start","end","status","ExpectField","raw","eatWhitespace","eatField","Field","ExpectOptionalBeginDefault","eatOptionalDefault","BeginDefault","ExpectDefaultValue","ExpectOptionalBeginPipe","eatDefaultValue","eatJsonValueOrLiteralString","eatOptionalBeginPipe","BeginPipe","ExpectPipeIdentifier","ExpectPlaceholderEnd","eatPipeIdentifier","matches","Error","JSON","stringify","PipeIdentifier","ExpectOptionalBeginPipeParameter","eatOptionalBeginPipeParameter","BeginPipeParameter","ExpectPipeParameter","eatPipeParameter","eatPlaceholderEnd","EndPlaceHolder","Initial","jsonLiteralMap","Map","nextStatus","test","firstChar","valueType","Array","Object","String","Others","objectBracesToMatch","arrayBracketsToMatch","stringQuotesToClose","stringBackslashToEscape","matched","char","JsonValue","parse","eatJsonValue","has","get","LiteralString","transform","compile","inject","transformAndInject","isInjectable","transformNode","data","node","result","field","undefined","defaultValue","processPipes","pipes","injectNode","namespace","subField","SimpleContextMap","SYS","FLAGS","query","getAll","event","overrideApp","app","location","hash","anchor","substr","original","console","error","params","injectNodeFactory","values","tree","elements","token","optionalToken","shift","acceptToken","isArray","includes","placeholder","pipe","identifier","parameters","parseTokens","tokenize","parseInjectableString"],"sourceRoot":""}